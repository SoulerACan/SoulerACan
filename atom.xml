<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Souler ACan’s blog</title>
  
  <subtitle>who am i ？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-25T12:23:07.656Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ACan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于文件系统，以及history、cd、ls、touch、cp命令以及通配符</title>
    <link href="http://yoursite.com/2018/07/25/%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BB%A5%E5%8F%8Ahistory%E3%80%81cd%E3%80%81ls%E3%80%81touch%E3%80%81cp%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/25/关于文件系统，以及history、cd、ls、touch、cp命令/</id>
    <published>2018-07-25T12:30:00.000Z</published>
    <updated>2018-07-25T12:23:07.656Z</updated>
    
    <content type="html"><![CDATA[<p>#<strong>==DAY 3==</strong></p><p><strong>命令行扩展、被括起来的集合</strong></p><pre><code>``  $()  把一个命令的输出打印给另一个命令的参数&quot;&quot;弱引用 ，&apos;&apos;强引用{} 打印重复字符串的简化形式</code></pre><p><strong>文件通配符</strong></p><pre><code>*        --&gt; 匹配任意个字符？       --&gt; 匹配单个字符~        --&gt; 当前用户家目录~mage    --&gt; 用户mage家目录~+       --&gt; 当前工作目录~-       --&gt; 前一个工作目录[0-9]:   --&gt; 匹配数字范围[a-z]:   --&gt; 小写字母[A-Z]:   --&gt; 大写字母[qwer]   --&gt; 匹配列表中的任何的一个字符[^qwer]  --&gt; 匹配列表中的所有字符以外的字符</code></pre><p>  预定义支付类： man 7 glob</p><pre><code>[:digit:]：任意数字，相当于0-9[:lower:]：任意小写字母[:upper:]: 任意大写字母[:alpha:]: 任意大小写字母[:alnum:]：任意数字或字母[:blank:]：水平空白字符[:space:]：水平或垂直空白字符[:punct:]：标点符号[:print:]：可打印字符[:cntrl:]：控制（非打印）字符[:graph:]：图形字符[:xdigit:]：十六进制字符</code></pre><p>#TAB键补全命令</p><p>  前提是安装了程序 bash-completion<br>  查看该安装包版本<br>    $rpm -qa bash-completion&lt;&gt;.noarch<br>   centos 6<br>    支持命令、目录的补全；不支持补全命令选项参数<br>   centos 7<br>    支持命令、目录的补全；支持补全命令选项参数</p><p>#history命令</p><p>  history命令用于显示指定数目的指令命令，读取历史命令文件中的目录到历史缓存区和将历史命令缓存区中的目录写入命令文件。</p><pre><code>每个用户的家目录下有个 .bash_history的文件，是专门存放用户所输入的命令历史。.bash_history（并非即时记录，用户登出才会将history追加入文件，不正常关机则无法写入文件）</code></pre><p>  该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入!2。<br>  历史命令是被保存在内存中的，当退出或者登录Shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。</p><p>  1.命令格式<br>    history [选项][参数]<br>  2.命令功能<br>    可单独用于查看历史命令，也可配合参数调用或删除历史命令。<br>  3.命令参数<br>    -c  (常用)<br>    清除内存中的历史列表<br>    -d <n><br>    清除第n条命令<br>    <n>（常用）<br>    显示最近n条历史记录<br>    -a<br>    将当前的历史记录行追加到历史记录文件<br>    -r<br>    读取未读取的历史<br>    -w &lt;文件名&gt;<br>    将当前历史写到指定文件中<br>    -p<br>    执行且不留历史记录<br>    -s<br>    伪造历史记录，但不执行</n></n></p><p><strong>关于history调用</strong></p><p>  调用历史命令，n是命历史命令编号<br>    !n<br>  执行上一条命令<br>    !!<br>  执行前一条命令，去除参数<br>    !:0<br>  补全上一个命令<br>    Esc，.<br>  补全上一个命令<br>    按住alt+. </p><p><strong>关于命令历史相关变量</strong></p><pre><code>HISTSIZE  历史记录条数HISTFILE  存储历史文件HISTFILESIZE  命令历史文件记录历史条数HISTTIMEFORMAT= &quot;%F %T&quot; 显示时间HISTIGNORE=&quot;str1:str2* &quot; 忽略str1命令，str2开头的历史</code></pre><p><strong>控制历史命令记录的方式</strong></p><pre><code>环境变量：HISTCONTROLignoredups: 忽略重复的命令；连续且相同方为”重复“ignorespace: 忽略所有空白开头的命令ignoreboth: ignoredups,ignorespaceerasedups: 删除重复命令Export 变量名=&quot;值存放在 /etc/profile或 ~/.bash_profile</code></pre><p><strong>bash快捷键</strong></p><p>  Ctrl + l<br>    清屏，相当于clear命令<br>  Ctrl + o<br>    执行当前命令，并重新显示本命令<br>  Ctrl + s<br>    阻止屏幕输出，锁定<br>  Ctrl + q<br>    允许屏幕输出<br>  Ctrl + c<br>    终止命令<br>  Ctrl + z<br>    挂起命令bash的快捷键<br>  Ctrl + a<br>    光标移到命令行首，相当于Home<br>  Ctrl + e<br>    光标移到命令行尾，相当于End<br>  Ctrl + f<br>    光标向右移动一个字符<br>  Ctrl + b<br>    光标向左移动一个字符<br>  Alt + f<br>    光标向右移动一个单词尾<br>  Alt + b<br>    光标向左移动一个单词首<br>  Ctrl + xx<br>    光标在命令行首和光标之间移动<br>  Ctrl + u<br>    从光标处删除至命令行首<br>  Ctrl + k<br>    从光标处删除至命令行尾<br>  Alt + r<br>    删除当前整行bash的快捷键<br>  Ctrl + w<br>    从光标处向左删除至单词首<br>  Alt + d<br>    从光标处向右删除至单词尾<br>  Ctrl + d<br>    删除光标处的一个字符<br>  Ctrl + h<br>    删除光标前的一个字符<br>  Ctrl + y<br>    将删除的字符粘贴至光标后<br>  Alt + c<br>    从光标处开始向右更改为首字母大写的单词<br>  Alt + u<br>    从光标处开始，将右边一个单词更改为大写<br>  Alt + l<br>    从光标处开始，将右边一个单词更改为小写<br>  Ctrl + t<br>    交换光标处和之前的字符位置<br>  Alt + t<br>    交换光标处和之前的单词位置<br>  Alt + N<br>    提示输入指定字符后，重复显示该字符N次</p><p>####注意：Alt组合快捷键经常和其它软件冲突</p><p><strong>实验：录屏</strong></p><p>  创建一个录屏命令 （用于复现）复现<br>    $ script -t 2&gt; time.log -a cmd.session<br>    $ …..<br>    $ …..<br>    $ …..<br>  退出录屏<br>    $exit<br>  复现录像<br>    $ scriptptreplay time.log cmd.session</p><p>#####多用于动态演示</p><p><strong>文件系统分层结构  LSB</strong></p><pre><code>/bin -&gt;/usr/bin 存放供用户使用的二进制程序/boot 引导程序文件，例如：kernel/dev  存放设备文件   brw------- b打头  块设备，随机访问   crw------- c打头  字符设备，线性访问/etc  存放系统范围内的配置文件，，可编辑的文本配置  /etc/opt  opt的配置文件  /etc/X11  X Windows系统的配置文件  /etc/sgml SGML的配置文件  /etc/xml  XML的配置文件/usr   用户存储只读用户数据的第二层次，包含绝大多数的（多）用户工具和应用程序/home  普通用户的家目录，保存用户个人的配置文件，一般为单独的分区/lib   /bin/和/sbin/中二进制文件必要的库文件/sbin  给管理员使用的二进制程序/media 可移除媒体的挂载点，图形界面下，自动充当光盘挂载点，代替/run/media/misc  命令行界面,普通用户手动挂载（进入该文件夹/misc/cd，则自动挂载光盘，不进入则不挂在）     $ systemctl start autofs     $ systemctl enable autofs       查看块设备      $ df/mnt   临时挂载的文件系统，超级用户手动挂载 $ mount /dev/sr0 /mnt/opt   可选应用软件包/proc  虚拟文件系统，，将内核与进程状态归档为文本文件，存放于内存，磁盘中所占空间为0，修改文件立即生效，但断电后数据丢失，数据修改不保存。/sys  虚拟文件系统，存放于内存，映射硬件信息      当识别不出块设备，扫描所有磁盘      $ echo &apos;- - -&apos; &gt; /sys/class/scsi_host/host2/scan/root  超级用户的家目录/sbin  必要的系统二进制文件/srv   站点的具体数据，由系统提供/data/run  不属于linux标准目录，代替/var/run/var  动态文件————在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区，亦可称为变量文件/tmp  临时文件，在系统重启时目录中文件不会被保留</code></pre><p>#####标准可参考 FHS国际规范 </p><p><strong>文件系统</strong><br>  rootfs： root filesystem<br>  文件名大小写区分看文件系统：<br>  eg：<br>     文件系统 xfs 严格区分大小写<br>     文件系统 vfat 不区分大小写 </p><p>  文件有两类数据：<br>     数据：data   存放数据的内容<br>     元数据：metadata 存放数据的属性     </p><p><strong>文件特性</strong></p><p>  查看文件类型的颜色规则<br>    $ cat /etc/DIR_COLOR</p><pre><code>蓝色--&gt;目录绿色--&gt;可执行文件红色--&gt;压缩文件浅蓝色--&gt;链接文件灰色--&gt;其他文件亮黄色--&gt;设备文件</code></pre><p>  查看文件类型<br>    drwxr-xr-x.  5 root root      231 Jul 18 14:49 vmware-tools<br>    eg： 文件类型由字符串drwxr-xr-x的第一位来表示，当前字符串第一位为d，由此我们可以得出该文件类型是目录文件</p><pre><code>-：普通文件d：目录文件b：块设备c：字符设备l：符号链接文件p：管道文件pises：套接字文件socker</code></pre><p><strong>显示当前工作目录</strong><br>  pwd命令</p><pre><code>$ pwd 显示连接路径$ pwd -P  显示真实物理路径</code></pre><p>  路径分为两种：相对路径，绝对路径</p><p>   相对路径（方便文件转移后的运行）<br>     不以正斜杠开始<br>     指定相对于当前工作目录或某目录的位置<br>     eg：<br>        $ cd home/xu<br>     在每个目录下都有’.’和’..’ ，相对路径中经常会使用到<br>      ‘.’表当前目录，’..’表父目录</p><p>   绝对路径<br>     以正斜杠开始<br>     完整的路径位置<br>     eg:<br>        $cd /home/xu<br>  基名：basename<br>  目录名：dirname</p><p><strong>cd命令</strong><br>  用于切换目录</p><p>  1.命令格式<br>     cd &lt;路径&gt;<br>  2.命令功能<br>     使用绝对或相对路径切换目录<br>  3.命令参数<br>    cd<br>      切换至当前用户主目录<br>    cd ..<br>      切换至父目录<br>    cd ~<br>      切换到当前登录用户的家目录<br>    cd ~用户名<br>      切换到指定用户家目录<br>    cd -<br>      切换回上次的目录，原理：由变量$OLDPWD控制<br>      可以手动更改变量 $OLDPWD=/路径名</p><p><strong>ls命令</strong></p><p>  ls命令是linux下最常用的命令。ls命令就是list的缩写，ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。<br>  通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多!</p><p>  1.命令格式<br>    ls [选项][参数]<br>  2.命令功能<br>    列出名表目录中所有的子目录和文件<br>  3.命令参数<br>    -d，<br>    列出目录本身，而不是其内容<br>    -a，<br>    列出所有文件以及文件夹（包括隐藏）<br>    -l<br>    使用长列表格式<br>    -A，<br>    不列出’.’(表当前目录)和’..’（表当前目录的父目录）<br>    -u，–time=atime, –time=access,–time= use<br>    与-l配合使用，显示访问时间<br>    -c，–time=ctime, –time=status<br>    与-l配合使用，显示权限修改时间<br>    -1<br>    显示另一列文件<br>    -S<br>    按文件从大到小排序<br>    -r，<br>    排序时的逆序<br>    -Sr<br>    反转，按文件小到大排序<br>    -R，<br>    以递归方式列出子目录<br>    -X<br>    按后缀排序<br>    -U<br>    不排序;按目录顺序列出条目<br>    -p，<br>    追加/指标到目录<br>    -n， -num-uid-gid<br>    像-l，但列出数字用户和组ID<br>    -o<br>    像-l，但不列出组信息<br>    （还有一些不懂怎么用，没列出来）</p><p><strong>touch命令</strong></p><p>  linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。</p><p>  1.命令格式<br>    touch [选项]..文件名..<br>  2.命令功能<br>    创建一个不存在的文件。<br>    touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。<br>  3.命令参数<br>    -r &lt;指定文档&gt; &lt;参考文档&gt;<br>    将文件时间与指定参考文件时间对齐。<br>    -c &lt;文件名&gt;<br>    若文件名不存在，则不创建。<br>    -t[[CC]YY]MMDDhhmm[.SS] &lt;文件名&gt;<br>    设定文件的时间戳<br>    [[CC]YY]MMDDhhmm[.SS]<br>    eg：2018年07月24日14点20分00秒;对应格式：201807241420.00<br>    -m 配合-t使用，修改Modify time 修改时间<br>    -a 配合-t使用，修改Acess time 访问时间</p><p><strong>cp命令</strong></p><p>  cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。<br>  一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。<br>  这说明命令行和shell脚本的执行方式有些不同。 </p><p>  1.命令格式<br>    cp[选项].. 源 目的<br>  2.命令功能<br>    将源文件复制至目标文件，或将多个源文件复制至目标目录。<br>  3.命令参数<br>    -a,-archive<br>    与-dR –preserve = all相同<br>    –attributes-only<br>    不要复制文件数据，只复制属性<br>    -i<br>    覆盖前询问<br>    -n<br>    不覆盖已存在的文件<br>    –backup[=CONTROL]<br>    备份每个现有目标文件,接受参数<br>    -b像–backup但不接受参数<br>    –copy-contents<br>    递归时复制特殊文件的内容<br>    -d与–no-dereference –preserve=links<br>    相同<br>    -f,–force<br>    如果无法打开现有目标文件，请将其删除并尝试<br>    再次（当使用-n选项时忽略此选项）<br>    -H<br>    遵循SOURCE中的命令行符号链接<br>    -l,–link<br>    硬链接文件而不是复制<br>    -L,–dereference<br>    始终遵循SOURCE中的符号链接<br>    -P,–no-dereference<br>    永远不要在SOURCE中关注符号链接<br>    -p与–preserve = mode，ownership，timestamps<br>    相同</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#&lt;strong&gt;==DAY 3==&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令行扩展、被括起来的集合&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;``  $()  把一个命令的输出打印给另一个命令的参数

&amp;quot;&amp;quot;弱引用 ，&amp;apos;&amp;ap
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人blog搭建（纯属笔记，不做任何解释）</title>
    <link href="http://yoursite.com/2018/07/22/%E4%B8%AA%E4%BA%BAblog%E6%90%AD%E5%BB%BA%EF%BC%88%E7%BA%AF%E5%B1%9E%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%B8%8D%E5%81%9A%E4%BB%BB%E4%BD%95%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/22/个人blog搭建（纯属笔记，不做任何解释）/</id>
    <published>2018-07-22T04:35:00.000Z</published>
    <updated>2018-07-22T05:14:49.345Z</updated>
    
    <content type="html"><![CDATA[<p>==<strong>windows下搭建hexo</strong>==</p><p>大致浏览即可，细节操作在下面的总结那<br>一.环境准备</p><p>1.安装node.js(npm也在安装包中)（默认安装即可，一路Next。。）<br>    安装包：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><pre><code>为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的</code></pre><p>   检查安装是否成功,出现版本号则说明 Node.js 环境配置成功<br>    node -v、npm -v</p><p>2.安装git（默认安装即可，也是一路Next。。）<br>    安装包：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p><pre><code>为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上</code></pre><p>   检查安装是否成功,出现版本号则说明 git 环境配置成功<br>    git -v<br>3.安装控制台Cmder（默认安装即可）<br>    安装包：<a href="http://cmder.net/" target="_blank" rel="noopener">http://cmder.net/</a></p><p>#个人使用爱好，可不装，用Windows自带cmd即可</p><p>4.安装Sublime Text 3（默认安装即可）<br>    安装包：<a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">https://www.sublimetext.com/3</a></p><p>#只要是支持.md的文本工具即可</p><p>二.GitHub的注册和配置<br>    官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>1.拥有一个GitHub账号，没有的话去官网注册一下，很简单就不多说了<br>    官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>2.在GitHub创建一个仓库</p><h1 id="yourname-必须是你的用户名。"><a href="#yourname-必须是你的用户名。" class="headerlink" title="yourname 必须是你的用户名。"></a>yourname 必须是你的用户名。</h1><pre><code>图片1（待上传）图片2（待上传） . . .</code></pre><p>3.配置SSH密钥</p><p>   1）在桌面空白处鼠标右键打开Git bash here,键入命令（$ 无需键入..）<br>    $ ssh-keygen -t rsa -C “your’s emaill address”<br>   引号内填入你注册时所用的邮箱，回车<br>   显示你ssh密钥生成后保存的目录，直接回车确认（记住目录名，后面要找它拿东西的）<br>   会提示你设置密码（需要输入两次，密码看不见的）设置完密码之后<br>   会生成两个文件&lt;id_rsa&gt;、&lt;id_rsa.pub&gt;<br>   前往目录寻找文件&lt;id_rsa.pub&gt;，使用sublime text3 打开，并复制所有内容<br>   2）将SSH密钥存入GitHub</p><h1 id="ssh-T-git-github-com-选择性设置，用于设置自动填入密码"><a href="#ssh-T-git-github-com-选择性设置，用于设置自动填入密码" class="headerlink" title="$ ssh -T git@github.com(选择性设置，用于设置自动填入密码)"></a>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>(选择性设置，用于设置自动填入密码)</h1><pre><code>图片1（待上传）图片2（待上传） . .</code></pre><p>三.环境配置完成，开始安装Hexo，以及利用hexo建立本地网站</p><p>1.win+r 打开Cmder控制台，键入命令</p><pre><code>$ npm install -g hexo-cli</code></pre><p>  会报错，正常现象<br>    npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\chokidar\node_modules\fsevents):<br>    npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href="mailto:fsevents@1.0.17" target="_blank" rel="noopener">fsevents@1.0.17</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”win32”,”arch”:”x64”})<br>关于这个两个报错：fsevent是mac osx系统的，你是在win或者Linux下使用了 所以会有警告，忽略即可</p><p>   安装需要点时间，请耐心等待，安装成功后会有提示<br>    $ hexo -v<br>   检查安装是否成功,出现版本号则说明 hexo 安装成功</p><p>2.在任意一个分区创建任意一个文件夹，并该目录建立网站</p><p>#路径中不要有中文<br>    eg:创建test文件夹，路径为F:\test<br>git<br>    hexo init f:\test         创建一个网站，可能需要等待一小会，耐心等待<br>  成功提示：INFO  Start blogging with Hexo!</p><p>3.配置test目录下的_config.yml，生成静态文件<br>    配置_config.yml，用sublime text3 打开编辑并保存<br>  直接到文本尾部</p><pre><code># Deployment   deploy:     type: git     repository: https://github.com/xucanbin/xucanbin.github.io.git     branch: master$ npm install hexo-deployer-git --save         安装一个插件</code></pre><p>  在test目录中，鼠标右键打开git bash  </p><pre><code>$ ls            检查下目录下是不是出现多个文件，都是用于搭建网站的，这就是hexo的强大之处了$ hexo g        生成静态文件。$ hexo s        启动服务器。默认情况下，访问网址为： http://localhost:4000/</code></pre><p>   尝试能否访问<a href="http://localhost:4000/，当然这只是本地的网页，没什么用。" target="_blank" rel="noopener">http://localhost:4000/，当然这只是本地的网页，没什么用。</a><br>   成功则如图<br>   由于source目录下自带一篇hello world文章，所以你网页上自动生成了。</p><p>四.配置test目录下的_config.yml</p><p>五.将hexo建立网站的目录（亦可称为本地仓库）与github同步</p><p> 在test目录下，新建一个README.md，并鼠标右键打开git bash<br> 并新建一个README.md ，用sublime text 3 打开编辑随意写点东西，后面会用到</p><p>将当前目录转变成一个 Git 仓库</p><pre><code>$ git init </code></pre><p>配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息</p><pre><code>$ git config --global user.name &quot;Your&apos;s name&quot;           引号中填自己的GitHub账号$ git config --global user.email &quot;Your&apos;s email address&quot; 引号中填注册GitHub的邮箱$ git add README.md       将README.md添加到索引$ git commit -m &quot;first commit&quot;添加远程仓库$ git remote add origin git@github.com:yourname/yourname.github.io.git$ ssh -T git@github.com$ git push -u origin master$ hexo g$ hexo d</code></pre><p>二次总结</p><p>关于搭建个人博客的事情我自己总结了几点</p><p>hexo 是帮你搭建了一个本地网站</p><p>git 是用于配置giuhub上的仓库以及ssh密钥</p><p>node.js的话，主要是其环境下的npm，依赖npm去安装hexo </p><p>我们创建自己的博客网站 其实就是把hexo创建的本地网站 所生成的静态页面部署到GitHub上<br>请准备好<git>好&lt;node.js&gt;环境，才能开始下列操作<br>实现部署的前提，拥有一个github账号以及在github上创建一个库命名格式为&lt;账号名.github.io.git&gt;</git></p><p>#命名格式必须遵守，不然无法成功（目前我是找不到其他方法啦）<br>1.安装并使用hexo,生成本地网站之后，配置本地网站中的_config.yml</p><pre><code>$ npm install -g hexo-cli   (还未分清楚用cmd还是git-bash安装，待测试)$ hexo --version    </code></pre><p>2.使用hexo建立本地网站</p><pre><code>$ hexo init &lt;目录名&gt;         亦可进入目录下打开git-bash键入</code></pre><p>3.生成静态页面，也就是你未来的blog网站，</p><pre><code>$ hexo g</code></pre><p>##｛以下操作可跳过<br>       $ hexo s       启动服务器，尝试进入本地网站，正常的话可以访问：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> </p><p>##以上操作可跳过｝</p><p>4.配置本地网站中的_config.yml</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><pre><code>deploy:  type: git  repository: https://github.com/xucanbin/xucanbin.github.io.git  branch: master</code></pre><p>5.安装hexo的deployer插件（必须装的插件）</p><pre><code>$ npm install hexo-deployer-git --save  (成功提示待测试)</code></pre><p>6.本地git仓库（这是把本地网站目录转换为git仓库的操作，我记得会有有一个.git）</p><pre><code>$ git init &lt; 目录名&gt;    亦可进入目录下打开git bash 直接键入</code></pre><p>7.ssh密钥   (使用git-bash)</p><pre><code>$ ssh-keygen -t rsa -C &quot;your&apos;s emaill address&quot; </code></pre><p>   引号内填入你注册时所用的邮箱，回车<br>   显示你ssh密钥生成后保存的目录，直接回车确认（记住目录名，后面要找它拿东西的）<br>   会提示你设置密码（需要输入两次，密码看不见的）设置完密码之后<br>   会生成两个文件&lt;id_rsa&gt;、&lt;id_rsa.pub&gt;<br>   前往目录寻找文件&lt;id_rsa.pub&gt;，使用sublime text3 打开，并复制所有内容<br>   将SSH密钥存入GitHub，附图片</p><p>##（待上传）##<br>8.配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息<br>      （在仓库目录下打开git-bash） </p><pre><code>$ git config --global user.name &quot;Your&apos;s name&quot;           引号中填自己的GitHub账号$ git config --global user.email &quot;Your&apos;s email address&quot; 引号中填注册GitHub的邮箱$ git add README.md               将README.md添加到索引$ git commit -m &quot;first commit&quot;    记录对存储库的更改,使用给定的&quot;&quot;first commit&quot;&quot;作为提交消息</code></pre><p>9.添加git远程仓库（在仓库目录下打开git-bash）<br>  添加远程仓库</p><pre><code>$ git remote add origin git@github.com:xucanbin/xucanbin.github.io.git</code></pre><p>10.推送到远程仓库（将 master 分支推送到 origin 服务器）（在仓库目录下打开git-bash）</p><pre><code>$ git push origin master</code></pre><p>11.基于被配置完后的_config.yml,再次生成静态网页（在仓库目录下打开git-bash）</p><pre><code>$hexo g</code></pre><p>12.将第二次生成的静态网页部署到git的远程仓库中（在仓库目录下打开git-bash）</p><pre><code>$hexo d        后续弹出一个窗口 输入git用户名以及密码</code></pre><p>基础搭建完成<br>test目录下 f:\test\source_post\<br>上传文章的方法</p><p>以后写的博客直接放在里面，格式要求 后缀的.md<br>git-bash下</p><pre><code>$ hexo g$ hexo d$ git push origin master</code></pre><p>最后，打开自己的博客就能看到文章所在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;==&lt;strong&gt;windows下搭建hexo&lt;/strong&gt;==&lt;/p&gt;
&lt;p&gt;大致浏览即可，细节操作在下面的总结那&lt;br&gt;一.环境准备&lt;/p&gt;
&lt;p&gt;1.安装node.js(npm也在安装包中)（默认安装即可，一路Next。。）&lt;br&gt;    安装包：&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux基础知识</title>
    <link href="http://yoursite.com/2018/07/21/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/07/21/linux基础知识/</id>
    <published>2018-07-21T07:45:00.000Z</published>
    <updated>2018-07-21T07:49:52.359Z</updated>
    
    <content type="html"><![CDATA[<p>==<strong>DAY 1</strong>==</p><h2 id="认识计算机"><a href="#认识计算机" class="headerlink" title="认识计算机"></a>认识计算机</h2><p><strong>世界上第一台计算机</strong></p><pre><code>计算机：一种能接受和存储信息，对海量数据进行自动、高速地处理，并输出结果的现代化智能设备。</code></pre><p><strong>冯·诺依曼体系结构</strong>：1946年数学家冯·诺依曼提出计算机有5个组成部分：运算器、控制器、存储器（主存储器、辅助存储器）、输入设备、输出设备。</p><pre><code>1946年，世界上第一台计算机在美国滨州大学诞生。占地170平方米，重达30吨。</code></pre><p>计算机发展历史：</p><pre><code>第一代（电子管时代）：1946-1957  第二代（晶体管时代）：1958-1964第三代（集成电路时代）：1965-1970第四代（大规模集成电路时代）：1971以后```</code></pre><p><strong>计算机系统</strong></p><p>1.硬件系统</p><pre><code>主机     中央处理器CPU          运算器ALU          控制器CU     内部存储器          rom          ram（断电丢失数据） 外部设备     外部存储器：硬盘、U盘     输入设备：鼠标、键盘     输出设备：显示屏、打印机、音频</code></pre><p>2.软件系统</p><pre><code>系统软件：     操作系统：win7、linux、mac     程序语言处理系统     数据库服务系统     服务程序：检查、诊断、调试程序应用软件：     通用应用软件--如QQ、office办公     专用应用软件--用户程序</code></pre><p><strong>服务器种类</strong></p><pre><code> 塔式服务器tower机架式服务器rack规格：宽度为19英寸，高度以U为单位，如42U（约2米高）。       1U=44.45毫米=1.75英寸。配件：     KVM（Keyboard Video Mouse）     PDU (Power Distribution Unit)刀片式服务器blade</code></pre><p><strong>存储网络：</strong></p><pre><code>DAS---直接连接存储(direct attached storage)与主机紧密相连     优点：         管理成本低，实施简单。     缺点：         存储共享受到限制。         不利于CPU的指令周期优化，增加系统负担。NAS---网络连接存储(network attached storage)基于文件协议（NFS、SMB/CIFS）,实现文件共享，适用于局域网或较小的网络     优点：         集中管理数据，从而释放带宽，提高性能。         可提供跨平台文件共享功能。     缺点：         可靠性差。    SAN---存储区域网络(storage area networks)基于SCSI、IP、ATM等多种高级协议，实现存储共享     优点：         服务器跟储存装置两者各司其职，         高效能、高稳定度的存储环境。     缺点：         实施复杂，管理成本高。</code></pre><p><strong>操作系统</strong><br>(Operating System)：</p><pre><code>OS功能：     硬件驱动、进程管理、内存管理、网络管理、安全管理、文件管理。OS分类：     服务器OS:REHL,CentOS,window server,AIX     桌面OS:WIN7,WIN10,MAC0S,Fedora     移动设备OS:Android,IOS,YunOS</code></pre><p><strong>开发接口</strong></p><p>ABI接口 （应用接口）</p><pre><code>OS与应用程序的底层接口,允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行如.apk无法在win7上运行如.exe无法在Android上运行</code></pre><p>API接口 （开发接口）</p><pre><code>库调用源代码和库之间的接口，实现库调用，因此同样的源代码可以在支持这个API的任何系统中编译</code></pre><p>POSIX:Portable Operating System Interface</p><pre><code>IEEE（国际组织）在操作系统上定义的一系列API标准</code></pre><p><strong>==练习==：</strong></p><pre><code>1.显示当前时间，格式：2016-06-18 10：20：30 2.显示前天是星期几3.设置当前时间为2019-08-07 06：05：10</code></pre><p>1.答：</p><pre><code>$ date %F&apos; &apos;%T</code></pre><p>2.答：</p><pre><code>$ date -d “2 days ago” +%A</code></pre><p>3.答：</p><pre><code>$ date 080706052019.10</code></pre><p>==<strong>DAY 2</strong>==</p><p>用户和内核空间</p><p>用户空间 user space</p><pre><code>用户空间必须通过系统接口（system call），才能向内核发出指令。</code></pre><p>内核空间 kerneL space</p><pre><code>内核空间可以执行任意命令，调用系统的一切资源。</code></pre><p>用户与内核的联系</p><pre><code>用户的程序无法直接访问硬件，只能通过操作系统间接访问硬件。两个空间相对独立，防止损害硬件，但用户能通过操作系统间接访问硬件。</code></pre><p>原理：</p><pre><code>上下文切换，会带来额外的资源损耗，减少上下文切换的次数，可以降低资源损耗。相当于用户空间与内核空间的来回切换。user space     user land application     #library#函数库,API接口     ↓↓↓     ↓↓↓（invoke）     ↓↓↓kernel space     #system call#系统调用接口     kernel     device driver     ↓↓↓hardware</code></pre><p>查看库调用</p><pre><code>$ ldd /bin/command$ ldd /bin/command</code></pre><p>跟踪底层系统调用</p><pre><code>$ strace command </code></pre><p>跟踪底层库调用</p><pre><code>$ ltrace command </code></pre><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>低级语言</p><pre><code> 机器语言：0、1汇编语言:和机器语言一一对应(学汇编，不会编)</code></pre><p>中级语言:系统级应用、驱动程序</p><pre><code>C语言</code></pre><p>高级语言：应用级程序开发</p><pre><code>Java、Python、Go、PHP、Objective-C、C#</code></pre><p>查看16进制的2进制代码</p><pre><code>$ hexdump -c  /bin/ls </code></pre><p>兼容分时系统工作原理</p><pre><code>原理：时间片 1s对于计算机来讲，相当的漫长 eg：1s分为100个时间片，每个时间片10ms任务绑定cpu：task cpu（主要是利用cpu中的三级缓存&quot;cache，L1,L2,L3&quot;，提高任务处理效率)</code></pre><p><strong>Linux起源</strong></p><pre><code>1991年的10月5日，完全免费的内核kernel诞生了</code></pre><p>兼容分时系统：Multics（多路信息计算系统）</p><pre><code>1964年发起了开发计划，于1969年失败，贝尔实验室退出计划。而后，ken thompson 为了打游戏，写了一个系统UNICS.（unix雏形）1969 ，雏形初现unics，基于B语言开发   1973，正式命名unix，基于C语言开发1977，BSD,伯克利大学流派开始开发1979，贝尔实验室流派，system V架构，因版权问题，不对学生提供源码，开始收费1984，minix操作系统，由Andrew S.Tanenbaum开发</code></pre><p>GUN（GNU is Not Unix）</p><pre><code>1984，由Richard Stallman发起并创建目的是为了所有软件开源、自由</code></pre><p>GPL(GUN General Public License)</p><pre><code>允许用户任意复制、传递、修改及再发布</code></pre><p>LGPL(Lesser General Public License)</p><pre><code>LGPL相对GPL较为宽松，允许不公开所有源码</code></pre><p>查看bash遵守GPL协议</p><pre><code>$ rpm -qi bash </code></pre><p>完整的类UNIX操作系统</p><pre><code>Linux内核+GNU工具</code></pre><p>linux三大主流</p><pre><code>Debian --UbantuRedHat --CentOSSlackware  --S.U.S.E</code></pre><p><strong>查看内核版本</strong></p><pre><code>$ uname -r </code></pre><p><strong>版本号解读</strong></p><pre><code>3.10.0-862.el7.x86_64 内核版本号 &apos;3.10.0&apos; 编译次数 &apos;862&apos;  次 厂商版本 &apos;el&apos; 商业Lunix 版本号 &apos;7&apos; centos7  &apos;x86-64&apos;  64位</code></pre><p><strong>登录前界面的配置文件</strong></p><pre><code>$ cat /etc/issue</code></pre><p><strong>哈希值校验</strong>（安装系统后检查系统的完整性）</p><pre><code>$ sha1sum /dev/sr0   </code></pre><p><strong>虚拟机软件:模拟硬件环境</strong></p><pre><code>vmware</code></pre><p><strong>windows下CMD命令行转换分区格式，数据不丢失（单向的FAT格式转NTFS ）</strong></p><pre><code>$ conver H:/fs:ntfs</code></pre><p><strong>Linux 准备</strong></p><pre><code>/dev/sda==硬盘/home/xu==c:\user/etc==注册表/usr==C:\Windows and C:\program files/boot 启动 mount point 挂载点</code></pre><p><strong>引导分区格式 MBR &amp; GPT</strong></p><p>MBR（主分区与扩展分区合起来不超过4个）</p><pre><code>MBR（主分区与扩展分区合起来不超过4个）主分区：     一个硬盘最多4个，主分区最小单位，只有一个活动的主分区。扩展分区：     一个硬盘最多只有一个扩展分区。但不可存储，需再次划分为更小的分区才能存储数据，即逻辑分区。逻辑驱动器：     由扩展分区二次划分。</code></pre><p>GPT（待补充）</p><p><strong>linux中分区格式</strong></p><pre><code>主分区编号：/dev/sda1~4 扩展分区编号：：/dev/sda5，6...</code></pre><p><strong>centos分区大小</strong> （建议）</p><pre><code>/boot 1g   系统挂载点/     50g   根目录/data 20g   做实验用的目录swap  2g    虚拟内存，大小一般为内存的1.5倍或者2倍</code></pre><p><strong>更改主机名</strong></p><pre><code>centos6$ nano /etc/sysconfig/networkcentos7$ nano /etc/hostname</code></pre><p>引导程序：</p><pre><code>$ grub</code></pre><p>查看内存：  </p><pre><code>$ free$ cat /proc/meminfo</code></pre><p>查看内存使用：</p><pre><code>$ free -h</code></pre><p><strong>用户id号：</strong></p><pre><code>id为0，则为管理员，与root名字无关</code></pre><p>uid</p><pre><code>超级用户root   uid：0普通用户       uid：500+或者1000+</code></pre><p>查看uid</p><pre><code>$ id -u   centos6 id 普通用户从500开始计算。。501 centos7 id 普通用户从1000开始计算。。1001</code></pre><p><strong>终端：</strong></p><p>物理终端</p><pre><code>/dev/tty* </code></pre><p>虚拟终端</p><pre><code>/dev/pts*</code></pre><p>查看当前终端：</p><pre><code>$ tty$ whoami$ who am i</code></pre><p>查看所有在线终端：</p><pre><code>$ who</code></pre><p>切换终端：</p><pre><code>$ chvt &lt;终端号&gt;$ ctrl+F1~F6</code></pre><p>关机命令：</p><pre><code>$ halt；$ poweroff；$ shutdown -r now</code></pre><p>设置登录前界面显示</p><pre><code>$ nano /etc/issue \d 天数  \l 显示当前登录终端号 \n 显示主机名字 \t 显示当前时间 \r 显示内核版本 \s 显示系统版本</code></pre><p><strong>==练习==：</strong></p><pre><code>1.在本机字符终端登录时，除显示原有信息外，再显示当前登录终端号，主机名和当前时间2.今天18：30自动关机，并提示用户</code></pre><p>1.答：  </p><pre><code>$ nano /etc/issue 在文件中加入以下代码 You are login on \l The hostname is \n It&apos;s \t now!</code></pre><p>2.答：</p><pre><code>$ shutdown 18：30 “you were be shutdown”</code></pre><p>==<strong>DAY</strong> 3==</p><p>多数企业基于安全问题，防止被针对版本漏洞而受到攻击，有关版本号的信息会进行自主修改。</p><p>许多公司在生产中所用系统版本相对滞后，以求稳定。</p><p>linux的系统相关配置皆放在文本文件中。</p><p><strong>查看centos版本</strong></p><p>centos6</p><pre><code>$ lsb_release -a （此程序centos7默认没有安装）</code></pre><p>centos7</p><pre><code>$ cat /etc/centos-release</code></pre><h6 id="字符界面下的编辑文本工具"><a href="#字符界面下的编辑文本工具" class="headerlink" title="字符界面下的编辑文本工具"></a>字符界面下的编辑文本工具</h6><pre><code>$ nano &lt;目录&gt;</code></pre><p>指定用户开机自动登录</p><pre><code>   编辑配置文件$ nano /etc/gdm/custom.conf   在字符 [daemon]下加入两行代码 [daemon] AutomaticLoginEnable=true AutomaticLogin=&lt;user&gt;</code></pre><p>查看cpu详细信息</p><pre><code>$ lscpu    Flags:所带有的关键特性，eg：mmx，针对视频加速处理的一个特性</code></pre><p>查看块设备</p><pre><code>$ lsblk</code></pre><p>查看网卡</p><pre><code>$ dmesg</code></pre><h3 id="交互式口"><a href="#交互式口" class="headerlink" title="交互式口"></a>交互式口</h3><p><strong>操作linux需要交互式接口</strong></p><p>图形化用户接口GUI(Graphic User Interface)</p><pre><code>GNOME(C,GTK)KDE(C++,QT)XFCE(轻量级桌面)应用于：X protocol, window manager, desktop三者之间的区别：底层库不同</code></pre><p>命令行接口CLI （效率高）</p><pre><code>shell程序：sh(bourn史蒂夫·伯恩)cshtcshksh(korn)bash (bournagain shell)GPLzshshell也被称为命令解释器。shell也属于开发语言，是一种简化、功能较弱的高级语言。</code></pre><h6 id="除了以上常提到的shell，还有一种shell较为特殊的shell-：nologin"><a href="#除了以上常提到的shell，还有一种shell较为特殊的shell-：nologin" class="headerlink" title="除了以上常提到的shell，还有一种shell较为特殊的shell ：nologin"></a>除了以上常提到的shell，还有一种shell较为特殊的shell ：nologin</h6><h6 id="用于底层系统服务，而非用户使用。"><a href="#用于底层系统服务，而非用户使用。" class="headerlink" title="用于底层系统服务，而非用户使用。"></a>用于底层系统服务，而非用户使用。</h6><p>查看当前所用shell</p><pre><code>$ echo $SHELL</code></pre><p>查看系统含有的所有shell</p><pre><code>$ cat /bin/shells</code></pre><p><strong>PS1变量 （用于命令行提示符）</strong></p><p>临时更改命令行提示符颜色</p><pre><code>$ PS1=&quot;\[\e[1;40;31m\][\u@\h \W]$\[\e[0m\]&quot;</code></pre><h6 id="1代表高亮-31-37代表字体颜色-40代表背景色"><a href="#1代表高亮-31-37代表字体颜色-40代表背景色" class="headerlink" title="1代表高亮,31~37代表字体颜色,40代表背景色"></a>1代表高亮,31~37代表字体颜色,40代表背景色</h6><p>永久更改命令提示符行颜色</p><pre><code>1.在/etc/profile.d/目录下2.创建&lt;任意名&gt;.sh3.将PS1=&quot;\[\e[1;40;31m\][\u@\h\W]$\[\e[0m\]&quot; 复制进去，保存4.source 文件，或者重启即可</code></pre><p><strong>PATH变量（用于存放外部命令的所有路径点）</strong></p><pre><code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><p><strong>帮助命令</strong></p><pre><code>$ help commandhelp中带*的表示被禁用</code></pre><h6 id="（）16进制中，0a换行符号，0d回车"><a href="#（）16进制中，0a换行符号，0d回车" class="headerlink" title="（）16进制中，0a换行符号，0d回车"></a>（）16进制中，0a换行符号，0d回车</h6><h3 id="三大类命令"><a href="#三大类命令" class="headerlink" title="三大类命令"></a>三大类命令</h3><p><strong>内部命令</strong></p><p>集成于当前系统所使用shell中的一些命令</p><p>查看所有内部命令</p><pre><code>$ enable</code></pre><p>禁用内部命令</p><pre><code>$ enable -n command</code></pre><p>启用内部命令</p><pre><code>$ enable command</code></pre><p>查看被禁用命令 </p><pre><code>$ enable -n</code></pre><p>查看可用命令</p><pre><code>$ enable -p</code></pre><p><strong>外部命令</strong></p><p>外部命令是在磁盘中独立的文件，使用的时候需要到磁盘中读取。</p><p>外部命令执行一次会产生缓存，有个命令叫hash，会从$PATH这个变量中定义的路径去搜索外部命令，从而执行该命令。</p><p>原理：</p><pre><code>外部命令一旦执行过后，命令所在路径会被hash缓存到内存中，下次再执行命令的时候就不必再到路径中去搜索，直接从hash中的路径读取，不用再到各个路径中去搜索，从而提升速度。</code></pre><p>关于hash的使用：</p><pre><code>$ hash                显示 hash 缓存 $ hash – l            显示 hash 缓存，可作为输入使用 $ hash – p path name  将命令全路径 path 起 别名为 name $ hash – t name       打印缓存中 name 的路径 $ hash – d name       清除 name 缓存 $ hash – r            清除缓存</code></pre><p><strong>别名命令</strong> <strong>alias</strong></p><p>外部命令与内部命令都可以被写为别名。</p><p>要想别名重启后不丢失永久生效，需将命令写当前用户目录下的.bashrc中</p><pre><code>$ nano /home/name/.bashrc      (普通用户,name换成你的用户名)$ nano /root/.bashrc           (超级用户)$ nano /etc/.bashrc            (所有用户）</code></pre><p>查看所有别名</p><pre><code>$ alias</code></pre><p>创建别名命令</p><pre><code>eg：  $ ailas copy=&apos;cp&apos; | &quot;cp&quot;  （&apos;&apos;跟&quot;&quot;都能学习）  $ alias -p copy=&apos;cp&apos;  （创建别名并打印出所有别名，仅支持&apos;&apos;）</code></pre><p>取消别名</p><pre><code>$ unalias </code></pre><p>取消所有别名</p><pre><code>$ unalias -r</code></pre><p>忽视别名的存在，强制执行原始命令</p><pre><code>$ \command$ `command`</code></pre><p><strong>判断命令的类别</strong> （tpye）</p><p>外部命令显示（路径）：</p><pre><code>eg：$ type echo    $ echo is /usr/bin/echo</code></pre><p>内部命令显示：</p><pre><code>eg：$ type type    $ type is a shell builtin</code></pre><p>别名命令则显示：（假设存在别名 alias copy=’cp’）</p><pre><code>eg：$ type copy    $ copy is aliased to `cp&apos;  </code></pre><p>显示命令的所有路径（或者类别）：</p><pre><code>$ type -a </code></pre><h6 id="优先级：别名命令-gt-内部命令-gt-外部命令"><a href="#优先级：别名命令-gt-内部命令-gt-外部命令" class="headerlink" title="优先级：别名命令&gt;内部命令&gt;外部命令"></a>优先级：别名命令&gt;内部命令&gt;外部命令</h6><p>在linux中，内存，属于易失性，要想配置永久生效，就要写到文件中。</p><p><strong>command</strong><br>组成部分</p><pre><code>[短选项]:-（可多个选项合并使用）eg:    $ ls -a -l    $ ls -la     $ ls -al  等同[长选项]:--eg：    $ ls --all    $ ls --help[参数]    可以是文件，也可以是路径等等。</code></pre><p><strong>快捷键</strong>（待补充）</p><p>快速退出终端</p><pre><code>ctrl+d </code></pre><p>强制结束</p><pre><code>ctrl+c </code></pre><p><strong>日期和时间</strong></p><p>硬件时间</p><pre><code>$ clock = $ hwclock $ clock   显示硬件时间$ clock -s，--systohc修正系统时间，以硬件时间为准$ clock -w，--hctosys修正硬件时间，以系统时间为准</code></pre><p>系统时间</p><pre><code>$ date     显示系统时间$ date +%s 计算从1970.1.1至今一共多少秒$ date -s  根据描述设置时间$ date -d  根据描述显示时间$ date -d  @&lt;秒&gt; +&quot;%F %T&quot;$ date -d &quot;2018-08-08 20:00:00&quot;+%s</code></pre><p>时区路径 /etc/localtime</p><p>更改时区</p><p>centos6.x</p><pre><code>$ tzselect</code></pre><p>centos7.x</p><pre><code>$ timedatectl set-timezone &lt;时区路径&gt;</code></pre><p>日历</p><pre><code>$ cal 显示当月日历$ cal -y 显示当年日历$ cal &lt;年份&gt; 显示该年份日历</code></pre><h6 id="与远程服务器同步时间"><a href="#与远程服务器同步时间" class="headerlink" title="与远程服务器同步时间"></a>与远程服务器同步时间</h6><pre><code>$ ntpdate &lt;ip&gt;      （ip较为特殊，需配置过的ip地址才能同步）</code></pre><h6 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h6><p>发送消息给所有在线主机，多用于提示</p><pre><code>$ wall “system will shutdown at 19：00 ”</code></pre><h4 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h4><p>获取帮助的能力决定了技术的能力</p><p>了解外部命令的基本功能</p><pre><code>$ whatis</code></pre><p>系统使用一定时间后，会生成生成数据库或者手动创建数据库</p><pre><code>$ whatis command数据库</code></pre><p><strong>手动创建whatis数据库</strong></p><p>centos 6.x</p><pre><code>$ makewhatis</code></pre><p>centos 7.x</p><pre><code>$ mandb</code></pre><p>了解命令的基本功能</p><pre><code>内部命令：$ help command外部命令：$ command --help</code></pre><p>寻找命令所在路径</p><pre><code>$ whereis</code></pre><h6 id="man-and-info（有待详细说明）"><a href="#man-and-info（有待详细说明）" class="headerlink" title="man and info（有待详细说明）"></a>man and info（有待详细说明）</h6><p>man帮助（manual用户手册）</p><p>man章节分类</p><pre><code>1.用户命令2.系统调用3.C库调用4.设备文件及特殊文件5.配置文件格式6.游戏7.杂项8.管理类命令9.Linux内核API</code></pre><p>使用命令获取章节号</p><pre><code>$ whatis command</code></pre><p>指定man章节号寻找帮助</p><pre><code>$ man &lt;章节号&gt; command</code></pre><p>在man中搜索关键词</p><pre><code>/ &lt;关键词&gt;  or ?&lt;关键词&gt;</code></pre><p>man的配置文件目录</p><p>centos6</p><pre><code>man.conf(作用待了解)</code></pre><p>centos7</p><pre><code>man_db.conf(作用待了解)</code></pre><p>待续….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;==&lt;strong&gt;DAY 1&lt;/strong&gt;==&lt;/p&gt;
&lt;h2 id=&quot;认识计算机&quot;&gt;&lt;a href=&quot;#认识计算机&quot; class=&quot;headerlink&quot; title=&quot;认识计算机&quot;&gt;&lt;/a&gt;认识计算机&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;世界上第一台计算机&lt;/stron
      
    
    </summary>
    
    
  </entry>
  
</feed>
