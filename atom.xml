<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Souler ACan’s blog</title>
  
  <subtitle>who am i ？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-02T13:19:02.667Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ACan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>进程和计划任务以及shell编程进阶</title>
    <link href="http://yoursite.com/2018/09/02/%E7%AC%AC%E4%B8%83%E5%91%A8-%E8%BF%9B%E7%A8%8B%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8Ashell%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2018/09/02/第七周-进程和计划任务以及shell编程进阶/</id>
    <published>2018-09-02T13:00:00.000Z</published>
    <updated>2018-09-02T13:19:02.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七周"><a href="#第七周" class="headerlink" title="第七周"></a>第七周</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><p><strong>内核的功能：</strong><br>    进程管理、文件系统、网络功能、内存管理、驱动程序、安全功能等  </p><p><strong>进程(process)：</strong><br>    指正在执行中的程序，占用内存空间<br>    进程编号：PID,用来标记各个进程<br>    进程元数据：PID,UID,GID<br>    进程存在生命期  </p><p><strong>进程数据结构：</strong><br>    task struct：Linux内核存储进程信息的数据结构格式<br>    task list：多个任务的task struct组成的链表   </p><p><strong>task命令</strong><br>    task -cp 0 <pid> 把进程绑定在第一个CPU上<br><strong>进程precess创建：</strong></pid></p><pre><code>操作系统中的第一个进程：      centos6中的第一个进程init      centos7中的第一个进程systemd  进程：由父进程创建,CoW机制     进程有父进程和子进程、进程又可创建多个线程    CoW机制：写实复制        写时复制（Copy-on-Write，也缩写为COW），顾名思义，就是在写入时才真正复制一份内存进行修改。        fork()、clone()    线程(thread)：        在pstree中            {}表示线程        一个进程中至少有一个线程        同一个进程中的线程共享进程资源</code></pre><p><strong>pstree命令</strong>  </p><pre><code>用于查看进程树  选项：  -p 查看进程树和pid</code></pre><h2 id="进程的状态和优先级"><a href="#进程的状态和优先级" class="headerlink" title="进程的状态和优先级"></a>进程的状态和优先级</h2><p><strong>基本状态</strong></p><p>进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化。通常进程有以下五种状态，前三种是进程的基本状态。</p><pre><code>就绪状态：    进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行阻塞状态：    又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。运行状态：    进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态创建状态：    进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的PCB，并向PCB中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源；最后把该进程转入到就绪状态。终止状态：     进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。</code></pre><p><strong>状态切换</strong></p><pre><code>就绪状态 -&gt; 运行状态：    处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。运行状态 -&gt; 就绪状态：    处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。运行状态 -&gt; 阻塞状态：    当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。阻塞状态 -&gt; 就绪状态：    当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。以下两种状态是不可能发生的：阻塞状态 -&gt; 运行状态：    即使给阻塞进程分配CPU，也无法执行，操作系统在进行调度时不会从阻塞队列进行挑选，而是从就绪队列中选取就绪状态 -&gt; 阻塞状态：    就绪状态根本就没有执行，谈不上进入阻塞状态</code></pre><p><strong>DMA设备</strong><br>DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到暂存器，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。</p><pre><code>总结结：内存直接访问，大大提示了CPU的利用率</code></pre><h2 id="进程优先级："><a href="#进程优先级：" class="headerlink" title="进程优先级："></a>进程优先级：</h2><p><strong>进程优先级</strong>  </p><pre><code>系统优先级：      数字越小，优先级越高      0-139(centos4，5)          各有140个运行队列和过期队列      0-99(centos6)  实时优先级：      99-0 值最大，优先级越高  nice优先级：      -20到19，对应系统优先级100-139  原理：CUP时间片切换      运行队列与等待队列来回切换  </code></pre><p><strong>Big O</strong><br>    时间复杂度，用时和规模的关系：<br>        O(1)、<br>        O(logn)、<br>        O(n)、<br>        O(n^2)、<br>        O(2^n)</p><h2 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h2><p><strong>进程内存</strong></p><pre><code>page frame：存储页面数据，存储Page 4K涉及LRU算法：近期最少使用算法，释放内存    不断的淘汰垫底的数据物理地址空间和线性地址空间MMU:负责转换线性和wuliTLB:保存虚拟地址和物理地址映射关系的缓存</code></pre><p><strong>IPC:Inter Process Communication</strong></p><pre><code>同一主机：    signal：信号    shm：shared memory    semaphore：信号量，一种计数器不同主机：    socker：IP和端口号    RPC：remote procedure call    MQ：消息队列,Kafka，ActiveMQ    </code></pre><p><strong>进程状态</strong></p><pre><code>Linux内核：抢占式多任务    进程类型：    守护进程：daemon，在系统引导过程中启动的进程，和终端无关    前台进程：跟终端相关，通过终端启动的进程    两者可互相转化进程状态：    运行态：running    就绪态：ready    睡眠态：        可中断：interruptable        不可中断：uninterruptable    停止态：stopped        休眠于内存，但不会被调度，除非手动启动    僵死态：zombie        结束进程，父进程结束前，子进程不关闭</code></pre><h2 id="系统管理工具"><a href="#系统管理工具" class="headerlink" title="系统管理工具"></a>系统管理工具</h2><p><strong>进程的分类</strong></p><pre><code>CPU-Bound：CPU密集型，非交互IO-Bound：IO密集型，交互linux系统各进程的相关信息均保存在/proc/PID目录下的各文件中</code></pre><p><strong>pstree命令</strong></p><pre><code>显示进程的树状结构选项：    -p 显示线程</code></pre><p><strong>ps工具</strong></p><pre><code>ps：process state 进程状态 ，当前进程的快照三种格式的选项    UNIX风格的短选项    BSD风格的选项    GNU风格的长选项默认显示当前终端的开启的相关进程BSD选项：    a 显示所有和终端有关的进程    x 显示和终端无关的进程    u 显示进程所有者的信息    k &lt;属性&gt;，排序     -&lt;属性&gt;，倒序    o 显示指定属性的信息    f 显示进程树    L 显示支持的属性列表UNIX风格选项：    -C 显示指定命令列表，单个，可多个    -L 显示线程    -e 显示所有进程    -f 显示的属性更加丰富    -H 显示子进程和父进程    -u 显示有效的用户ID    -U 显示真正的用户ID    -p 显示指定pid的进程    --ppid 显示属于pid的子进程常见组合：    aux    -ef    -eFH    -eo    axoeg:按cpu百分比排序        ps axo pid,%cpu k %cpups输出属性：    VSZ：虚拟内存集,线性内存    RSS：常驻内存集    STAT:进程状态        R:running        S:interruptable sleeping        D:uninterruptable sleeping        T:stopped        Z:zombie        +:前台进程        l:多线程进程        L:内存分页并带锁        N:低优先级进程        &lt;:高优先级进程        s:子进程发起者        ni:nice值        pri:priority 优先级        psr：processor CPU编号        rtprio：实时优先级        </code></pre><p><strong>进程优先级</strong></p><pre><code>优先级调整：    静态优先级：100-139    进程默认启动时的nice值为0，优先级为120    只有根用户才能降低nice值    nice -n &lt;优先级&gt; PID    renice -n &lt;优先级&gt; PID查看nice优先级(ni参数)    ps axo pid,comm,ni</code></pre><p><strong>搜索进程</strong></p><pre><code>pgrep命令搜索进程选项：    -U 进程发起者    -u 进程生效者    -l 显示进程名    -t &lt;终端&gt; 显示指定终端运行的进程    -a 显示完整格式的进程名    -P &lt;PID&gt; 显示指定进程的子进程pidof    pidof &lt;进程名&gt; 显示进程是否正常工作以及显示PID</code></pre><p><strong>系统工具</strong></p><pre><code>uptime命令    显示当前时间，系统已启动时间，当前在线人数，以及系统平均负载情况(1/5/10)系统平均负载：    指在特定时间间隔内运行队列中的平均进程数通常每个CPU内核的当前活动进程数不大于3,那么系统的性能良好。如果每个CPU内核的任务数大于5，那么此主机的性能有严重问题如果linux主机是一个双核CPU，当Load Average为6的时候说明机器已经被充分使用</code></pre><p><strong>进程管理工具</strong><br>top工具：可以实时动态地查看系统的整体运行情况，是一个综合了多方信息监测系统性能和运行信息的实用工具。通过top命令所提供的互动式界面，用热键可以管理。</p><pre><code>top命令    选项：        -d # 指定刷新时间间隔，默认3秒        -b 显示所有进程        -n # 刷新指定次数后退出        -H 线程模式    内置选项：        P 以%CPU排序        M 以%MEM排序        T 以占据CPU时长排序        l 显示uptime信息        t 显示cpu信息        m 显示memory信息        s 修改刷新时间间隔        k 杀死指定进程    退出：q    保存文件:W  </code></pre><p>htop工具：top的花里胡哨版</p><pre><code>htop命令(需安装，使用epel源，花里胡哨的，支持鼠标点击)    选项：        -d # 指定刷新时间间隔        -u &lt;username&gt; 仅显示指定用户的进程        -s 以指定字段进行排序</code></pre><h2 id="内存工具"><a href="#内存工具" class="headerlink" title="内存工具"></a>内存工具</h2><p><strong>free命令</strong></p><pre><code>功能：    用来查看内存使用情况的主要命令。和top命令相比,它的优点是使用简单,并且只占用很少的系统资源。选项：    -h   人类易读格式    -b 　以Byte为单位显示内存使用情况。     -k 　以KB为单位显示内存使用情况。     -m 　以MB为单位显示内存使用情况。    -g   以GB为单位显示内存使用情况。     -o 　不显示缓冲区调节列。     -s&lt;间隔秒数&gt; 　持续观察内存使用状况。     -t 　显示内存总和列。     -V 　显示版本信息</code></pre><p><strong>iostat命令</strong></p><pre><code>功能：    统计CPU和设备IO信息    通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况,    负载信息。选项：    -C 显示CPU使用情况    -d 显示磁盘使用情况    -k 以 KB 为单位显示    -m 以 M 为单位显示    -N 显示磁盘阵列(LVM) 信息    -n 显示NFS 使用情况    -p[磁盘] 显示磁盘和分区的情况    -t 显示终端和CPU的信息    -x 显示详细信息    -V 显示版本信息</code></pre><p><strong>pmap命令</strong></p><pre><code>功能：    提供了进程的内存映射，用于显示一个或多个进程的内存状态用法：pmap &lt;PID&gt;选项：    -x extended显示扩展格式    -d device显示设备格式    -q quiet不显示header/footer行    -V 显示版本信息</code></pre><p><strong>glances命令</strong></p><pre><code>功能：    远程监视 CPU，平均负载，内存，网络流量，磁盘 I/O，其他处理器 和 文件系统 空间的利用情况。使用方法：    C/S模式下运行glances命令    服务端先开启        glances -s -B &lt;服务端地址&gt;    客户端连接进去远程监控服务端        glances -c &lt;服务端地址&gt;选项：    -b：显示网络连接速度 Byte/ 秒    -B @IP|host ：绑定服务器端 IP 地址或者主机名称    -c @IP|host：连接 glances 服务器端    -C file：设置配置文件默认是 /etc/glances/glances.conf     -d：关闭磁盘 I/O 模块    -e：显示传感器温度    -f file：设置输出文件（格式是 HTML 或者 CSV）    -m：关闭挂载的磁盘模块    -n：关闭网络模块    -p PORT：设置运行端口默认是 61209     -P password：设置客户端 / 服务器密码    -s：设置 glances 运行模式为服务器    -t sec：设置屏幕刷新的时间间隔，单位为秒，默认值为 2 秒，数值许可范围：1~32767     -h : 显示帮助信息    -v : 显示版本信息交互式选项：    h ：显示帮助信息    q ：离开程序退出    c ：按照 CPU 实时负载对系统进程进行排序    m ：按照内存使用状况对系统进程排序    i ：按照 I/O 使用状况对系统进程排序    p ：按照进程名称排序    d ：显示磁盘读写状况     w ：删除日志文件    l ：显示日志    s ：显示传感器信息    f ：显示系统信息    1 ：轮流显示每个 CPU 内核的使用情况（次选项仅仅使用在多核 CPU 系统）</code></pre><p><strong>vmstat工具</strong></p><pre><code>功能：    用于查看虚拟内存信息用法：    vmstat n #      n表示刷新时间间隔，#表示扫描次数选项：    -s 显示内存的统计数据所显示参数的含义详解procs:    r：可运行（正运行或等待运行）进程的个数，和核心数有关    b：处于不可中断睡眠态的进程个数(被阻塞的队列的长度)memory：    swpd: 交换内存的使用总量    free：空闲物理内存总量    buffer：用于buffer的内存总量    cache：用于cache的内存总量swap:    si：从磁盘交换进内存的数据速率(kb/s)    so：从内存交换至磁盘的数据速率(kb/s)io：    bi：从块设备读入数据到系统的速率(kb/s)    bo: 保存数据至块设备的速率system：    in: interrupts  每次CUP的中断次数，包括时间中断    cs: context switch  进程上下文切换速率cpu：    us:Timespent running non-kernel code 用户CPU时间    sy: Time spent running kernel code   系统CPU时间    id: Time spent idle                  空闲CUP时间    wa: Time spent waiting for IO        等待IO CPU时间    st: Time stolen from a virtual machine 从虚拟机中窃取的时间</code></pre><p><strong>dstat工具</strong></p><pre><code>功能：    结合了vmstat，iostat，ifstat，netstat以及更多的信息选项：    -l ：显示负载统计量    -m ：显示内存使用率（包括used，buffer，cache，free值）    -r ：显示I/O统计    -s ：显示交换分区使用情况    -t ：将当前时间显示在第一行    –fs ：显示文件系统统计数据（包括文件总数量和inodes值）    –nocolor ：不显示颜色（有时候有用）    –socket ：显示网络统计数据    –tcp ：显示常用的TCP统计    –udp ：显示监听的UDP接口及其当前用量的一些动态数据</code></pre><p><strong>iotop工具</strong></p><pre><code>功能：    一个用来监视磁盘I/O使用状况的top类工具。iotop具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息，能够观察每个进程的在磁盘中的读写速度内建选项：    左右箭头：改变排序方式，默认是按IO排序。    r：改变排序顺序。    o：只显示有IO输出的进程。    p：进程/线程的显示方式的切换。    a：显示累积使用量。    q：退出。选项：    -o：只显示有io操作的进程    -b：批量显示，无交互，主要用作记录到文件。    -n NUM：显示NUM次，主要用于非交互式模式。    -d SEC：间隔SEC秒显示一次。    -p PID：监控的进程pid。    -u USER：监控的进程用户。</code></pre><p><strong>lsof工具</strong></p><pre><code>功能：    用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为 lsof 需要访问核心内存和各种文件，所以需要root用户执行。用法：lsof [参数][文件]选项：    -a &lt;程序的绝对路径&gt;  查看进程被谁使用    -p &lt;PID&gt; 查看进程使用的文件    -c &lt;程序名&gt; 查看指定程序打开的文件    -g  列出GID号进程详情    -d&lt;文件号&gt; 列出占用该文件号的进程    +d&lt;目录&gt;  列出目录下被打开的文件    +D&lt;目录&gt;  递归列出目录下被打开的文件    -n&lt;目录&gt;  列出使用NFS的文件    -i&lt;条件&gt;  列出符合条件的进程    -u  列出UID号进程详情    -h 显示帮助信息    -v 显示版本信息eg:    lsof -i -n 查看所有的网络连接    lsof -i ：80 -n 查看80端口被谁占用恢复删除文件，前提是正在使用的文件lsof|grep &lt;被删除文件&gt;cd /proc/&lt;PID&gt;/fd/&lt;n&gt;cat &gt;  &lt;被删除文件&gt; </code></pre><p><strong>kill工具</strong><br>    功能：<br>        常用与杀死进程<br>    用法：kill &lt;信号&gt; <pid><br>    选项：<br>        -l 查看可用信号<br>            表示方法：<br>                数字<br>                全称<br>                简称<br>        -1  不关闭进程且重读配置文件<br>        -2  终止正在运行的进程，相当于crtl+c<br>        -3<br>        -9  强制杀死某程序，但无法杀死再生进程<br>        -15 正常的关闭某程序<br>        -18 继续运行<br>        -19 睡眠<br><strong>killall工具</strong></pid></p><pre><code>功能：    用来结束同名的的所有进程用法：killall [参数] [进程名]选项：    -Z 只杀死拥有scontext 的进程    -e 要求匹配进程名称    -I 忽略小写    -g 杀死进程组而不是进程    -i 交互模式，杀死进程前先询问用户    -l 列出所有的已知信号名称    -q 不输出警告信息    -s 发送指定的信号    -v 报告信号是否成功发送    -w 等待进程死亡    --help 显示帮助信息    --version 显示版本显示</code></pre><p><strong>pkill命令</strong></p><pre><code>功能：    搜索并关闭进程，可以按照进程名杀死进程。pkill和killall应用方法差不多，也是直接杀死运行中的程序；如果您想杀掉单个进程，请用kill来杀掉选项：    -o：仅向找到的最小（起始）进程号发送信号；    -n：仅向找到的最大（结束）进程号发送信号；    -P：指定父进程号发送信号；    -g：指定进程组；    -t：指定开启进程的终端。</code></pre><hr><h2 id="作业管理"><a href="#作业管理" class="headerlink" title="作业管理"></a>作业管理</h2><p><strong>作业相关理论知识</strong></p><pre><code>前台作业：通过终端启动，且启动后一直占据终端资源后台作业：可通过终端启动，但启动后即转入后台运行(释放终端)    后台停止    后台运行让作业转入后台：    1.运行中的作业： ctrl+z        转入后台休眠    2.尚未启动的作业：command &amp;        将其后台作业呼出到前台后台作业虽然被送往后台运行，但其依然与终端相关；退出终端，将关闭后台作业。如果希望送往后台后，剥离与终端的关系。常用到命令：    bg 停止转运行    kill -18 停止转运行，后台    kill -19 运行转停止，后台</code></pre><p><strong>jobs工具</strong><br>    功能：<br>        用于查看当前终端所有作业</p><pre><code>bg [job_num] 将后台休眠中的的程序呼出到前台，ctrl+无法将其终止fg [job_num] 将后台呼出到前台，crtl+c可将其终止</code></pre><p><strong>断网时的解决方案，剥离与终端的关系</strong></p><pre><code>nohub命令screen命令</code></pre><p><strong>并行执行，提高效率</strong></p><pre><code>并行执行的三种方法1.{ 命令&amp; 命令&amp; }  或者  { 命令 } &amp;2.    (命令&amp;);(命令&amp;);(命令&amp;)3.调用脚本vi all.sh    f1.sh&amp;    f2.sh&amp;    f3.sh&amp;</code></pre><hr><h2 id="任务计划"><a href="#任务计划" class="headerlink" title="任务计划"></a>任务计划</h2><p><strong>at工具</strong> (不常用)</p><pre><code>功能：在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程 交互式命令    ctrl+D正常退出at命令    会生成计划任务文件存放于/var/spool/at计划任务中标准输出以邮件的方式发送    写在计划任务里的任务不要有标准输出，防止磁盘被撑满禁止普通用户使用计划任务    /etc/at.deny 黑名单，优先级低    /etc/at.allow 白名单，优先级高    当不存在黑白名单时，表示只有管理员可以设置计划任务，普通用户将没有权限设置计划任务用法：at [option] time    time指定某时某分选项：    -m 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出    -I atq的别名    -d atrm的别名    -v 显示任务将被执行的时间    -c 打印任务的内容到标准输出    -V 显示版本信息    -q&lt;列队&gt; 使用指定的列队    -f&lt;文件&gt; 从指定文件读入任务而不是从标准输入读入    -t&lt;时间参数&gt; 以时间参数的形式提交要运行的任time格式：    1)HH:MM  02:00        在今日的HH:MM 进行，若该时刻已过，则明天此时执行任务    2)HH:MM YYYY-MM-DD   02:00 2016-09-20        规定在某年某月的某一天的特殊时刻进行该项任务     3)HH:MM[am|pm] [Month] [Date]        表示在某月某日或者明天执行该任务    04pm March 17    17:20 tomorrow    4)HH:MM[am|pm] + number [minutes|hours|days|weeks]        表示在某个时间点再加几个时间后才进行该项任务    now + 5 min     02pm + 3 days</code></pre><p><strong>关于进程服务开机自启</strong></p><pre><code>eg：atd服务    centos6中:        chkconfig --list atd  查看开机是否启动        service atd status 是否当前是启动状态        service atd start 启动当前服务        chkconfig atd on 开机启动        chkconfig atd off 开机关闭    centos7中:        systemctl is-enabled atd  查看开机是否启动        systemctl status atd  是否当前是启动状态        systemctl start atd  启动当前服务eg：防火墙服务    centos6中：        chkconfig iptables off 开机关闭        使用vim编辑/etc/sysconfig/selinux文件,将SELINUX=&lt;&gt;  更改为SELINUX=disable    centos7中:        systemctl disable firewalld 开机关闭        使用vim编辑/etc/sysconfig/selinux文件,将SELINUX=&lt;&gt;  更改为SELINUX=disableeg:ntpd服务，自动同步时间    步骤1    ntpdate &lt;ip&gt;    步骤2    /etc/ntp.conf    server &lt;ip&gt; iburst    server ntp.aliyun.com iburst    步骤3    设置为开启启动ntpd服务    chkconfig ntpd on    步骤4    立即启动ntpd服务    service ntpd starteg:chrony服务，centos7中同步时间    (待补充)</code></pre><h2 id="cron-周期性计划任务-第2个视频，重点待补充"><a href="#cron-周期性计划任务-第2个视频，重点待补充" class="headerlink" title="cron 周期性计划任务  (第2个视频，重点待补充)"></a>cron 周期性计划任务  (第2个视频，重点待补充)</h2><p><strong>cron所涉及的文件</strong></p><pre><code>主程序包：cronie    包含crontab命令补充程序包：cronie-anacron维护任务包：crontabs    相关文件夹        /etc/cron.daily 系统每天的计划任务        /etc/cron.hourly 系统每小时的计划任务        /etc/cron.weekly 系统每周的计划任务        /etc/cron.monthly 系统每个月的计划任务run-part     用于调用某个文件夹中的所有计划任务</code></pre><p><strong>anacron系统</strong>(了解下即可)</p><pre><code>辅助性工具，由于关机而没有执行的任务，开机自动检测，未执行的任务，自动补充执行计划任务，centos6以后的版本取消anacron服务，由crond服务管理适用于笔记本电脑、家用电脑台式机，服务器不用。centos6中    清除临时文件的计划任务    /etc/cron.daily/tmpwatch centos7中    清除临时文件    使用systemd-tmpfiles-setup服务实现查看anacron的信息    rpm -qi cronie-anacron 查看crontab信息    rpm -ql crontabs 守护进程所存放文件夹    /usr/lib/systemd/system/crond.service</code></pre><p><strong>系统计划任务的配置文件</strong></p><pre><code>/etc/contabs文件     定义管理员创建的系统任务计划    当所执行的任务命令较为复杂时，写成脚本再进行调用</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件格式：</span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># For details see man 4 crontabs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name  command to be executed</span></span><br><span class="line">30 2 *  * sun root /root/back.sh</span><br></pre></td></tr></table></figure><pre><code>/etc/cron.d/目录    也用于存放计划任务，使计划任务易于管理cron的日志文件    /var/log/cron特殊的时间格式    @yearly 每年          表示 0 0 1 1 *    @annually 每年        表示 0 0 1 1 *      @monthly 每月        表示 0 0 1 * *    @weekly 每星期        表示 0 0 * * 0    @daily 每天        表示 0 0 * * *    @hourly 每小时        表示 0 * * * *    @reboot 下次开机后的时候        表示 run once after reboot&quot;@reboot root reboot&quot; 的解决方案    开机界面 e    linux16 在最后加入 rd.break    按 ctrl+x    mount 查看根的挂载点    进入相应位置更改配置文件    重启即可</code></pre><p><strong>普通用户创建计划任务</strong></p><pre><code>crontab工具功能：    通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常适合周期性的日志分析或数据备份等工作。创建计划任务crontab命令    crontab -e 调出vim编辑器并手动编辑计划任务    crontab -l 查看当前用户的计划任务    crontab -l -u &lt;user&gt; 查看指定用户的计划任务    crontab -r 删除所有计划任务    crontab -ir 交互式删除指定计划任务计划任务存放位置    /var/spool/cron/计划任务日志文件    /var/log/cron使用前添加环境变量，定义使用何种编辑器来编辑计划任务    EDITOR=vi; export EDITORcron的黑白名单    /etc/cron.deny 黑名单    /etc/cron.allow 白名单，优先级高于黑名单</code></pre><p><strong>注意事项</strong></p><pre><code>注意：    计划任务运行结果的标准输出和错误将以邮件的传给相关用户，将导致产生垃圾信息。解决方案：    利用重定向将标准输出和错误重定向到垃圾箱中。    1.command &gt; /dev/null    2.command &amp;&gt; /dev/null对于cron任务来讲，%具有特殊用途；如果在命令中要使用%，则需要转义，将%放置于单引号中，则不可用转义。</code></pre><p><strong>将计划任务精确到秒</strong></p><pre><code>sleep命令    秒级命令    用法：sleep &lt;n&gt;[时间单位]    可用时间单位：        &lt;n&gt;s 秒，默认不用加        &lt;n&gt;m 分钟        &lt;n&gt;h 小时        &lt;n&gt;d 天数    eg：每20秒执行一次        cmd1;sleep 20;cmd1;    eg：每7分钟执行一次        cmd1;sleep 420;cmd1;usleep命令     微秒级命令        1000=1毫秒        1000000=1秒    eg：0.5秒执行一次        usleep 500000</code></pre><hr><h2 id="Shell脚本编程进阶"><a href="#Shell脚本编程进阶" class="headerlink" title="Shell脚本编程进阶"></a>Shell脚本编程进阶</h2><pre><code>shell脚本的三种类型：    顺序执行    选择执行    循环执行选择执行：    条件选择if语句        用法：        1.单分支            if  &lt;判断条件语句&gt;;then            fi        2.双分支            if  &lt;判断条件语句&gt;;then            else            fi        3.多分支            if  &lt;判断条件语句&gt;;then            elif    &lt;判断条件语句&gt;;then            elif    &lt;判断条件语句&gt;;then            elif    &lt;判断条件语句&gt;;then            else            fi    条件判断case语句        用法：        case &lt;判断条件&gt; in        &lt;判断条件&gt;)            echo             ;;        &lt;判断条件&gt;)            echo             ;;        &lt;判断条件&gt;)            echo            ;;        .        .        .        *)            echo        esac循环执行        for循环语句        用法：            for &lt;变量名&gt; in &lt;列表&gt;;do                循环体            done    while循环语句(判断条件为真则这行循环)        用法：            while [判断条件];do                循环体            done    until循环语句(判断条件为假则执行循环)        用法：            until [判断条件];do                循环体            done</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">脚本实例：使用<span class="keyword">if</span>语句判断分数</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input score: "</span> num </span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$num</span> =~ ^[[:digit:]]+$ ]];<span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"<span class="variable">$num</span>"</span> -ge 0 -a <span class="string">"<span class="variable">$num</span>"</span> -lt 60 ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"not good"</span></span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$num</span>"</span> -ge 60 -a <span class="string">"<span class="variable">$num</span>"</span> -lt 80  ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"good"</span></span><br><span class="line">    <span class="keyword">elif</span> [ <span class="string">"<span class="variable">$num</span>"</span> -ge 80 -a <span class="string">"<span class="variable">$num</span>"</span> -le 100  ];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"very good"</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"please input a right score"</span></span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">else</span>        </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"please input a number"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">脚本实例：使用<span class="keyword">case</span>语句实现菜单选择</span><br><span class="line">cat &lt;&lt;EOF</span><br><span class="line">1:lanmian</span><br><span class="line">2:huimian</span><br><span class="line">3:daoxiaomian</span><br><span class="line">4:juanbing</span><br><span class="line">5:mifan</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input your choose number: "</span> num                                </span><br><span class="line"><span class="keyword">case</span> <span class="variable">$num</span> <span class="keyword">in</span></span><br><span class="line">1)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"lamian price is 15"</span>;;</span><br><span class="line">2)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"huimian price is 18"</span>;;</span><br><span class="line">3)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"daoxiaomian price is 13"</span>;;</span><br><span class="line">4)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"juanbing price is 10"</span>;;</span><br><span class="line">5)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"mifan price is 2"</span>;;</span><br><span class="line">*)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"no list"</span></span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">脚本实例：网址扫描器</span><br><span class="line">&gt; /app/iplist.log</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"please input netid: "</span> net</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..254&#125;;<span class="keyword">do</span></span><br><span class="line">    &#123; <span class="keyword">if</span> ping -c1 -w1 <span class="variable">$net</span>.<span class="variable">$i</span> &amp;&gt; /dev/null ;<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$net</span>.<span class="variable">$i</span> is up</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$net</span>.<span class="variable">$i</span> &gt; /app/iplist.log</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ehco <span class="variable">$net</span>.<span class="variable">$i</span> is down</span><br><span class="line">      <span class="keyword">fi</span> &#125; &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第七周&quot;&gt;&lt;a href=&quot;#第七周&quot; class=&quot;headerlink&quot; title=&quot;第七周&quot;&gt;&lt;/a&gt;第七周&lt;/h1&gt;&lt;h2 id=&quot;进程概念&quot;&gt;&lt;a href=&quot;#进程概念&quot; class=&quot;headerlink&quot; title=&quot;进程概念&quot;&gt;&lt;/a&gt;进程概
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RAID知识点以及命令dd、du、df</title>
    <link href="http://yoursite.com/2018/08/15/%E7%AC%AC%E4%BA%94%E5%91%A8-RAID/"/>
    <id>http://yoursite.com/2018/08/15/第五周-RAID/</id>
    <published>2018-08-15T12:00:00.000Z</published>
    <updated>2018-08-19T13:37:52.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令dfdd、du"><a href="#命令dfdd、du" class="headerlink" title="命令dfdd、du"></a>命令dfdd、du</h2><p>df命令</p><pre><code>查看设备占用空间的工具用法:选项:    -H 以1000为单位，(卖U盘的厂商都是这样)    -h 以1024为单位,人类易读    -T 显示文件系统    -i 节点使用情况    -P 格式对其</code></pre><p>du命令 </p><pre><code>列出并查看所有文件夹的大小选项：    -h 人类易读    -s 将文件夹的大小汇总    --max-depth=1 显示一级目录下的文件夹    --max-depth=0 显示目录本身</code></pre><p>dd命令</p><pre><code>转换或复制文件用法：dd if=/path/from/SRC of=/path/to/DEST bs=  count=bs=表示复制单元大小，count表示复制多少个bs修复老旧硬盘，消磁dd if=/dev/sda of=/dev/sda</code></pre><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><p>多个磁盘合成一个”阵列”来提供更好的性能、冗余，或者两者都提供。<br>RAID成服务器标配，内置RAID卡</p><p>提高IO能力<br>    磁盘并行读写<br>提高耐用性<br>磁盘冗余来实现<br>级别：多块磁盘组织在一起的工作方式有所不同<br>RAID实现的方式：<br>    外接式磁盘阵列：通过扩展卡提供适配能力<br>    内接式RAID：主板集成RAID控制器<br>        安装OS前在BIOS里配置<br>    软件RAID：通过OS实现</p><p>RAID防止物理损坏</p><p>存储方式：将文件分为若干块chunk，将chunk均匀的存储在每个硬盘上</p><p><strong>RAID级别</strong></p><p>RAID 0 （条带集）</p><pre><code>磁盘利用率100%性能好，容错性差，服务器上一般不用存储方式：将文件分为若干块chunk，将chunk均匀的存储在每个硬盘上   chunk</code></pre><p>RAID 1  （镜像）</p><pre><code>磁盘利用率50%读写性能有所下降有容错能力最少硬盘数：2，2N自动备份</code></pre><p>已被淘汰：RAID 4 (带校验位的条带集)<br>已被淘汰：JBOD</p><p>RAID 5 (带1个校验位的条带集)</p><pre><code>磁盘利用率(n-1/n)%读写性能提升容错性：允许坏1个硬盘,并将进入降级状态降级状态：    写入数据的速度变慢    读入数据的速度几乎没影响最少需要硬盘：3，3+</code></pre><p>RAID 6 (带2个校验位的条带集)</p><pre><code>磁盘利用率(n-2/n)%读写性能提升容错性：允许坏2个硬盘，并进入降级状态降级状态：    写入数据的速度变慢    读入数据的速度几乎没影响最少需要硬盘：4，4+</code></pre><p>RAID 7 </p><pre><code>可以理解为一个独立存储计算机，自带有操作系统和管理工具，可以独立运行，理论上性能最高的RAID模式</code></pre><p>RIAD 01</p><pre><code>容错率低最少磁盘数：4，4+</code></pre><p>RAID 10 </p><pre><code>读写性能提升容错率高最少磁盘数：4，4+</code></pre><p>RAID 50</p><p><strong>mdadm命令</strong></p><pre><code>选项：-C &lt;设备名&gt;   自定义创建RAID设备名    /dev/md0、/dev/md1、/dev/md2等等-a &lt;yes|no&gt;    是否初始化RAID设备-l&lt;n&gt;   n表示所创建的RAID级别-n&lt;n&gt; &lt;分区&gt; n表示分区成员个数，以及分区名字-D  &lt;设备名&gt;  查看RAID信息-Ds &lt;设备名&gt;  查看RAID的UUID-x&lt;n&gt; &lt;设备名&gt; n表示空白设备(非活动分区)的数量</code></pre><p><strong>软RIAD的创建实验系列</strong><br>实验：RAID 0</p><pre><code>准备分区或者硬盘,记得给分区添加fd标签创建RAIDmdadm -C /dev/md0 -a yes -l0 -n4 /dev/sd{b,c,d,e}1将uuid写入配置文件中mdadm -Ds /dev/md0 &gt; /etc/mdadm.conf创建文件系统mkfs.xfs /dev/md0创建挂载点mkdir /mnt/raid0配置fstab文件使配置文件生效mount -a</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># lsblk           </span></span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0  120G  0 disk </span><br><span class="line">├─sda1   8:1    0    1G  0 part /boot</span><br><span class="line">├─sda2   8:2    0   50G  0 part /</span><br><span class="line">├─sda3   8:3    0   20G  0 part /app</span><br><span class="line">├─sda4   8:4    0    1K  0 part </span><br><span class="line">└─sda5   8:5    0    2G  0 part [SWAP]</span><br><span class="line">sdb      8:16   0    8G  0 disk </span><br><span class="line">└─sdb1   8:17   0    1G  0 part </span><br><span class="line">sdc      8:32   0    6G  0 disk </span><br><span class="line">└─sdc1   8:33   0    1G  0 part </span><br><span class="line">sdd      8:48   0    4G  0 disk </span><br><span class="line">└─sdd1   8:49   0    1G  0 part </span><br><span class="line">sde      8:64   0    2G  0 disk </span><br><span class="line">└─sde1   8:65   0    1G  0 part </span><br><span class="line">[root@Souler7 ~]<span class="comment"># mdadm -C /dev/md0 -a yes -l0 -n4 /dev/sd&#123;b,c,d,e&#125;1  </span></span><br><span class="line">mdadm: Defaulting to version 1.2 metadata</span><br><span class="line">mdadm: array /dev/md0 started.</span><br><span class="line">[root@Souler7 ~]<span class="comment"># mdadm -D /dev/md0  </span></span><br><span class="line"></span><br><span class="line">/dev/md0:</span><br><span class="line">           Version : 1.2</span><br><span class="line">     Creation Time : Sat Aug 18 19:21:14 2018</span><br><span class="line">        Raid Level : raid0</span><br><span class="line">        Array Size : 4186112 (3.99 GiB 4.29 GB)</span><br><span class="line">      Raid Devices : 4</span><br><span class="line">     Total Devices : 4</span><br><span class="line">       Persistence : Superblock is persistent</span><br><span class="line"></span><br><span class="line">       Update Time : Sat Aug 18 19:21:14 2018</span><br><span class="line">             State : clean </span><br><span class="line">    Active Devices : 4</span><br><span class="line">   Working Devices : 4</span><br><span class="line">    Failed Devices : 0</span><br><span class="line">     Spare Devices : 0</span><br><span class="line"></span><br><span class="line">        Chunk Size : 512K</span><br><span class="line"></span><br><span class="line">Consistency Policy : none</span><br><span class="line"></span><br><span class="line">              Name : Souler7.localdomain:0  (<span class="built_in">local</span> to host Souler7.localdomain)</span><br><span class="line">              UUID : 59d6abd0:ca5d529b:0a58fb7c:c8a5dfdc</span><br><span class="line">            Events : 0</span><br><span class="line"></span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       17        0      active sync   /dev/sdb1</span><br><span class="line">       1       8       33        1      active sync   /dev/sdc1</span><br><span class="line">       2       8       49        2      active sync   /dev/sdd1</span><br><span class="line">       3       8       65        3      active sync   /dev/sde1</span><br><span class="line">[root@Souler7 ~]<span class="comment"># mdadm -Ds /dev/md0 &gt; /etc/mdadm.conf</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># cat /etc/mdadm.conf</span></span><br><span class="line">ARRAY /dev/md0 metadata=1.2 name=Souler7.localdomain:0 UUID=59d6abd0:ca5d529b:0a58fb7c:c8a5dfdc</span><br><span class="line">[root@Souler7 ~]<span class="comment"># mkfs.xfs /dev/md0</span></span><br><span class="line">meta-data=/dev/md0               isize=512    agcount=8, agsize=130816 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=1046528, imaxpct=25</span><br><span class="line">         =                       sunit=128    swidth=512 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=8 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">[root@Souler7 ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME    MAJ:MIN RM  SIZE RO TYPE  MOUNTPOINT</span><br><span class="line">sda       8:0    0  120G  0 disk  </span><br><span class="line">├─sda1    8:1    0    1G  0 part  /boot</span><br><span class="line">├─sda2    8:2    0   50G  0 part  /</span><br><span class="line">├─sda3    8:3    0   20G  0 part  /app</span><br><span class="line">├─sda4    8:4    0    1K  0 part  </span><br><span class="line">└─sda5    8:5    0    2G  0 part  [SWAP]</span><br><span class="line">sdb       8:16   0    8G  0 disk  </span><br><span class="line">└─sdb1    8:17   0    1G  0 part  </span><br><span class="line">  └─md0   9:0    0    4G  0 raid0 </span><br><span class="line">sdc       8:32   0    6G  0 disk  </span><br><span class="line">└─sdc1    8:33   0    1G  0 part  </span><br><span class="line">  └─md0   9:0    0    4G  0 raid0 </span><br><span class="line">sdd       8:48   0    4G  0 disk  </span><br><span class="line">└─sdd1    8:49   0    1G  0 part  </span><br><span class="line">  └─md0   9:0    0    4G  0 raid0 </span><br><span class="line">sde       8:64   0    2G  0 disk  </span><br><span class="line">└─sde1    8:65   0    1G  0 part  </span><br><span class="line">  └─md0   9:0    0    4G  0 raid0 </span><br><span class="line">[root@Souler7 ~]<span class="comment"># lsblk -f</span></span><br><span class="line">NAME    FSTYPE    LABEL                 UUID                                 MOUNTPOINT</span><br><span class="line">sda                                                                          </span><br><span class="line">├─sda1  xfs                             0969a307-2d09-4c7d-b13d-6aa550635363 /boot</span><br><span class="line">├─sda2  xfs                             c074ae1d-45ec-4214-a9a1-af4357b03745 /</span><br><span class="line">├─sda3  xfs                             551335e1-2a4e-4b36-a2bb-3197f391b6c3 /app</span><br><span class="line">├─sda4                                                                       </span><br><span class="line">└─sda5  swap                            62f3e665-d832-444f-8217-f8713f5228a7 [SWAP]</span><br><span class="line">sdb                                                                          </span><br><span class="line">└─sdb1  linux_rai Souler7.localdomain:0 59d6abd0-ca5d-529b-0a58-fb7cc8a5dfdc </span><br><span class="line">  └─md0 xfs                             b8f25a84-c016-4005-9581-c13c99dc33db </span><br><span class="line">sdc                                                                          </span><br><span class="line">└─sdc1  linux_rai Souler7.localdomain:0 59d6abd0-ca5d-529b-0a58-fb7cc8a5dfdc </span><br><span class="line">  └─md0 xfs                             b8f25a84-c016-4005-9581-c13c99dc33db </span><br><span class="line">sdd                                                                          </span><br><span class="line">└─sdd1  linux_rai Souler7.localdomain:0 59d6abd0-ca5d-529b-0a58-fb7cc8a5dfdc </span><br><span class="line">  └─md0 xfs                             b8f25a84-c016-4005-9581-c13c99dc33db </span><br><span class="line">sde                                                                          </span><br><span class="line">└─sde1  linux_rai Souler7.localdomain:0 59d6abd0-ca5d-529b-0a58-fb7cc8a5dfdc </span><br><span class="line">  └─md0 xfs                             b8f25a84-c016-4005-9581-c13c99dc33db </span><br><span class="line">[root@Souler7 ~]<span class="comment"># mdadm -Ds /dev/md0 &gt; /etc/mdadm.conf</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># mkfs.xfs /dev/md0</span></span><br><span class="line">meta-data=/dev/md0               isize=512    agcount=8, agsize=130816 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=1046528, imaxpct=25</span><br><span class="line">         =                       sunit=128    swidth=512 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=8 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">[root@Souler7 ~]<span class="comment"># lsblk</span></span><br><span class="line">NAME    MAJ:MIN RM  SIZE RO TYPE  MOUNTPOINT</span><br><span class="line">sda       8:0    0  120G  0 disk  </span><br><span class="line">├─sda1    8:1    0    1G  0 part  /boot</span><br><span class="line">├─sda2    8:2    0   50G  0 part  /</span><br><span class="line">├─sda3    8:3    0   20G  0 part  /app</span><br><span class="line">├─sda4    8:4    0    1K  0 part  </span><br><span class="line">└─sda5    8:5    0    2G  0 part  [SWAP]</span><br><span class="line">sdb       8:16   0    8G  0 disk  </span><br><span class="line">└─sdb1    8:17   0    1G  0 part  </span><br><span class="line">  └─md0   9:0    0    4G  0 raid0 </span><br><span class="line">sdc       8:32   0    6G  0 disk  </span><br><span class="line">└─sdc1    8:33   0    1G  0 part  </span><br><span class="line">  └─md0   9:0    0    4G  0 raid0 </span><br><span class="line">sdd       8:48   0    4G  0 disk  </span><br><span class="line">└─sdd1    8:49   0    1G  0 part  </span><br><span class="line">  └─md0   9:0    0    4G  0 raid0 </span><br><span class="line">sde       8:64   0    2G  0 disk  </span><br><span class="line">└─sde1    8:65   0    1G  0 part  </span><br><span class="line">  └─md0   9:0    0    4G  0 raid0 </span><br><span class="line">[root@Souler7 ~]<span class="comment"># lsblk -f</span></span><br><span class="line">NAME    FSTYPE    LABEL                 UUID                                 MOUNTPOINT</span><br><span class="line">sda                                                                          </span><br><span class="line">├─sda1  xfs                             0969a307-2d09-4c7d-b13d-6aa550635363 /boot</span><br><span class="line">├─sda2  xfs                             c074ae1d-45ec-4214-a9a1-af4357b03745 /</span><br><span class="line">├─sda3  xfs                             551335e1-2a4e-4b36-a2bb-3197f391b6c3 /app</span><br><span class="line">├─sda4                                                                       </span><br><span class="line">└─sda5  swap                            62f3e665-d832-444f-8217-f8713f5228a7 [SWAP]</span><br><span class="line">sdb                                                                          </span><br><span class="line">└─sdb1  linux_rai Souler7.localdomain:0 59d6abd0-ca5d-529b-0a58-fb7cc8a5dfdc </span><br><span class="line">  └─md0 xfs                             b8f25a84-c016-4005-9581-c13c99dc33db </span><br><span class="line">sdc                                                                          </span><br><span class="line">└─sdc1  linux_rai Souler7.localdomain:0 59d6abd0-ca5d-529b-0a58-fb7cc8a5dfdc </span><br><span class="line">  └─md0 xfs                             b8f25a84-c016-4005-9581-c13c99dc33db </span><br><span class="line">sdd                                                                          </span><br><span class="line">└─sdd1  linux_rai Souler7.localdomain:0 59d6abd0-ca5d-529b-0a58-fb7cc8a5dfdc </span><br><span class="line">  └─md0 xfs                             b8f25a84-c016-4005-9581-c13c99dc33db </span><br><span class="line">sde                                                                          </span><br><span class="line">└─sde1  linux_rai Souler7.localdomain:0 59d6abd0-ca5d-529b-0a58-fb7cc8a5dfdc </span><br><span class="line">  └─md0 xfs                             b8f25a84-c016-4005-9581-c13c99dc33db </span><br><span class="line">[root@Souler7 ~]<span class="comment"># mkdir /mnt/raid0</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># blkid /dev/md0</span></span><br><span class="line">/dev/md0: UUID=<span class="string">"b8f25a84-c016-4005-9581-c13c99dc33db"</span> TYPE=<span class="string">"xfs"</span> </span><br><span class="line">[root@Souler7 ~]<span class="comment"># vim /etc/fstab </span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda2       52403200 4193080  48210120   9% /</span><br><span class="line">devtmpfs          483096       0    483096   0% /dev</span><br><span class="line">tmpfs             498988       0    498988   0% /dev/shm</span><br><span class="line">tmpfs             498988    8744    490244   2% /run</span><br><span class="line">tmpfs             498988       0    498988   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda3       20961280   32944  20928336   1% /app</span><br><span class="line">/dev/sda1        1038336  157968    880368  16% /boot</span><br><span class="line">tmpfs              99800      28     99772   1% /run/user/0</span><br><span class="line">[root@Souler7 ~]<span class="comment"># mount -a</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda2       52403200 4193080  48210120   9% /</span><br><span class="line">devtmpfs          483096       0    483096   0% /dev</span><br><span class="line">tmpfs             498988       0    498988   0% /dev/shm</span><br><span class="line">tmpfs             498988    8744    490244   2% /run</span><br><span class="line">tmpfs             498988       0    498988   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda3       20961280   32944  20928336   1% /app</span><br><span class="line">/dev/sda1        1038336  157968    880368  16% /boot</span><br><span class="line">tmpfs              99800      28     99772   1% /run/user/0</span><br><span class="line">/dev/md0         4175872   33072   4142800   1% /mnt/raid0</span><br><span class="line">[root@Souler7 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>实验：RAID 5</p><pre><code>创建RAIDmdadm -C /dev/md5 -a yes -l5 -n3 -x1 /dev/sd{b,c,d,}1 /dev/sda7查看RAID信息mdadm -D /dev/md5cat /proc/mdstat将配置写入文件mdadm -Ds /dev/md5 &gt; /ect/mdadm.conf创建文件系统mkfs.xfs /dev/md5创建挂载点mkdir /mnt/raid5配置fstab    略使配置文件生效mount -a</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># mdadm -C /dev/md5 -a yes -l5 -n3 -x1 /dev/sd&#123;b,c,d&#125;1 /dev/sde1</span></span><br><span class="line">mdadm: Defaulting to version 1.2 metadata</span><br><span class="line">mdadm: array /dev/md5 started.</span><br><span class="line">[root@Souler7 ~]<span class="comment"># mdadm -D</span></span><br><span class="line">mdadm: No devices given.</span><br><span class="line">[root@Souler7 ~]<span class="comment"># mdadm -D /dev/md5</span></span><br><span class="line">/dev/md5:</span><br><span class="line">           Version : 1.2</span><br><span class="line">     Creation Time : Sat Aug 18 20:20:55 2018</span><br><span class="line">        Raid Level : raid5</span><br><span class="line">        Array Size : 2093056 (2044.00 MiB 2143.29 MB)</span><br><span class="line">     Used Dev Size : 1046528 (1022.00 MiB 1071.64 MB)</span><br><span class="line">      Raid Devices : 3</span><br><span class="line">     Total Devices : 4</span><br><span class="line">       Persistence : Superblock is persistent</span><br><span class="line"></span><br><span class="line">       Update Time : Sat Aug 18 20:21:01 2018</span><br><span class="line">             State : clean </span><br><span class="line">    Active Devices : 3</span><br><span class="line">   Working Devices : 4</span><br><span class="line">    Failed Devices : 0</span><br><span class="line">     Spare Devices : 1</span><br><span class="line"></span><br><span class="line">            Layout : left-symmetric</span><br><span class="line">        Chunk Size : 512K</span><br><span class="line"></span><br><span class="line">Consistency Policy : resync</span><br><span class="line"></span><br><span class="line">              Name : Souler7.localdomain:5  (<span class="built_in">local</span> to host Souler7.localdomain)</span><br><span class="line">              UUID : 48af101b:c9fe64dc:947299a3:44564504</span><br><span class="line">            Events : 18</span><br><span class="line"></span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       17        0      active sync   /dev/sdb1</span><br><span class="line">       1       8       33        1      active sync   /dev/sdc1</span><br><span class="line">       4       8       49        2      active sync   /dev/sdd1</span><br><span class="line"></span><br><span class="line">       3       8       65        -      spare   /dev/sde1</span><br><span class="line">[root@Souler7 ~]<span class="comment"># mdadm -Ds /dev/md5 &gt; /etc/mdadm.conf</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># mkfs.xfs /dev/md5</span></span><br><span class="line">meta-data=/dev/md5               isize=512    agcount=8, agsize=65408 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0, sparse=0</span><br><span class="line">data     =                       bsize=4096   blocks=523264, imaxpct=25</span><br><span class="line">         =                       sunit=128    swidth=256 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=8 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">[root@Souler7 ~]<span class="comment"># mkdir /mnt/raid5</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda2       52403200 4193028  48210172   9% /</span><br><span class="line">devtmpfs          483096       0    483096   0% /dev</span><br><span class="line">tmpfs             498988       0    498988   0% /dev/shm</span><br><span class="line">tmpfs             498988    8736    490252   2% /run</span><br><span class="line">tmpfs             498988       0    498988   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda3       20961280   32944  20928336   1% /app</span><br><span class="line">/dev/sda1        1038336  157968    880368  16% /boot</span><br><span class="line">tmpfs              99800      28     99772   1% /run/user/0</span><br><span class="line">[root@Souler7 ~]<span class="comment"># vim /etc/fstab </span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># mount -a</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># df</span></span><br><span class="line">Filesystem     1K-blocks    Used Available Use% Mounted on</span><br><span class="line">/dev/sda2       52403200 4193324  48209876   9% /</span><br><span class="line">devtmpfs          483096       0    483096   0% /dev</span><br><span class="line">tmpfs             498988       0    498988   0% /dev/shm</span><br><span class="line">tmpfs             498988    8736    490252   2% /run</span><br><span class="line">tmpfs             498988       0    498988   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda3       20961280   32944  20928336   1% /app</span><br><span class="line">/dev/sda1        1038336  157968    880368  16% /boot</span><br><span class="line">tmpfs              99800      28     99772   1% /run/user/0</span><br><span class="line">/dev/md5         2082816   33072   2049744   2% /mnt/raid5</span><br><span class="line">[root@Souler7 ~]<span class="comment"># lsblk -f</span></span><br><span class="line">NAME    FSTYPE            LABEL                 UUID                                 MOUNTPOINT</span><br><span class="line">sda                                                                                  </span><br><span class="line">├─sda1  xfs                                     0969a307-2d09-4c7d-b13d-6aa550635363 /boot</span><br><span class="line">├─sda2  xfs                                     c074ae1d-45ec-4214-a9a1-af4357b03745 /</span><br><span class="line">├─sda3  xfs                                     551335e1-2a4e-4b36-a2bb-3197f391b6c3 /app</span><br><span class="line">├─sda4                                                                               </span><br><span class="line">└─sda5  swap                                    62f3e665-d832-444f-8217-f8713f5228a7 [SWAP]</span><br><span class="line">sdb                                                                                  </span><br><span class="line">└─sdb1  linux_raid_member Souler7.localdomain:5 48af101b-c9fe-64dc-9472-99a344564504 </span><br><span class="line">  └─md5 xfs                                     6095f832-6e1b-4a8a-9e92-4c186a6b03be /mnt/raid5</span><br><span class="line">sdc                                                                                  </span><br><span class="line">└─sdc1  linux_raid_member Souler7.localdomain:5 48af101b-c9fe-64dc-9472-99a344564504 </span><br><span class="line">  └─md5 xfs                                     6095f832-6e1b-4a8a-9e92-4c186a6b03be /mnt/raid5</span><br><span class="line">sdd                                                                                  </span><br><span class="line">└─sdd1  linux_raid_member Souler7.localdomain:5 48af101b-c9fe-64dc-9472-99a344564504 </span><br><span class="line">  └─md5 xfs                                     6095f832-6e1b-4a8a-9e92-4c186a6b03be /mnt/raid5</span><br><span class="line">sde                                                                                  </span><br><span class="line">└─sde1  linux_raid_member Souler7.localdomain:5 48af101b-c9fe-64dc-9472-99a344564504 </span><br><span class="line">  └─md5 xfs                                     6095f832-6e1b-4a8a-9e92-4c186a6b03be /mnt/raid5</span><br><span class="line">sr0     iso9660           CentOS 7 x86_64       2018-05-07-12-53-47-00               </span><br><span class="line">[root@Souler7 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>删除软RAID设备：</strong></p><pre><code>取消挂载umount &lt;设备名&gt;停止设备mdadm -S &lt;设备名&gt;删除raid的配置文件rm -f /etc/mdadm.conf删除fstab中的相关配置信息清除RAID信息mdadm --zero-superblock    &lt;raid的成员&gt;</code></pre><p><strong>mdadm命令的其他用法</strong></p><pre><code>测试速度dd if=/dev/zero of=/dev/md0/f1 bs=1M count=1024 conv=fdatasync停止设备mdadm -S &lt;raid设备名&gt;激活设备mdamd -As &lt;raid设备名&gt;清除raid信息mdadm --zero-superblock /dev/sd{b,c,d,e}1模拟/dev/sde1设备损坏mdadm &lt;raid设备名&gt; -f /dev/sde1删除raid成员sde1mdadm &lt;raid设备名&gt; -r /dev/sde1加入raid成员sde1mdadm &lt;raid设备名&gt; -a /dev/sde1扩展RAID容量mdadm -G &lt;raid设备名&gt; -n 5 -a &lt;新增的设备名&gt;注意：在为raid增加容量的时候，需要同步不同的文件系统需要用到不用的命令同步xfs文件系统    xfs_growfs &lt;挂载点&gt;    xfs_growfs /mnt/raid5同步ext文件系统    resize2fs &lt;raid设备名&gt;    resize2fs /dev/md5</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;命令dfdd、du&quot;&gt;&lt;a href=&quot;#命令dfdd、du&quot; class=&quot;headerlink&quot; title=&quot;命令dfdd、du&quot;&gt;&lt;/a&gt;命令dfdd、du&lt;/h2&gt;&lt;p&gt;df命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;查看设备占用空间的工具
用法:
选项:
  
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>磁盘相关知识以及分区管理和挂载</title>
    <link href="http://yoursite.com/2018/08/12/%E7%AC%AC%E5%9B%9B%E5%91%A8-%E7%A3%81%E7%9B%98%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86%E5%92%8C%E6%8C%82%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/08/12/第四周-磁盘相关知识以及分区管理和挂载/</id>
    <published>2018-08-12T14:00:00.000Z</published>
    <updated>2018-08-12T15:08:47.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DAY-12"><a href="#DAY-12" class="headerlink" title="DAY 12"></a>DAY 12</h1><h2 id="认识磁盘"><a href="#认识磁盘" class="headerlink" title="认识磁盘"></a>认识磁盘</h2><p><strong>CHS和LBA</strong></p><pre><code>CHS模式采用24bit位寻址 其中前10位表示cylinder，中间8位表示head，后面6位表示sector 最大寻址空间8GBLBA模式 LBA是一个整数，通过转换成CHS格式完成磁盘具体寻址 LBA采用48个bit位寻址 最大寻址空间128PB注意：由于CHS寻址方式的寻址空间大概在8GB以内，所以在磁盘容量小于大概8G时，可以使用CHS寻址方式或是LBA寻址方式；在磁盘容量大于大概8GB时，则只能使用LBA寻址方式</code></pre><p><strong>磁盘的相关术语</strong></p><pre><code>track 磁道 10bit 2^10=1024个磁道 0-1023sector 扇区 6bit 2^6=64个扇区 0-63  每个扇区固定大小512个字节head 磁头数    8bit 2^8=256 cylinder 柱面 </code></pre><p><strong>磁盘分区的优点</strong></p><pre><code>优化io性能提高修复速度采用不同的文件系统隔离系统和程序磁盘配额注意：没有分区就没有文件系统，没有文件系统就没有文件，用户通过文件系统来管理文件。</code></pre><p><strong>两种分区：mbr与gpt</strong></p><pre><code>MBR分区 ,CHS使用32位表示扇区数，分区不超过2T按柱面分区    0磁道0扇区：512bytes        446 bytes：boot loader （存放主引导程序）        64 bytes：分区表 （破坏会导致分区丢失）            16 bytes：识别分区                引导标志：                    80活动分区                    00非活动分区        2 bytes：标记位55aa （破坏会导致系统识别不出分区）    4个主分区：3个主分区和一个扩展分区GPT分区    支持更大的分区</code></pre><hr><h2 id="管理分区"><a href="#管理分区" class="headerlink" title="管理分区"></a>管理分区</h2><pre><code>列出块设备lsblk 查看块设备的文件系统lsblk -f查看磁盘的分区表     fdisk -l /dev/sdb      查看内存中的分区表     ls /dev/sdb*      cat /proc/partitions     lsblk     centos 6 中同步内存与磁盘的分区表         partx -a /dev/sda 读取硬盘加所有的分区             partx -d --nr &lt;sda后跟着的编号&gt; /dev/sda 删除分区     centos 7 中同步内存与磁盘的分区表         partprobe （centos6中无效）         kpartx -a /dev/sda </code></pre><p><strong>fdisk命令</strong> ：创建MBR分区</p><pre><code>用法：fdisk [option] /dev/sdb     交互式选项：         m 列出所有选项         P 显示当前硬盘分区         d 删除分区         q 直接退出规划         v 校验分区         t 更改分区标签id         n 创建一个新分区             p 创建主分区             e 创建扩展分区                 l 逻辑分区             +2G  分两个G的大小         w 结束规划，保存，分区生效         q 结束规划，不保存退出option：     -c 关闭dos报警     -u 指定以何种单位分区     -l 列出硬盘信息</code></pre><p><strong>gdisk命令</strong>：创建GPT分区以及管理MBR和GPT分区</p><pre><code>用法：gdisk /dev/sdb     交互式选项：         ? 列出所有选项         p 显示当前硬盘分区         d 删除分区         q 直接退出规划         v 校验分区是否正确         n 创建一个新分区             输入分区编号：1-128             输出分区大小：+1G             code编号默认即可         w 结束规划，分区生效</code></pre><p><strong>parted命令</strong>： 实时生效的命令</p><pre><code>parted /dev/sdb mkladel gpt/msdos 创建一个GPT/MBR的分区parted /dev/sdb mkpart primary 1 100  创建一个99mparted /dev/sdb print 打印分区信息parted /dev/sdb rm 分区号  删除指定分区</code></pre><hr><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>分区后必须创建文件系统，提供文件管理的功能</p><pre><code>查看系统支持的文件系统ls /lib/modules/`uname -r`/kernel/fs</code></pre><p><strong>文件系统的类型：</strong></p><pre><code>linux文件系统：    ext2：适用于/boot分区     ext3：新增了日志功能，能够帮助系统从非正常关机导致的数据丢失恢复。它通常被用作通用的文件系统，但修复速度慢     ext4：是ext文件系统的最新版。提供了很多新的特性，包括纳秒级的时间戳、创建和使用巨型文件（16TB）、最大1EB的文件系统，以及修复速度的提升     xfs：支持最大8EB的文件系统     btrfs：Oracle 发布，还属于测试阶段，企业中几乎不用此文件系统     reiserfs：本来是世界最优秀的文件系统，但作者被抓了..就此没落     swap：模拟内存的文件系统光盘：iso9660网络文件系统：NFS、CIFS集群文件系统：GFS2、OCFS2分布式文件系统：ceph、fastdfs、moosefs、mofilefs</code></pre><p><strong>文件系统分类：</strong></p><pre><code>日志型文件系统：ext3、ext4、xfs非日志型文件系统：ext2、vfat 查看文件系统是否已加载到内存中使用     lsmod内核中的模块：ext4、xfs、vfat用户空间的管理工具：     mkfs.ext4,     mkfs.xfs,     mkfs.vfatlinux的虚拟文件系统：VFS查看当前支持的文件系统：cat /proc/filesystems</code></pre><p><strong>管理文件系统的相关命令</strong></p><pre><code>查看超级块备份的位置     dumpe2fs &lt;分区&gt;查看ext系列文件系统的元数据     tune2fs -l  &lt;分区&gt;查看UUID     blkid添加分区acl权限    tune2fs -o acl &lt;分区&gt;删除分区acl权限    tune2fs -o ^acl &lt;分区&gt;删除日志功能    tune2fs -O ^has_journal &lt;分区&gt;增加日志功能    tune2fs -O has_journal &lt;分区&gt;更改最大挂载次数为10     tune2fs -c 10 &lt;分区&gt;更改当前挂载次数为5     tune2fs -C 5 &lt;分区&gt;更改检查时间为一个月     tune2fs -i 1m &lt;分区&gt;更改文件系统的UUID     tune2fs -U `uuidgen` &lt;分区&gt;</code></pre><p><strong>mkfs命令</strong>： 格式化分区，并创建文件系统，生成UUID</p><pre><code>用法：    mkfs.ext4 &lt;分区&gt;    mkfs.xfs &lt;分区&gt;选项：    -L 添加卷标</code></pre><p><strong>mke2fs命令：</strong> 专门管理ext系列的工具</p><pre><code>用法：mke2fs -t &lt;ext系统类型&gt;选项：-b 指定block大小 1024，2048，4096-t ext2/ext3/ext3 指定管理文件系统-i # 为数据块中每#个字节创建一个inode-I # 一个inode记录占用的磁盘空间大小，128--4096-N # 指定分区中创建#个inode-m # 改变预留给管理员使用空间的百分比-L 添加卷标</code></pre><p><strong>fsck命令：</strong> 文件系统检查</p><pre><code>fsck -y &lt;分区&gt;    自动修复ext系列的文件系统，前提需要取消挂载</code></pre><h2 id="分区、文件以及文件夹挂载"><a href="#分区、文件以及文件夹挂载" class="headerlink" title="分区、文件以及文件夹挂载"></a>分区、文件以及文件夹挂载</h2><p><strong>mount命令</strong></p><pre><code>mount基本用法：    mount &lt;分区&gt; &lt;挂载点&gt;    mount &lt;文件&gt; &lt;挂载点&gt;    mount &lt;文件夹&gt; &lt;挂载点&gt;    查看挂载信息         cat /etc/mtab = mount    使用UUID挂载设备（推荐使用该方法，不易出错）         mount &lt;UUID=..&gt; &lt;挂载点&gt;    使用卷标挂载设备         mount LABEL=&quot;&lt;卷标&gt;&quot; &lt;挂载点&gt;    加卷标          e2label &lt;设备&gt; &lt;卷标名&gt;其他用法：     使用UUID查找分区         findfs  UUID=&quot;&quot; /blkid -U UUID     使用卷标名查找分区         findfs LABEL=&quot;&quot; /blkid -L LABEL     不更新mtab （在centos7中不起作用）         mount -n         cat /proc/mounts 查看隐藏挂载     只读方式挂载         mount -r     不影响用户使用的同时重新挂载，并更改权限为可读可写         mount -o remount，rw  &lt;挂载点&gt;     不影响用户使用的同时重新挂载，并更改权限为只读         mount -o remount，ro  &lt;挂载点&gt;     将文件挂载到文件夹中，df无法查看文件的挂载，mount可查看，类似于软链接和硬链接的综合体         mount -B &lt;文件&gt; &lt;挂载点&gt;     查看正在访问挂载点的进程         losf &lt;挂载点&gt;         fuser -v &lt;挂载点&gt;     杀死正在访问挂载点的进程（慎用）         fuser -km &lt;挂载点&gt;     查看挂载情况         findmnt &lt;挂载点&gt;      重新挂载，并设置挂载点不更新atime，除非使用touch         mount -o remount,noatime &lt;挂载点&gt;     重新挂载，并设置挂点的目录不更新atime         nount -o remount，nodiratime    使fstab配置文件生效        mount -a      重新挂载，并禁用挂载点所有的可执行程序         mount -o remount，noexec     重新挂载，并禁用设备文件         mount -o remount，nodev     重新挂载，并禁用suid权限         mount -o remount，nosuid     重新挂载，并添加acl权限         mount -o remount，acl &lt;挂载点&gt;    注意：        一个设备可以挂载到多个挂载点        一个文件夹同一时间只能挂载一个设备         当挂载点的文件夹最好为空关于loop设备     在centos6中，将文件挂载到文件夹上，需要消耗一个loop，默认有8个loop     手动添加loop设备：         vim /boot/grub/grub.conf         寻找行(kernel ...rhgb quiet)，并在该行的末端加入 max_loop=100         (kernel ...rhgb quiet max_loop=100)保存退出并重启，重启后loop设备会增加到100个。     在centos6中，将普通文件模拟为设备文件，然后挂到文件夹中    步骤如下         touch /app/p1         mkdit /mnt/p1         dd if=/dev/zero of=/app/p1 bs=1M count=100         mkfs.ext4 /app/p1  //将文件作为文件系统         mount -o loop /app/p1 /mnt/p1  //将文件挂载到文件夹中,此时/app/p1可以作为一个u盘</code></pre><p><strong>fstab文件：</strong></p><pre><code>格式：    1.分区挂载        设备名or(UUID)    挂载点      文件系统的类型      相关配置   备份     检查次序        /dev/sdb1       /mnt/sdb1  ext3           defaults   0      0    2.文件挂载        设备名or(UUID)    挂载点      文件系统的类型      相关配置   备份 检查次序        /app/p1           /mnt/p1    ext4           loop       0      0    3.文件夹挂载        设备名or(UUID)    挂载点      文件系统的类型      相关配置   备份     检查次序        /etc            /mnt/etc   none           bind       0      0 defaults:默认选项     rw,suid,dev,exec,auto,nouser,async注意：永久保存挂载点，需编辑/etc/fstab        寻找fstab文件中含有auto的挂载项，使其立即生效，自动挂载             mount -a （仅首次挂载有效） 当救援模式下，文件不可写时，重新挂载根，即可解决     mount -o remount,rw /注意：UUID项最好不要出现引号    fstab内     当挂载点出错不影响系统启动，centos6与7一样     当设备出错，centos6与7有差别     centos6中，         当设备出错，导致系统无法启动时，更改/etc/fstab下文件系统的检查次序为0，跳过检查（centos7不可用     centos7中，         设备出错将导致系统无法启动，只能通过注释掉出错设备，来恢复系统的正常启动</code></pre><p><strong>实验：将/home下的数据迁移到一个新的分区</strong></p><pre><code>建立一个新的分区    fdisk /dev/sda为新建分区创建文件系统    mkfs.xfs /dev/sda6在mnt目录下新建挂载点    mkdir /mnt/home将分区挂载到挂载点    mount /dev/sda6 /mnt/home将当前系统更改为单用户模式，保证维护状态，会断网    init 1保证数据完整拷贝情况下，拷贝数据至挂载点中    cp -av /home/* /mnt/home编辑fstab文件，新增行，使得系统启动时自动将分区挂在到home目录下      UUID=..(此处省略一大串字符) /home     xfs   defaults    0 0使配置文件fstab立刻生效    mount -a确认home成功挂载后，将原来的home数据删除，不删则会称为垃圾文件，建议删除    umount /home      取消挂载点    umount /mnt/home  取消挂载点    rm -rf /home/*    删除原来的文件    mount -a          重新挂载</code></pre><p><strong>创建swap分区</strong></p><pre><code>新建分区    fdisk &lt;分区&gt;    注意：在交互式创建分区的过程中，t-&gt;l-&gt;82,最好是加个标签，方便识别，不加也无妨格式化并创建swap文件系统    mkswap  &lt;分区&gt;将swap写进fstab文件中    默认配置defaults,若想改变优先级,&apos;defaults&apos;改为&apos;pri=10&apos;即可更改优先级的值为10使fstab中的swap分区生效（此处mount -a 无法使swap分区生效）    swapon -a 查看swap内存配置    swapon -s 或者 cat /proc/swaps    文件名         文件类型          大小     使用情况  优先级（值越大优先级越高）    Filename      Type            Size     Used     Priority   /dev/sda5    partition       2097148   6144     -1禁用指定的swap分区    swapoff &lt;分区&gt;删除swap分区    需要先禁用swap分区    再修改fstab    最后通过fdisk将分区彻底删除</code></pre><p><strong>实验：将文件作为swap使用</strong></p><pre><code>先创建一个大小为1G的文件    dd if=/dev/zero of=/swapfile bs=1G count=1创建swap文件系统    mkswap /swapfile将配置写到fstab文件中    过程略更改权限    chmod 600 /swapfile使fstab文件配置生效    swapon -a</code></pre><p><strong>关于ISO的挂载与制作</strong></p><pre><code> 将光盘挂载到文件夹中     创建文件夹         mkdir /mnt/cdrom     配置fstab     设备名or(UUID)    挂载点        文件系统的类型      相关配置   备份     检查次序    /dev/cdrom      /mnt/cdrom   iso9660          defaults    0      0    使配置生效，挂载光盘        mount -a创建iso文件    cp /dev/sr0 /app/centos7.iso挂载iso    创建文件夹        mkdir /mnt/iso    将iso挂载到文件中        mount /app/centos7.iso /mnt/iso将etc文件夹制作成iso文件    mkisofs -r -o ect.iso /etc/弹出光驱    eject</code></pre><p><strong>关于USB</strong></p><pre><code>查看usb设备    lsusb强制把内存中的数据写到u盘中    sync，多敲几次，防止写入失败</code></pre><p>知识穿插：</p><pre><code>超级块记录了分区的元数据，超级块会有备份，分别存于1,3,5,7,9五个块组中</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DAY-12&quot;&gt;&lt;a href=&quot;#DAY-12&quot; class=&quot;headerlink&quot; title=&quot;DAY 12&quot;&gt;&lt;/a&gt;DAY 12&lt;/h1&gt;&lt;h2 id=&quot;认识磁盘&quot;&gt;&lt;a href=&quot;#认识磁盘&quot; class=&quot;headerlink&quot; title=&quot;认
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rmp命令、yum命令、编译安装实例</title>
    <link href="http://yoursite.com/2018/08/09/%E7%AC%AC%E5%9B%9B%E5%91%A8-rmp%E5%91%BD%E4%BB%A4%E3%80%81yum%E5%91%BD%E4%BB%A4%E3%80%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/08/09/第四周-rmp命令、yum命令、编译安装实例/</id>
    <published>2018-08-09T12:00:00.000Z</published>
    <updated>2018-08-12T13:24:27.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DAY-11"><a href="#DAY-11" class="headerlink" title="DAY 11"></a>DAY 11</h1><h2 id="软件包管理之-rpm命令"><a href="#软件包管理之-rpm命令" class="headerlink" title="软件包管理之 rpm命令"></a>软件包管理之 rpm命令</h2><p><strong>软件运行环境和编译</strong></p><pre><code>不同的库对应不同的API接口:    开发应用程序常常需要调用库文件    使用对应的API接口调用对应的库    POSIX：通用的API接口不同系统的ABI接口不同:    应用程序想在某个系统上运行，需要有对应的ABI接口，符合系统的接口    linux与Windows ABI接口不同    linux ：ELF    Windows：PE程序源代码的处理过程：    预处理：        把必要的数据简单处理，删除注释信息    编译： 静态编译或动态编译        语法检查        把文本文件转化为汇编语言    汇编：        将汇编语言生成二进制的机器码    链接：静态链接或动态链接        由于调用库，把调用的程序库与程序关联起来，已形成一个完整的二进制程序</code></pre><p><strong>库文件</strong>  </p><pre><code>查看命令所调用的库    ldd &lt;二进制程序路径&gt;加载库文件    ldconfig显示已缓存的所有可用库文件以及文件路径    /sbin/ldconfig -p映射关系    配置文件：/etc/ld.so.conf            /etc/ld.so.conf.d/*.conf    缓存文件：/etc/ldconfig.so.cache</code></pre><p><strong>RPM包管理员</strong> (RPM Package Manager)</p><p>功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件，从而方便快捷的实现程序包的安装、卸载、升级、查询、校验、数据库维护。</p><pre><code>RPM软件包分为:二进制包、源代码包和delta包三种。    &lt;二进制包&gt;可以直接安装在计算机中：        二进制应用程序的组成部分：二进制文件、库文件、配置文件、帮助文件。    &lt;源代码包&gt;将会有RPM自动编译、安装。        源代码包经常以src.rpm作为后缀名包文件组成：    RPM包内的文件    RPM的元数据：        名称，版本，依赖性，描述等        安装或卸载时运行的脚本</code></pre><p>RPM数据库：/var/lib/rpm </p><pre><code>该数据库很重要，包含以下信息：    安装软件包名称及版本    依赖关系    功能说明    包安装后生成的各文件路径级校验码</code></pre><p>rpm命令：</p><pre><code>    用法：rpm [option] [参数]    常用： rpm -ivh &lt;rpm软件包&gt;    选项：        -i/--install 安装软件包            -i --test 测试安装，但不执行安装            -i --nodeps 忽略依赖性，安装后也不能用，需补全依赖环境，用于强制安装和强制卸载            -i --replacepkgs  强制重装软件            -i --replacefiles  强制重装替换文件        -v 显示安装过程        -vv 更加详细的安装过程        -U 升级软件包，不存在旧版本则安装软件包，不常用        -F 升级软件包，不存在旧版本则不做任何操作，不常用        -e 删除软件            --allmatches 所有            --nodeps 忽略依赖性卸载        -h 安装进度，以#号显示进度条        -q 查看信息            -ql 查看软件包的文件列表                -qlp 针对未安装的程序包，查看文件列表            -qa 查看当前系统已安装的软件包            -qf 查看包版本，查找rpm数据库            -qc 查看配置文件            -qd 查看man帮助文档文件            --whatrequires 查询包的依赖性             --changelog 查看版本更新日志            --script 查看程序包自带脚本        --oldpackage 降级        --force 强制安装        -V 校验    参数：        软件包rpm公钥：pubkey    导入本地公钥：rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7rpm的缺点：不能解决包的依赖性注意：一般用-i升级内核；-U、-F用于升级但不常用</code></pre><hr><h2 id="软件安装工具之-yum命令"><a href="#软件安装工具之-yum命令" class="headerlink" title="软件安装工具之 yum命令"></a>软件安装工具之 yum命令</h2><p><strong>yum：底层依赖于rpm，主要用于解决依赖性</strong></p><p>使用yum安装软件的前提：需要相应的yum仓库和yum源</p><p><strong>yum相关配置文件：</strong></p><pre><code>yum配置文件    /etc/yum.confyum日志文件     /var/log/yum.logyum仓库配置文件    /etc/yum.repos.d/*.repo</code></pre><p><strong>自定义yum源：将任目录作为yum源</strong></p><pre><code>creatrepo &lt;路径&gt;eg：将当前目录作为yum源    createrepo .</code></pre><p><strong>创建yum仓库</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在/etc/yum.repos.d目录下，创建&lt;任意名字&gt;.repo文件,格式如下</span><br><span class="line">    [仓库名]</span><br><span class="line">    name=仓库名.db</span><br><span class="line">    baseurl=file://本地yum源</span><br><span class="line">            http://网络yum源</span><br><span class="line">    gpgcheck=0</span><br></pre></td></tr></table></figure></p><p>yum命令：</p><pre><code>用法：yum [option].. &lt;软件名&gt;常用：    yum install &lt;软件名&gt;  安装软件    yum remove  &lt;软件名&gt;  卸载软件选项：    yum repolist 显示yum仓库列表    yum hisroty    查看安装历史列表        info n 查看安装的软件        undo n 撤销安装        redo n 重新执行n历史行为    yum clean all 清理yum缓存    yum install -q -y 静默安装    yum provides 查看文件由哪个包提供    yum search 搜索    yum grouplist  包组列表    yum groupinstall 安装包组    yum groupremove 卸载包组    yum groupinfo 查看包组信息    yum deplist  查看依赖文件    yum reinstall  重装    yum info 查看包信息</code></pre><p>其他用法：安装工具yum-utils</p><pre><code>repoquery -ql 查找未安装好的软件包中包含的文件列表，基于yum仓库的工具 yum-utils</code></pre><hr><h2 id="编译安装软件：-程序包编译可以实现功能定制以及路径指定"><a href="#编译安装软件：-程序包编译可以实现功能定制以及路径指定" class="headerlink" title="编译安装软件： 程序包编译可以实现功能定制以及路径指定"></a>编译安装软件： 程序包编译可以实现功能定制以及路径指定</h2><p><strong>编译安装软件实例</strong></p><pre><code>eg：编译安装httpd软件1.准备环境安装编译httpd所需工具    develoment tools    apr-devel    apr-util-devel    gcc    openssl-devel2.了解软件进入源码包解压后的目录中，寻找3个文件    README      介绍软件的文件    INSTALL     安装教程的文件    ./configure 可执行文件3.编译安装。执行命令: ./configure --prefix=路径  &amp;&amp; make &amp;&amp; make install  ,等待编译安装完成    补充：        ./configure有许多的选项        默认选项：--prefix=路径 不分文别类，所有东西存放在同一目录        其他选项数量太多，而且还不会使用，不一一列出4.添加PATH变量进入指定的安装目录下的bin/apachectl    将路径添加PATH变量并重定向到文件中：    echo &apos;PATH=&lt;路径&gt;:$PATH&apos;  &gt;  /etc/profile.d/httpd.sh       使配置文件生效：    source /etc/profile.d/http.sh    启动http服务：    apachectl start      可查看端口80是否已开启：    ss -ntl 至此，http的编译安装以及使用完成。</code></pre><p>额外的知识穿插：</p><pre><code>救援模式下：切换根目录为/mnt/sysimage/    --root=/mnt/sysimage/    chroot /mnt/sysimage/ 恢复被删除的二进制文件，可能会造成文件属性丢失，与源文件属性不同    rpm2cpio |cpio -tv 预览文件    rpm2cpio |cpio -idv ./usr/bin/tree  取出指定文件，    cp .usr/bin/tree /usr/bin/扫描磁盘命令    echo &apos;- - -&apos; &gt; /sys/class/scsi_host/host0/scan</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DAY-11&quot;&gt;&lt;a href=&quot;#DAY-11&quot; class=&quot;headerlink&quot; title=&quot;DAY 11&quot;&gt;&lt;/a&gt;DAY 11&lt;/h1&gt;&lt;h2 id=&quot;软件包管理之-rpm命令&quot;&gt;&lt;a href=&quot;#软件包管理之-rpm命令&quot; class=&quot;head
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件查找以及打包压缩</title>
    <link href="http://yoursite.com/2018/08/07/%E7%AC%AC%E5%9B%9B%E5%91%A8-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8C%85%E5%8E%8B%E7%BC%A9/"/>
    <id>http://yoursite.com/2018/08/07/第四周-文件查找以及打包压缩/</id>
    <published>2018-08-07T12:00:00.000Z</published>
    <updated>2018-08-12T12:05:19.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DAY-10"><a href="#DAY-10" class="headerlink" title="DAY 10"></a>DAY 10</h1><h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><p>查找文件的方法有两种：  </p><pre><code>非实时查找--locate命令  实时查找--find命令(常用)</code></pre><p><strong>locate命令</strong></p><pre><code>原理：通过索引数据库完成文件查找    /var/lib/mlocate/mlocate.db（二进制文件）更新数据库：    updatedb特点：    查找速度快    模糊查找    非实时查找    搜索的文件是全路径，不仅仅是文件名    只能搜索用户具备读取和执行权限的目录用法：locate &lt;文件名&gt;选项：    -i 不区分大小写搜索    -n # 只列举#个    -r 使用正则表达式eg：搜索名称或路径中带有&quot;conf&quot;的文件        locate conf    使用REGEX(正则表达式)来搜索&quot;.conf&quot;结尾的文件        locate -r &apos;\.conf$&apos;</code></pre><p><strong>find命令</strong></p><pre><code>原理：通过遍历指定路径完成文件查找  工作特点：      查找速度略慢    精确查找    实时查找    只能搜索用户具备读取和执行权限的目录用法：    find [选项].. [查找路径] [查找条件] [处理动作]    该命令默认是递归搜索    查找路径：指定具体目标路径，默认当前目录    查找条件：指定的查找标准，可以是文件名、大小、类型、权限等标准进行；默认找出指定路径下的所有文件    处理动作：对符合条件的文件做操作，默认输出至屏幕查找条件：    搜索层级：        -maxdepth n 搜索指定最大层级，n表示层数        -mindepth n 搜索指定最小层级，n表示层数    根据文件名和inode查找：        -regex          使用正则搜索文件          -name           精确查找，支持通配符        -i              忽略大小写        -inum n         按节点编号查找文件，n表示节点编号        -samefilename   查找相同的文件，节点编号相同的文件        -links n        搜索软链接数为n的文件    根据属主属组查找：        -user &lt;用户名&gt;   查找指定用户名属主的文件         -group &lt;组&gt;      查找指定组名属组的文件        -uid &lt;id&gt;       查找指定uid号属主的文件        -gid &lt;id&gt;       查找指定gid号属组的文件        -nogroup        查找没有属组的文件         -nouser         查找没有属主的文件    根据文件类型查找：        -type f 查找普通文件        -type d 查找目录文件        -type l 查找符号链接文件        -type s 查找套接字文件        -type b 查找块设备文件        -type c 查找字符设备文件        -type p 查找管道文件        空文件或目录            find -empty         查找空文件            find -type f -empty    根据文件大小查找        -size &lt;文件大小&gt;             eg：-size -6M  (0M,5M]                -size  6M  (5M,6M]                -size +6M  (6M,∞)    根据时间戳查找        以天为单位：            -atime ±#            eg：-atime -# [0,#)                  -atime  # (#,#+1)                  -atime +# [#+1,∞]            -mtime            -ctime        以分钟为单位：            -amin ±#            -mmin ±#            -cmin ±#    根据权限查找        -perm[/|-]MODE            MODE:精确权限匹配            /MODE:任何一类(u,g,o)对象的权限中只要能一位匹配即可            -MODE 每一类对象都必须同时拥有指定权限,至少                            -644                110 100 100 ，1检查位，0不检查                find /data -perm -222 -ls        find -perm 755 会匹配权限模式恰好是755的文件        只要当任意人有写权限是，find -perm +222就会匹配        只有当每个人都有写权限是，find -perm -222才会匹配        只有当其他人(other)有写权限是，find -perm -002才会匹配    组合条件：        与:-a        或:-o        非：-not,!    德摩根定律：        (非A)或(非B)=非(A且B)        (非A)且(非B)=非(A或B)处理动作：    -print 默认的处理动作，显示至屏幕    -ls  类似于对查找到的文件执&quot;ls -l&quot; 显示详细信息    -delete 删除查找到的文件    -fls 用于长信息重定向到文件中    -ok command {} \;   对查找到的每个文件执行由command指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认 {}表示搜索到的文件    -exec command {}\； 对查找的每个文件执行由command指定的命令，</code></pre><p><strong>Gnome搜索工具</strong> </p><pre><code>位置-&gt;搜索文件...图形化搜索工具，可搜索    命令    内容    用户/组群    大小    修改时间</code></pre><p><strong>xargs</strong> 传命令参数  </p><pre><code>touch {1..1000000}.txt  此命令参数过大无法创建文件  但是可以通过管道使用xargs将参数传给touch来实现          eg：    echo {1..1000000}.txt|xargs touch</code></pre><hr><h2 id="压缩与打包"><a href="#压缩与打包" class="headerlink" title="压缩与打包"></a>压缩与打包</h2><p><strong>压缩与解压工具：</strong> compress、gzip、bzip2、xz</p><pre><code>compress: 压缩包格式file.Z    用法：compress     选项：        compress -d &lt;file.Z&gt;   解压缩，不保留源文件        uncompress &lt;file.Z&gt;    等同-d解压缩        compress -c &lt;file.Z&gt;   结果输出至标准输出，不删除源文件        compress -c &apos;file&apos; &gt; &apos;file.Z&apos;  保留源文件，并生成压缩包        zcat &apos;file.Z&apos; &gt; &apos;file&apos;  重定向解压缩gzip/gunzip: 压缩包格式file.gz    用法：gzip [option].. file..    选项：        gzip -d &lt;file.gz&gt;  解压缩，不保留源文件        gunzip &lt;file.gz&gt;  等同-d解压        gzip -c &lt;file.gz&gt; 结果输出至标准输出，不删除源文件        -#：1-9，指定压缩比，值越大压缩比越大        zcat &apos;file.gz&apos; &gt; &apos;file&apos;   重定向解压缩    eg：(待添加)bzip2: 压缩包格式file.bz2    用法：bzip2 [option].. file..    选项：        bzip2 -k &lt;file&gt;   压缩文件，并保留源文件        bzip2 -d &lt;file.bz2&gt; 解压缩，不保留源文件        bunzip2 &lt;file.bz2&gt; 等同于-d解压缩        -#：1-9，指定压缩比，值越大压缩比越大        bzcat  &apos;file.bz2&apos;  &gt;  &apos;file&apos;   重定向解压缩    eg：(待添加)xz: 压缩包格式file.gz    用法：xz [option].. file..    选项：        xz -k &lt;file&gt; 压缩文件，并保留源文件        xz -d &lt;file.xz&gt; 解压缩,不保留源文件        -#：1-9，指定压缩比，值越大压缩比越大        unxz &lt;file.xz&gt;  等同于-d解压缩        xzcat file.xz &gt; file 重定向解压缩，以及查看内容    eg：(待添加)注意：压缩工具中压缩比越高，越损耗cpu性能</code></pre><p><strong>打包工具：</strong> zip与tar</p><pre><code>zip：压缩包格式file.zip  (个人认为不常用，稍作了解即可)    用法：zip [option] file.zip file..将多个文件或者文件夹打包压缩，压缩比不高    选项：        zip -r file.zip file1 file2  递归处理将指定目录下的所有文件和子目录一并打包，且将绝对路径改为相对路径        unzip file.zip 解压缩文件        unzip -t file.zip 检查压缩包的完整性        unzip -v file.zip 只查看压缩包内容，不解压缩        unzip -j file.zip 将所有子目录中的文件全部解压到第一级目录tar：linux最常用的打包程序，通常以.tar结尾 （tape archive 磁带归档）    用法：tar [option].. file..          注意：tar本身不具有压缩功能，他是调用压缩功能实现的    选项：        -c 建立新的压缩文件        -x 从压缩文件中提取文件        -v 显示解压过程        -f 指定压缩文件        -Z 支持compress解压文件        -j 支持bzip2解压文件        -z 支持gz解压文件        -t 显示压缩文件的内容        -W 确认压缩文件的正确性        -A 新增压缩文件到已存在的压缩    常用组合        tar cvf 文件.tar 文件        -p  显示打包过程        -cvf  打包        -tvf  预览解包        -xvf  解包        jcvf  打包成.tar.bz2        jxvf  将.tar.bz2解包        zcvf  打包成.tar.gz        zxvf  将.tar.gz解包        Zcvf  打包成.tar.Z        Zxvf  将.tar.Z解包        Jcvf  打包成.tar.xz        Jxvf  将.tar.xz解包    -X 指定不打包的文件列表,选项后跟文件        -X file    -T 指定要打包的文件列表，选项后跟文件        -T file</code></pre><p><strong>切割文件的工具：</strong></p><pre><code>splist命令：将一个大文件分割成很多个小文件，提高可读性，生成日志等    用法：split [option] [size] file    选项：        -b size          -d  切割后的文件使用数字后缀命名         -a n  指定后缀的长度为n        -l n  根据文件的行数来分割文件，每个小文件n行        合并文件                    cat 被切割过的所有文件 &gt; 合并后的文件名</code></pre><p><strong>重定向打包工具：</strong></p><pre><code>cpio命令    通过重定向的方式将文件进行打包备份，还原恢复的工具，他可以解压以&apos;.cpio&apos;或&apos;.tar&apos;结尾的文件    功能：从归档中复制文件，或者复制文件到归档中    用法：        cpio [option] &gt; 文件名或者设备名        cpio [option] &lt; 文件名或者设备名    选项：        -o 将文件拷贝打包成文件或者将文件输出到设备上        -i 解包，将打包文件解压或将设备上的备份还原到系统        -t 预览，查看文件内容或者输出到设备上的文件内容        -v 显示打包过程中的文件名称        -d 解包生成目录，在cpio还原时，自动建立的目录        -c 一种较新的存储方式    eg：将/etc目录备份：        find  ./etc print|cpio -ov &gt;etc.cpio    eg: 内容预览        cpio -tv &lt; etc.cpio    eg: 解包文件        cpio -idv &lt; etc.cpio</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DAY-10&quot;&gt;&lt;a href=&quot;#DAY-10&quot; class=&quot;headerlink&quot; title=&quot;DAY 10&quot;&gt;&lt;/a&gt;DAY 10&lt;/h1&gt;&lt;h2 id=&quot;文件查找&quot;&gt;&lt;a href=&quot;#文件查找&quot; class=&quot;headerlink&quot; title=&quot;文
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shell脚本编程基础知识</title>
    <link href="http://yoursite.com/2018/08/05/%E7%AC%AC%E4%B8%89%E5%91%A8-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/08/05/第三周-shell脚本编程基础知识/</id>
    <published>2018-08-05T08:00:00.000Z</published>
    <updated>2018-08-05T08:20:15.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DAY-8-9"><a href="#DAY-8-9" class="headerlink" title="DAY 8-9"></a>DAY 8-9</h1><h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><p><strong>程序:为了更好的处理数据</strong>  </p><pre><code>程序:算法+数据结构  数据:是程序的核心   数据结构：数据在计算集中的类型和组织方式  算法： 处理数据的方式  </code></pre><p><strong>程序编程风格：</strong>  </p><pre><code>过程式：以指令为中心，数据服务于指令（shell编程基于过程式）  对象式：以数据为中心，（开发语言推崇使用）  </code></pre><p>shell程序：提供了编程能力，解释执行的过程<br>shell编程：过程式、解释执行  </p><p><strong>程序的执行方式：</strong></p><pre><code>运行二进制指令    编程语言：人于计算机之间交互的语言低级编程语言：    机器：二进制的0和1的序列，称为机器指令    汇编：艰涩难懂，贴近硬件高级编程语言：    编译型语言：        英文句子--&gt;编译器--&gt;编译成机器代码--&gt;执行 （时间短）        典型：C    解释型语言：        英文句子--&gt;执行--&gt;解释器--&gt;解释成机器代码（每次执行都要有一个解释的过程，时间长）        典型：shell、python、perlJava的程序比较特殊： 转换中间代码（处理数据运行于虚拟机），屏蔽底层的接口，实现（一次编译到处运行）</code></pre><p><strong>编程的基本概念：</strong></p><pre><code>编程逻辑处理方式：    顺序循环    循环执行    选择执行编程的基本结构：    各种系统命令的组合    数据存储：变量、数组    表达式：a+b    语句：if</code></pre><hr><h2 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h2><p>—shell脚本：包含一些命令或声明，并符合一定格式的文本文件</p><p><strong>格式要求：</strong> 首行shebang机制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  使用bash</span></span><br><span class="line"><span class="meta">#!/bin/csh   使用csh</span></span><br><span class="line"><span class="comment">#!/bin/python 使用python    //格式要求：首行shebang机制，命名与所用解释器有关</span></span><br></pre></td></tr></table></figure></p><p><strong>shell脚本的用途：</strong> 减少重复操作</p><pre><code>自动化常用命令执行系统管理和故障排除创建简单的应用程序处理文本或文件</code></pre><p><strong>创建shell脚本：</strong><br>    第一步：使用文本编辑器来创建文本文件<br>      脚本内容的第一行必须是shebang机制#!/bin/bash  ，后续可以跟注释，注释以#开头，用于提醒其他人<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg：vim test.sh  //创建文本</span><br><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="comment">#the first foot book   //此处为注释</span></span><br><span class="line">hellowold</span><br></pre></td></tr></table></figure></p><p>第二步：运行脚本<br>        运行的方法有很多种 </p><pre><code>直接运行解释器，将脚本作为解释器程序的参数运行      bash test.sh  给予执行权限，将脚本放入$PATH变量中的所指定的路径      chmod +x test.sh      test.sh  亦可用绝对路径运行脚本      /path/to/test  </code></pre><p>注意：脚本属于外部命令，外部命令执行需要通过$PATH变量所在路径去搜索命令  </p><pre><code>将当前目录作为PATH变量中的路径(基于安全，此方法少用为好)     PATH=.:$PATH        &apos;.&apos;表示当前目录，&apos;:&apos;为了保留之前的变量，用冒号隔开，将此变量加入配置文件中，并且source使配置文件生效即可  不常用的脚本运行方式：因为会改变环境变量    . test.sh          source test.sh </code></pre><p><strong>脚本规范：</strong>   脚本代码开头约定（除了shebang机制必须添加，其它注释看个人喜好添加）  </p><pre><code>第一行一般为shebang机制作者日期版本号程序名程序作用版本更新的简要说明</code></pre><p><strong>脚本的基本结构：</strong>  </p><pre><code>#!shebang 声明机制  configuration_variables 配置变量  function_definitions 函数定义  main_code 主程序代码  </code></pre><p><strong>脚本调试：</strong></p><pre><code>检测脚本的语法错误：有时候报错的行数不是很精确，但是可在该行数附近找找错误    bash -n &lt;脚本程序&gt;跟踪调试命令的执行过程：        bash -x &lt;脚本程序&gt;</code></pre><p><strong>脚本名字：</strong> 见名知义</p><pre><code>命名方法驼峰法    小驼峰 studentName  第二个单词首字母大写    大驼峰 StudentName  全部的单词首字母大写</code></pre><p>bug：程序错误<br>debug：调试错误，解决错误</p><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量：</strong> 代表一块内存空间，人为的命名  </p><pre><code>变量：任何一种编程语言都应该有变量，为程序提供数据程序：是由指令加数据组成    指令：由程序文件提供    数据：IO设备、文件、管道、变量程序也有另外一种说法：是由算法+数据结构来组成的变量名：指向内存空间中某一段空间中的起始地址变量名+指向的内存空间变量赋值：name=value变量类型：存储格式、表示数据范围、参与的运算    用于编程语言：        强类型变量：        弱类型变量：            bash中把所有变量都被视为字符型，不支持浮点数据            bash中的变量无需事先声明，同时实现声明和赋值。                声明的意思：说明变量类型，定义变量名称变量替换：把变量名出现的位置替换为其所指向的内存空间中的数据变量引用：$(变量名),$变量名        null视为空变量命名法则：见名知义    不能使用程序中的保留至：如if，for    只能使用数字、字母、下划线，且不能以数字开头    统一命名规则：驼峰法        小驼峰studentName        大驼峰StudentName</code></pre><p><strong>bash进程：</strong>  bash子进程与bash父进程</p><pre><code>显示进程树    pstree -p查看bash父进 程编号    echo $PPID查看当前bash进程编号    echo $$ 开启bash子进程，脚本在子进程中运行，不影响环境变量    bash &lt;脚本程序&gt; 不开启bash子进程，执行脚本将影响环境变量    source &lt;脚本程序&gt; ()开启子进程执行命令，{}当前进程执行命令 </code></pre><p><strong>bash中变量种类:</strong>  局部变量、环境变量、只读变量、位置变量</p><p>局部变量：当前进程使用</p><pre><code>生效范围在当前终端的shell进程中，若切换终端窗口，变量失效</code></pre><p>   eg：name=xcb<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># name=xcb   //变量赋值</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $name  //当前终端窗取变量</span></span><br><span class="line">xcb         //当前终端窗口打印了xcb</span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $name  //新开终端窗口去变量</span></span><br><span class="line">            //新的终端窗口打印为空，变量失效</span><br><span class="line">[root@Souler7 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>环境变量：可以传给子进程使用，但不可传给父进程  </p><pre><code>由bash内建的变量    PATH  外部命令的搜索路径    SHELL 当前使用的shell    USER  用户名    UID   用户ID    HOME  用户家目录    PWD   当前路径    SHLVL 当前子进程嵌套数    LANG  语言    MAIL  邮箱路径    HOSTNAME 主机名    HISTSIZE 最大历史记录条数    RANDOM  随机数显示前一个命令的参数    echo $_  删除变量，但无法删除只读变量    unset &lt;变量名&gt; 将局部变量定义为环境变量    exprot 查看环境变量    env     printenv    export     declare -x</code></pre><p> eg:RANDOM的使用<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># echo $[RANDOM%7]  表示对7取模，0-6随机数</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $[RANDOM%7+31]]  取31到37的随机数</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># color=$[RANDOM%7+31];echo -e "\e[1;$&#123;color&#125;mCLOOR\e[0m"    取随机颜色</span></span><br></pre></td></tr></table></figure></p><p>只读变量：不可删除</p><pre><code>声明只读变量    declare -r    readonly查看只读变量    readonly -p  </code></pre><p>位置变量：灵活  </p><pre><code>$1,$2...: 对应第1、第2等参数，    shift 每个数据往左移动1位，原先第一个数据被覆盖    shift n 同理$* 所有变量 例如：a b c 参数被视为一个字符串$@ 所有变量 例如：a b c 每个参数是独立的字符串    注意：$*与$@只有在被双引号抱起来的时候才会有差异，否则，为相同意思$# 传递给脚本的参数个数$0 显示命令本身，脚本所在路径    basename $0 只显示脚本名称set-- 清空所有位置变量</code></pre><p>退出状态：特殊变量$?的使用  </p><pre><code>查看上一命令执行结果成功或失败    echo $?默认退出状态码        0 代表成功， 1-255 代表失败自定义退出状态码    exit [n]</code></pre><p>注意：脚本中一旦遇到exit命令，脚本会立即终止，终止退出状态取决于exit命令后面的数字<br>注意：如果脚本未指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码</p><hr><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><strong>bash中的算数运算：</strong>  仅支持整数运算</p><pre><code>bash中的算数运算：let运算符号：+、-、*、/、%（取余）、**（乘方）数字运算符号        -eq 等于        -ne 不等于        -lt 小于        -le 小于等于        -gt 大于        -ge 大于等于</code></pre><p>方法1：let sum=a+b 默认是let，可不加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># a=2</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># b=3</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># let sum=a+b</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $sum</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure></p><p>方法2：echo $[a*b] ，a=$[算术表达式]可用于逻辑运算<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    [root@Souler7 bin]<span class="comment"># a=2</span></span><br><span class="line">    [root@Souler7 bin]<span class="comment"># b=3</span></span><br><span class="line">    [root@Souler7 bin]<span class="comment"># echo $[a*b]</span></span><br><span class="line">    6</span><br><span class="line">```     </span><br><span class="line">方法3：<span class="built_in">echo</span> $((a-b))  ((a=10+11)) <span class="built_in">echo</span> <span class="variable">$a</span> 会显示a运算的值为21</span><br><span class="line">```bash</span><br><span class="line">    [root@Souler7 bin]<span class="comment"># a=2</span></span><br><span class="line">    [root@Souler7 bin]<span class="comment"># b=3</span></span><br><span class="line">    [root@Souler7 bin]<span class="comment"># echo $((a-b))</span></span><br><span class="line">    -1</span><br></pre></td></tr></table></figure></p><p>方法4：expr命令，专门做运算的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># expr 3 \* 3   (每个参数之间都需要空格，且*需要转义，+不用转义)</span></span><br><span class="line">9</span><br></pre></td></tr></table></figure></p><p>方法5：declare -i (个人不推荐使用，给每个变量赋值都需要加declare -i)单独使用可用于查看变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># declare -i a=5</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># declare -i b=6</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># declare -i sum=$a*$b</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $sum</span></span><br><span class="line">30</span><br></pre></td></tr></table></figure></p><p>方法6：使用bc命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># echo 30/5|bc</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><p><strong>赋值：</strong></p><p>增强型赋值：+=、-=、*=、/=、%=<br>eg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># let n=10</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $n </span></span><br><span class="line">10</span><br><span class="line">[root@Souler7 bin]<span class="comment"># let n+=10  (表示为n=n+10)</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $n  </span></span><br><span class="line">20</span><br></pre></td></tr></table></figure></p><p>自增自减：  </p><pre><code>let n++   表示为n=n+1,先赋值后加1let n--   表示为n=n-1,同上let ++n   表示为n=n+1，先加1后赋值let --n   表示为n=n-1,同上</code></pre><p>eg：<br>let m=n++, echo $m ,m=10<br>eg：<br>let m=++n, echo $m ,m=11</p><p><strong>逻辑运算：</strong></p><pre><code>true or false：      true：1    //此处1表示真    false：0   //0表示假与或非运算、异或运算：    与：符号&amp;表示与        有0则为假        1与1=1        1与0=0        0与1=0        0与0=0    或：符号|表示或        有1则为真        1或1=1        1或0=1        0或1=1        0或0=0    非：符号！表示非        对结果取反        ！1=0        ！0=1    异或：符号^表示异或：        异或的两个值，相同为假，不同为真        1^1=0 假        1^0=1 真        0^1=1 真        0^0=0 假                       公式：a^b=c,b=c^a,a=c^b</code></pre><p>eg：判断a大于b是否为真，并使用逻辑取反<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># a=5</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># b=10</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ $a -gt $b ]   //判断逻辑运算是否为真</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $?</span></span><br><span class="line">1   //结果为假</span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ ! $a -gt $b ]  //对逻辑运算取反</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $?</span></span><br><span class="line">0   //取反后，结果为真</span><br></pre></td></tr></table></figure></p><p>eg：利用异或运算，互换a与b的值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># a=10</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># b=5</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># a=$[a^b]  //a此时拿到了中间值c</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># b=$[a^b]  //c与b异或且赋值给b，此时b得到了a的初始值10，b=10</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># a=$[a^b]  //c与b(a的初始值)异或,此时a的值为b的初始值5，a=5</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo a=$a b=$b </span></span><br><span class="line">a=5 b=10   //从该结果可看到实现了a与b的值互换</span><br></pre></td></tr></table></figure></p><p>短路运算：</p><pre><code>短路与：符号&amp;&amp;表示短路与    cmd1 &amp;&amp; cmd2 若cmd1为true ，则执行cmd2    cmd1 &amp;&amp; cmd2 若cmd1为false，则不执行cmd2短路或：符号||表示短路或    cmd1 || cmd2 若cmd1为ture ，则不执行cmd2    cmd1 || cmd2 若cmd1为false，则执行cmd2组合使用：        如果cmd1成功，就执行cmd2，如果cmd2成功(此处假设cmd2总成功)，就执行cmd3        cmd1 &amp;&amp; cmd2 || cmd3    如果cmd1失败，就执行cmd2，如果cmd2成功(此处假设cmd2总成功)，就执行cmd3        cmd1 || cmd2 &amp;&amp; cmd3</code></pre><hr><h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p><strong>描述：</strong><br>判断某需求是否满足，需要由测试机制来实现  </p><pre><code>专用的测试表达式需要由测试命令辅助完成测试过程</code></pre><p>评估布尔声明，以便用在条件性执行中  </p><pre><code>若真，则返回0若假，则返回1注意：此处的0、1不同于逻辑运算中的0、1</code></pre><p><strong>测试命令：</strong> test命令</p><pre><code>三种用法：    test EXPRESSION    [ EXPRESSION ]    [[ EXPRESSION ]]注意：[ ]内有字符即为真，无字符则为假，空格也算字符</code></pre><p>用法1：test EXPRESSION  (不常用)<br>eg：判断a是否小于b<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># a=5</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># b=10</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># test $a -lt $b</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $? //查看结果</span></span><br><span class="line">0     //结果为真,故a小于b</span><br><span class="line">[root@Souler7 bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>用法2：[ EXPRESSION ]</p><pre><code>选项：    用于文件类型测试：        [ -a &quot;文件路径&quot; ] 判断文件的存在性，存在为真，不存在为假        [ -b &quot;文件路径&quot; ] 判断文件是否为 块设备，存在为真，不存在为假        [ -c &quot;文件路径&quot; ] 判断文件是否为字符设备，存在为真，不存在为假        [ -d &quot;文件路径&quot; ] 判断文件是否为文件夹，是为真，否为假        [ -f &quot;文件路径&quot; ] 判断文件是否为普通文件，是为真，否为假            -f无法识别软链接，而是直接识别软链接所指向的文件        [ -L &quot;文件路径&quot; ] 判断文件是否为软链接，是为真，否为假            -L针对判断软链接    用于文件权限测试：        [ -u &quot;文件路径&quot; ] 判断文件是否为有suid权限，是为真，否为假        [ -g &quot;文件路径&quot; ] 判断文件是否为有sgid权限，是为真，否为假        [ -k &quot;文件路径&quot; ] 判断文件是否为有sticky权限，是为真，否为假        [ -r &quot;文件路径&quot; ] 判断对文件是否为有r权限，是为真，否为假        [ -w &quot;文件路径&quot; ] 判断对文件是否为有w权限，是为真，否为假        [ -x &quot;文件路径&quot; ] 判断对文件是否为有x权限，是为真，否为假    用于文件大小测试：        [ -s &quot;文件路径&quot; ] 判断对文件是否存在且非空，是为真，否为假    用于测试文件是否打开：        [ -t fd ] 判断文件描述符是否在某终端已经打开，是为真，否为假        [ -N &quot;文件路径&quot; ] 判断文件从上一次被读取之后是否被修改过，是为真，否为假        [ -O &quot;文件路径&quot; ] 判断对文件属主是否为当前登录用户，是为真，否为假        [ -G &quot;文件路径&quot; ] 判断对文件属组是否为当前登录用户，是为真，否为假    双目测试：        [ &quot;文件1&quot; -ef &quot;文件2&quot; ] 判断文件1是否为文件2的硬链接，是为真，否为假        [ &quot;文件1&quot; -nt &quot;文件2&quot; ] 判断文件1是否比文件2新，是为真，否为假        [ &quot;文件1&quot; -ef &quot;文件2&quot; ] 判断文件1是否比文件2旧，是为真，否为假    同时判断多个条件，        用-a来实现，表示与的关系        用-o来实现，表示或的关系        用！来实现，表示非,取反的关系</code></pre><p>eg：判断a是否小于b<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># a=5</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># b=10</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ $a -lt $b ]</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $? //查看结果</span></span><br><span class="line">0     //结果为真,故a小于b</span><br><span class="line">[root@Souler7 bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>eg：判断字符串是否相等,以及使用双引号””，避免出现语法错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># name=xcb   //变量赋值xcb   </span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># i=xcb      //变量赋值xcb</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ name = i ] &amp;&amp; echo ture || echo false  //语法错误，变量名前没有加$符号</span></span><br><span class="line"><span class="literal">false</span>   //此判断不成立</span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "$name" = "$i" ] &amp;&amp; echo ture || echo false //加上$再次判断</span></span><br><span class="line"><span class="literal">true</span>    //name=i，结果为真,输出<span class="literal">true</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># i=xxx    //对i赋一个新的值xxx</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "$name" = "$i" ] &amp;&amp; echo ture || echo false //判断变量name字符串是否等于变量i的字符串</span></span><br><span class="line"><span class="literal">false</span>  //name≠i，结果为假，输出<span class="literal">false</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "$name" = "xcb" ] &amp;&amp; echo ture || echo false //判断变量name的字符串是否为xcb</span></span><br><span class="line"><span class="literal">true</span>  //name=xcb，结果为真，输出<span class="literal">true</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ $name = xxx ] &amp;&amp; echo ture || echo false  //判断变量n的字符串是否为xxx</span></span><br><span class="line"><span class="literal">false</span>  //name≠xxx，结果为假，输出<span class="literal">false</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># unset name  //删除变量name</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ $name = xcb ] &amp;&amp; echo ture || echo false //当变量不存在，且变量名没有用双引号引起来，进行判断</span></span><br><span class="line">-bash: [: =: unary operator expected // 此处提示语法错误</span><br><span class="line"><span class="literal">false</span>  //此判断不成立</span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "$name" = xcb ] &amp;&amp; echo ture || echo false //当变量不存在，且变量名加了双引号，进行判断</span></span><br><span class="line"><span class="literal">false</span>  //此处没有提示语法错误，而是把引号内的变量名作为空字符，进行判断，结果为假</span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "" = xcb ] &amp;&amp; echo ture || echo false     </span></span><br><span class="line"><span class="literal">false</span>  //此处的结果，等同上一句的意思，亦可得出结论：加双引号可避免出现语法错误</span><br></pre></td></tr></table></figure></p><p>eg：判断变量是否为空，-z，-n的使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># name=xcb  //变量赋值</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $name</span></span><br><span class="line">xcb</span><br><span class="line">[root@Souler7 ~]<span class="comment"># [ -z "$name" ] &amp;&amp; echo true ||echo false //判断变量是否为空，空为true，非空为false</span></span><br><span class="line"><span class="literal">false</span> //变量非空，结果为<span class="literal">false</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># [ -n "$name" ] &amp;&amp; echo true ||echo false //判断变量是否非空，空为false，非空为true</span></span><br><span class="line"><span class="literal">true</span>  //变量非空</span><br><span class="line">[root@Souler7 ~]<span class="comment"># unset name //删除变量</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># [ -z "$name" ] &amp;&amp; echo true ||echo false //判断变量是否为空，空为true，非空为false</span></span><br><span class="line"><span class="literal">true</span> //变量为空，结果为<span class="literal">true</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># [ -n "$name" ] &amp;&amp; echo true ||echo false //判断变量是否非空，空为false，非空为true</span></span><br><span class="line"><span class="literal">false</span> //变量为空，结果为<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>用法3：[[ EXPRESSION ]] 支持扩展正则表达式，=~引用正则表达式，变量用双引号引起来，扩展正则表达式不需要加引号</p><pre><code>[[ =~ ]] 支持扩展正则模式[[ == ]] 支持通配符[[ != ]] 表示取反</code></pre><p>eg：使用扩展正则表达式，判断变量是否符合要求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 bin]<span class="comment"># file=abc.sh        </span></span><br><span class="line">[root@Souler6 bin]<span class="comment"># [[ $file =~ \.sh$ ]] &amp;&amp; echo true || echo false //判断变量是否为.sh结尾的字符串</span></span><br><span class="line"><span class="literal">true</span>   //变量条件符合，结果为真</span><br><span class="line">[root@Souler6 bin]<span class="comment"># [[ $file =~ \.s$ ]] &amp;&amp; echo true || echo false  //判断变量是否为.s结尾的字符串</span></span><br><span class="line"><span class="literal">false</span>  //变量条件不符合，结果为假</span><br></pre></td></tr></table></figure></p><p>eg：判断输出的数字是否为合法IP地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 bin]<span class="comment"># ip=1.1.1.1; [[ "$ip" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2[0-5][0-5])\.)&#123;3&#125;([1-9]?[0-9]|1[0-9][0-9]|2[0-5][0-5])$ ]] &amp;&amp; echo ip right || echo ip error  </span></span><br><span class="line">ip right  //ip符合</span><br><span class="line">[root@Souler6 bin]<span class="comment"># ip=111.111.111.1111; [[ "$ip" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2[0-5][0-5])\.)&#123;3&#125;([1-9]?[0-9]|1[0-9][0-9]|2[0-5][0-5])$ ]] &amp;&amp; echo ip right || echo ip error  </span></span><br><span class="line">ip error  //ip不符合</span><br></pre></td></tr></table></figure></p><p>注意：EXPRESSION前后必须有空白字符  </p><hr><h2 id="配置用户环境"><a href="#配置用户环境" class="headerlink" title="配置用户环境"></a>配置用户环境</h2><p><strong>bash的配置文件:</strong> 按生效范围划分，存在两类：</p><pre><code>全局配置：    /etc/profile    /etc/profile.d/*.sh    /etc/bashrc个人配置：    ~/.bashrc    ~/.bash_profile</code></pre><p><strong>shell登录的两种方式：</strong></p><p>交互式登录：</p><pre><code>1.通过终端输入账号密码登录2.使用su - username 切换的用户    配置文件的生效顺序：        1--&gt;/etc/profile        2--&gt;/etc/profile.d/*.sh        3--&gt;~/.bash_profile        4--&gt;~/.bashrc        5--&gt;/etc/bashrc</code></pre><p>非交互式登录:</p><pre><code>1.su username2.图形界面打开的终端3.执行脚本       4.任何其他的bash实例    配置文件的生效顺序：        1--&gt;~/.bashrc        2--&gt;/etc/bashrc        3--&gt;/etc/profile.d/*.sh</code></pre><p><strong>类：</strong></p><p>profile类:为交互式登录的shell提供配置</p><pre><code>全局配置：    /etc/profile    /etc/profile.d/*.sh个人配置：    ~/.bash_profile        实现环境变量和函数启动程序的文件功用：    用于定义环境变量    运行命令或脚本</code></pre><p>bashrcl类：为非交互式和交互式登录的shell提供配置</p><pre><code>全局设置:    /etc/bashrc个人设置：    ~/.bashrc        实现别名和函数的文件功用：    定义命令别名和函数    定义本地变量</code></pre><p><strong>编辑配置文件生效：</strong></p><pre><code>修改profile和bashrc文件后需生效    两种方法：        重启        source或.    eg：. ~/.bashrc</code></pre><p><strong>bash退出任务:</strong></p><pre><code>~/.bash_logout文件：用于自动备份，删除临时文件用户退出登录shell时，自动执行在/etc/目录下创建nologin文件，可禁止普通用户登录</code></pre><hr><p><strong>关于bash如何展开命令行</strong>  (此处并不能很好的诠释，见谅..)</p><pre><code>把命令行分成单个命令词展开别名展开大括号的声明{}展开波浪符声明~命令替换$()和``再次把命令行分成命令词展开文件通配*、？、[abc]准备I/O重定向&lt;、&gt;运行命令</code></pre><p>防止扩展：  </p><pre><code>加引号    双引号&quot;&quot;防止部分扩展(本人目前还未搞懂..)    单引号&apos;&apos;防止所有扩展    反斜杆 \防止所有扩展</code></pre><p>eg：反斜杆 \,转义符，单引号’’也能防止所有扩展，除了’本身，双引号则行不通<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># name=xcb</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $name</span></span><br><span class="line">xcb</span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo \$name  //此处转义，$name只当为普通字符串</span></span><br><span class="line"><span class="variable">$name</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo '$name'  //此处''转义</span></span><br><span class="line"><span class="variable">$name</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo "$name"</span></span><br><span class="line">xcb</span><br></pre></td></tr></table></figure></p><p><strong>read命令：</strong> 把输入值分配给一个或多个shell变量常用于脚本</p><pre><code>选项：     -p        指定要显示的提示    -s        静默输入，一般用于密码    -n        N指定输出的字符长度N，达到字符长度自动退出    -d &apos;字符&apos; 指定输入字符为结束符，结束符出现立即退出    -t n      等待n秒，时间到自动退出对多个变量赋值    read x y z &lt;&lt;&lt; &quot;aaa bbb ccc&quot;</code></pre><p>eg：read -p用法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># read -p "Please input your name:" -t 30 xcb //定义变量名称为xcb，且该命令执行后等待输入</span></span><br><span class="line">Please input your name:xucanbin   //此处输入字符串xucanbin并自动赋值给变量xcb</span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $xcb   //打印变量xcb的值</span></span><br><span class="line">xucanbin    //显示为xcb的值为xucanbin</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DAY-8-9&quot;&gt;&lt;a href=&quot;#DAY-8-9&quot; class=&quot;headerlink&quot; title=&quot;DAY 8-9&quot;&gt;&lt;/a&gt;DAY 8-9&lt;/h1&gt;&lt;h2 id=&quot;编程基础&quot;&gt;&lt;a href=&quot;#编程基础&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文本处理工具和正则表达式</title>
    <link href="http://yoursite.com/2018/08/01/%E7%AC%AC%E4%B8%89%E5%91%A8-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/01/第三周-文本处理工具和正则表达式/</id>
    <published>2018-08-01T08:00:00.000Z</published>
    <updated>2018-08-05T08:19:39.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DAY7"><a href="#DAY7" class="headerlink" title="DAY7"></a>DAY7</h1><p><strong>抽取文本的工具</strong></p><p>cat命令：用于查看文本  </p><pre><code>选项-A 查看隐藏符号,控制符-n 显示行号-b 忽略空行显示行号-s 合并空行-E 显示回车结束符$</code></pre><p>less命令：用于查看文本，支持文本分页和翻页显示(man帮助中的翻页功能用的就是less)</p><pre><code>使用空格翻页，翻到底部不会退出文本/ 搜索 同man搜索(man帮助中的翻页以及搜索功能用的就是less命令)</code></pre><p>more命令：用于查看文本，支持文本分页和翻页显示</p><pre><code>使用空格翻页，翻到底部自动退出文本</code></pre><p>tac命令：用于查看文本</p><pre><code>将文本纵向倒着显示</code></pre><p>rev命令：用于查看文本</p><pre><code>将文本横向倒着显示</code></pre><p><strong>显示文件内容的头或者尾</strong></p><p>head命令：查看文本首部，不加选项默认前10行</p><pre><code>选项：    -n # 行数    -c # 字节数eg:显示前5行    head 1.txt -n 5</code></pre><p>tail命令：查看文本末尾，不加选项默认后10行</p><pre><code>选项：    -n # 行数    -c # 字节数    -f 跟踪文件    -F 跟踪文件名eg：显示最后5行        tail 1.txt -n 5    跟踪文件内容，即时文件被删除，依旧继续跟踪        tail -f 1.txt    跟踪文件名，当文件被删除时，不再跟踪文件内容，并提示用户        tail -F 1.txt(tailf命令 跟踪文件，内容不增长则不继续跟踪，虽然已是等同于tail -f但是效率更高）</code></pre><p><strong>按列抽取文本</strong></p><p>cut命令：将文本切割为列并取出指定列</p><pre><code>选项：    -d分隔符 指明分隔符    -f：取字段        #    取指定的第n个字段        #,# 取离散的指定字段        #-# 取连续的指定字段    -c# 取字节数    --output-delimiter=&lt;&gt;指定输出分隔符 取出信息并指定输出分隔符</code></pre><p><strong>合并文件</strong></p><p>paste命令：合并文本内容 </p><pre><code>用法：    paste file1 file2    paste f1 f2&gt;f3选项：    -s 合成一行    -d     分隔符</code></pre><p><strong>分析文本的工具</strong></p><p>wc命令（word count）：用于统计行数，单词数，字节数</p><pre><code>选项：    -l 行数    -w 单词数    -c 字节数    -m 字符数字典：/usr/share/dict/linux.wordseg：统计字典中的单词数    wc -w /usr/share/dict/linux.words</code></pre><p>sort命令：用于排序，去重，不修改文件原内容（待添加eg）</p><pre><code>选项：    -t  分隔符    -k  取第几列    -n  按数字排序    -r  倒序    -u  去重    -R  随机排序eg：</code></pre><p>uniq命令：合并相邻的重复行 （待添加eg）</p><pre><code>选项：    -c 显示重复的次数    -u 去重复的行数    -d 只要重复的行数eg：</code></pre><p>diff命令：查看文件的不同之处（待分析）</p><pre><code>用法：    diff f1 f2    diff f1 f2 &gt; diff.log 生成补丁选项：    -u 详细    patch命令：补丁        patch f1 diff.log            选项：                -b    备份</code></pre><hr><h1 id="文本处理三剑客之一：grep"><a href="#文本处理三剑客之一：grep" class="headerlink" title="文本处理三剑客之一：grep"></a>文本处理三剑客之一：grep</h1><p>（Global search REgular expression an Print out the line）</p><p>grep命令：文本过滤工具，主要是过滤‘行’ （待添加eg）</p><pre><code>用法：    grep [选项] [模式] file        模式：指的是正则表达式的提出过滤条件选项：    -v 取反    -i 忽略大小写    -n 显示行号    -c 显示有多少行含有关键词    -o 打印关键词    -q 静默        echo $? 显示0或1（多用于编脚本）    -A 搜索结果的后三行    -B 搜索结果的前三行    -C 搜索结果的前三行和后三行    -e 搜索多个关键字    -w 匹配单词    -E 扩展表达式，等同egrep    -F 不支持正则表达式    -f （不理解）</code></pre><p><strong>正则表达式</strong><br>使用特殊字符编写模式，配合grep命令匹配文本中的字符串</p><p>正则表达式有两类：BRE、ERE</p><ol><li><p>基本正则表达式:BRE</p><pre><code>元字符匹配：    .    匹配一个任意字符    []   匹配指定范围    [^]  匹配指定范围外，就是将[]取反    [:alnum:] 字母和数字    [:alpha:] 任意大小写字母    [:lower:] 任意小写字母    [:upper:] 任意大写字母    [:space:] 空格符    [:digit:] 任意数字    [:punct:] 标点符号    [:print:] 可打印字符 （不常用）     [:cntrl:] 不可打印的控制字符（退格、删除）    [:graph:] 可打印的非空白字符匹配次数：    *    匹配*前字符出现任意次包括0次，贪婪模式    \?   匹配字符出现一次或者零次，懒惰模式    \+   匹配字符至少出现一次    \{n\}    匹配字符出现n次    \{n,\}   匹配字符至少出现n次    \{,n\}   匹配字符至多出现n次    \{m,n\}  匹配字符至少m次，至多n次位置锚定    ^  锚定行首&lt;^关键词&gt;    $  锚定行尾&lt;关键词$&gt;    \&gt; 词尾锚定     \&lt; 词首锚定     \&lt;关键词\&gt; 匹配整个单词，等同 &apos;\b关键词\b&apos;    eg：        ^[[:space:]]*$  匹配0次或者任意次空格字符，即空行,等同^$        ^[[:space:]]\+.*$ 匹配至少一个空格字符，用于行首带空格的非空白行分组    \(关键词\) 表示整体    \|  表示或    \1  表示第一个括号，匹配最终结果        \2  表示第二个括号</code></pre></li></ol><ol start="2"><li><p>扩展正则表达式:ERE</p><pre><code>字符匹配:同基本正则,故不再说明匹配次数：    * 匹配前面字符出现任意次    ? 匹配前面字符出现0或1次  #对比基本正则少了&apos;\&apos;    + 匹配前面字符至少出现一次 #对比基本正则少了&apos;\&apos;    {n}   匹配前面字符出现n次 #对比基本正则少了&apos;\&apos;    {n,}  匹配前面字符至少出现n次 #对比基本正则少了&apos;\&apos;    {,n}  匹配前面字符至多出现n次 #对比基本正则少了&apos;\&apos;    {n,m} 匹配前面字符至少出现n次，至多出现m次 #对比基本正则少了&apos;\&apos;位置锚定:同基本正则，故不再说明分组：    () 表示整体 #对比基本正则少了&apos;\&apos;    |  表示或   #对比基本正则少了&apos;\&apos;    再次引用定义的分组结果        \1,\2,\3    eg:</code></pre></li></ol><p>练习：<br>1、利用扩展正则表达式分别表示0-9、10-99、100-199、200-249、250-255  </p><pre><code>答：seq 0 255 &gt; num.txt #创建一个包含了0 - 255的文本  分别表示    0-9: grep -E -w &quot;^[0-9]&quot; num.txt    10-99: grep -E -w &quot;((^[1-9])[0-9])&quot; num.txt  100-199: grep -E -w &quot;^1([0-9]{2})&quot; num.txt  200-249: grep -E -w &quot;^2[0-4][[:digit:]]&quot; num.txt  250-255: grep -E -w &quot;^2[5][0-5]&quot; num.txt  </code></pre><p>2、显示ifconfig命令结果中所有IPv4地址  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：[root@Souler7 ~]<span class="comment"># ifconfig |grep -w -E "inet" |tr -s " "|cut -d" " -f3</span></span><br></pre></td></tr></table></figure><p>3、将此字符串：welcome to magedu linux 中的每个字符去重并排序，重复次数多的排到前面<br>    答：  </p><pre><code class="bash">[root@Souler7 ~]<span class="comment"># echo welcome to magedu linux|grep -Eo "[[:alpha:][:space:]]"|sort|uniq -c|sort -nr</span></code></pre><pre><code>其他编辑器：    gedit 简单的图形编辑器    gvim  vim图形版本</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DAY7&quot;&gt;&lt;a href=&quot;#DAY7&quot; class=&quot;headerlink&quot; title=&quot;DAY7&quot;&gt;&lt;/a&gt;DAY7&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;抽取文本的工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cat命令：用于查看文本  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用户和组的管理以及权限管理</title>
    <link href="http://yoursite.com/2018/07/29/%E7%AC%AC%E4%BA%8C%E5%91%A8-%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%9A%84%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/07/29/第二周-用户和组的管理以及权限管理/</id>
    <published>2018-07-29T12:00:00.000Z</published>
    <updated>2018-07-29T12:17:55.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DAY-6"><a href="#DAY-6" class="headerlink" title="DAY 6"></a>DAY 6</h1><hr><h1 id="linux的安全模型、用户账号以及用户组的介绍"><a href="#linux的安全模型、用户账号以及用户组的介绍" class="headerlink" title="linux的安全模型、用户账号以及用户组的介绍"></a>linux的安全模型、用户账号以及用户组的介绍</h1><p><strong>介绍安全3A</strong></p><pre><code>资源分派：    Authentication：认证    Authorization：授权    Accouting|Audition：审计</code></pre><p><strong>用户user</strong></p><pre><code>令牌token,identityLinux用户：Username/UID管理员：root, 0普通用户：1-60000 自动分配    系统用户：1-499, 1-999（CentOS7）        对守护进程获取资源进行权限分配登录用户：500+, 1000+（CentOS7）    交互式登录</code></pre><p><strong>组group</strong></p><pre><code>Linux组：Groupname/GID管理员组：root, 0普通组：    系统组：1-499, 1-999（CENTOS7）    普通组：500+, 1000+（CENTOS7）</code></pre><p><strong>安全上下文</strong></p><pre><code>Linux安全上下文    运行中的程序：进程(process)    以进程发起者的身份运行：        root: /bin/cat        mage: /bin/cat进程所能够访问资源的权限取决于进程的运行者的身份</code></pre><p><strong>组的类别</strong></p><pre><code>Linux组的类别    用户的主要组(primary group)        用户必须属于一个且只有一个主组组名同用户名，且仅包含一个用户，私有组    用户的附加组(supplementary group)        一个用户可以属于零个或多个辅助组</code></pre><p><strong>关于ps aux</strong></p><pre><code>许多进程在系统启动了就已经自动运行，这些进程属于系统用户，非人使用的。            系统用户使用的shell类型为/bin/nologin，</code></pre><h1 id="用户和组的管理"><a href="#用户和组的管理" class="headerlink" title="用户和组的管理"></a>用户和组的管理</h1><p><strong>关于用户和组的一些关键文件</strong></p><pre><code>/etc/passwd  存放用户信息    eg: xu:x:1000:1000:xu,can,bin,13048973251:/home/xu:/bin/bash    对应格式: 用户名：口令：uid：gid：用户信息注释：家目录：shell类型/etc/shadow  存放用户口令    eg：xu:$6$./CWkeEIb89Q$mmkk1xypAQ1vLXkAQZENBGI8dtXmflwU0npV4UaMhB7BI2hGmHtQFNYvz30BkY7sRaYvyq1tIblxH/lZi4CAO.:17741:0:99999:7:::    对应格式：用户名：口令：口令创建日期：口令最短有效期：密码有效期：密码过期前几天提示：密码过期后的宽限期：账户的有效期：保留未使用        shadow文件格式，shadow中8个冒号隔成9个字段        第一段 用户登录名        第二段 加密口令很长            （！！表示加锁）             sha512加密算法512位 $1:md5加密算法（已被破解）            $6:sha512加密算法（！！表示加锁）            算法的后面会加$（salt）$ 称为salt盐            salt盐 不一样            王小云：破解md5，sha1            /etc/login.defs 用户口令相关文件，存放了默认的加密算法            更改算法：            authconfig --passalgo=sha256 --update        第三段            上一次口令更改时间天数（以1970位参考，）        第四段            更换密码所需时间间隔（例如，3，则表示每更换一次密码后，想再次更改密码需要等待3天才能更换密码）        第五段            密码有效期        第六段            密码过期的前几天会提示你更换密码        第七段            密码过期后的宽限期        第八段            账户的有效期            chage &lt;用户名&gt;             可以更改指定用户的shadow中第3段到第8段的信息        第九段            保留未使用/etc/group   存放组信息    eg：xu:x:1000:xu    对应格式：组名：口令：组id：该组作为附加组时的成员/etc/gshadow 存放组口令    eg：xu:$6$V63Bs/1moqF/$GqgjT3Nj8bBSW4xxF0IAn7MCdf2ClS8fZLPOwSJ5n8M8X.MXKgY1GoTNFbTyw8da0kN5wtKZrnC6bSvW3YMf//::    对应格式：组名：口令：组管理员列表：以当前组为附加组的用户列表/etc/default/useradd    该文件存放了用户口令相关文件，该文件中定义了创建新用户的默认配置        [root@Souler7 ~]# useradd -D        GROUP=100        HOME=/home  #默认家目录创建路径        INACTIVE=-1  #口令过期后，默认不锁定        EXPIRE=   #有效期        SHELL=/bin/bash #默认shell        SKEL=/etc/skel  #新建家目录的模板，都是隐藏文件        CREATE_MAIL_SPOOL=yes  #默认创建邮箱    列出/etc/default/useradd的内容        useradd -D        useradd -D=cat /etc/default/useradd/etc/login.defs    该文件最后两行配置了了口令的加密算法    eg：# Use SHA512 to encrypt password.        ENCRYPT_METHOD SHA512/etc/skel/ -a    该文件是存放了家目录的模板文件        [root@Souler7 ~]# ll -a /etc/skel/        total 24        drwxr-xr-x.   3 root root   78 Apr 11 12:59 .        drwxr-xr-x. 139 root root 8192 Jul 29 16:05 ..        -rw-r--r--.   1 root root   18 Apr 11 08:53 .bash_logout        -rw-r--r--.   1 root root  193 Apr 11 08:53 .bash_profile        -rw-r--r--.   1 root root  231 Apr 11 08:53 .bashrc        drwxr-xr-x.   4 root root   39 Jul 18 14:47 .mozilla</code></pre><p><strong>关于getent</strong></p><pre><code>列出/etc/passwd的内容    getent passwd    getent passwd=cat /etc/passwd      getent passwd &lt;username&gt; 查看指定用户的passwd信息列出/etc/shadow的内容    getent shadow    getent shadow=cat /etc/shadow    getent shadow &lt;username&gt; 查看指定用户的shadow信息列出/etc/group的内容    getent group    getent group=cat /etc/group    getent group &lt;username&gt; 查看指定组的group信息列出/etc/gshadow的内容    getent gshadow    getent gshadow=cat /etc/gshadow    getent gshadow &lt;username&gt; 查看指定的gshadow信息</code></pre><p><strong>关于用户的创建和管理</strong><br>（常用与给系统服务创建账号）</p><pre><code>useradd命令： 用于创建用户    useradd = adduser    useradd -D =cat /etc/default/useradd    （rpm -q -scripts postfix 查看useradd的常用格式）    选项：        useradd -d &lt;路径&gt;      指定家目录        useradd -M             不创建家目录        useradd -g &lt;groupname&gt; 指定主组        useradd -G &lt;groupname&gt; 附加组        useradd -c &quot;注释&quot;       用户的注释信息        useradd -s shell       指定使用shell类型，不指定默认使用/bin/bash        useradd -r             创建系统，创建目录默认不创建家目录        useradd -u &lt;uid&gt;       指定uid        useradd -N             自动加入users组        useradd -o &lt;uid&gt;       避免同id冲突usermod命令：用于修改用户属性（不常用）    选项：        usermod -G 组 用户     增加附加组，且覆盖已有附加组        usermod -aG 组 用户    追加附加组        usermod -G &quot;&quot; 用户     清除所有附加组        usermod -L 用户        给用户加锁        usermod -U 用户        给用户解锁userdel命令：用于删除用户    userdel &lt;用户&gt;    删除用户    选项：        userdel -r &lt;用户&gt; 删除用户及其家目录用户相关的其他命令    chfn命令（修改用户的描述信息）        用法：        chfn &lt;用户&gt;修改指定用户描述信息，不指定用户名则默认修改当前用户的描述信息    finger命令（查看用户的描述信息，需自行安装，否则无效）        用法：        finger &lt;用户&gt; 查看指定用户描述信息    chsh命令（修改用户shell类型）        用法：        chsh -s shell &lt;用户&gt; 更改用户的shell类型</code></pre><p><strong>关于用户口令</strong></p><pre><code>passwd命令：用与更改用户口令    选项：                    passwd -l &lt;用户&gt; 双重锁               类似：usermod -L &lt;用户&gt; 单锁        passwd -u &lt;用户&gt; 解双重锁             类似：usermod -U &lt;用户&gt; 解单锁        passwd -d &lt;用户&gt; 清空用户口令        passwd -e &lt;用户&gt; 强制下次登录，提示用户改口令（常用）        passwd -f &lt;用户&gt; 强制操作批量改口令（多用于写程序时的命令）    echo 密码 | passwd --stdin 用户名（常用）chage命令（更改shadow）    选项：        chage &lt;用户&gt;    交互式更改指定用户密码策略        chage -l &lt;用户&gt; 查看指定用户密码策略        chage -d 0 &lt;用户&gt; 指定用户口令立即过期</code></pre><p><strong>关于用户组的创建和管理</strong></p><pre><code>groupadd命令：用于创建组    选项：        groupadd -g &lt;gid&gt; &lt;groupname&gt; 创建指定id号的用户组            系统用户id默认设置            centos6&lt;500            centos7&lt;1000        groupadd -r &lt;groupname&gt; 创建指定系统用户组groupmod命令：用于修改组属性    选项：        groupmod -n &lt;new_name&gt; &lt;groupname&gt; 更改用户组名        groupmod -g &lt;new_id&gt; &lt;groupname&gt;   更改用户组idgroupdel命令：用于删除组    groupdel &lt;groupname&gt;  删除用户组    选项：        groupdel -R    注意：主组不能删，附加组可以groupmems命令：用于更改和查看组成员选项：    groupmems -g &lt;group&gt;   更改为指定组(只有root)配合-g使用的参数：    groupmems -g &lt;group&gt; -a &lt;user&gt;  指定用户加入组    groupmems -g &lt;group&gt; -d &lt;user&gt;  从组中删除用户    groupmems -g &lt;group&gt; -p         从组中清除所有成员    groupmems -g &lt;group&gt; -l         显示组成员列表groups命令：用于查看组成员    groups[OPTION].[USERNAME]... 查看用户所属组列表</code></pre><p><strong>关于组密码</strong></p><pre><code>gpasswd命令：用于更改组密码     gpasswd &lt;group&gt; 更改组的密码    选项：        gpasswd -a &lt;用户&gt; &lt;组&gt; ，将用户添加至指定组中        gpasswd -d &lt;用户&gt; &lt;组&gt; ，从指定组中移除用户</code></pre><p><strong>查看用户相关的id信息以及切换用户</strong></p><pre><code>id命令：用于判断用户的存在性    id &lt;用户&gt; 显示uid，gid，属组和附加组    uid=0(root) gid=0(root) groups=0(root)    选项：        id -n &lt;用户&gt; 显示名字        id -g &lt;用户&gt; 显示组id        id -u &lt;用户&gt; 显示uid        id -G &lt;用户&gt; 显示附加组id，全部组su命令（switch user）：用于切换账号，普通用户需要口令    su &lt;用户&gt; 切换用户，环境没变    su - &lt;用户&gt;  相当于重新登录，环境改变    su - &lt;用户&gt; -c &quot;command&quot; 切换用户，且执行命令后退出     尽量不要多次切换</code></pre><p><strong>检查</strong></p><pre><code>pwck 检查用户grpck 检查组</code></pre><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><pre><code>给用户添加附加组的办法:    usermod -aG &lt;组&gt; &lt;用户&gt;    gpasswd -a &lt;用户&gt; &lt;组&gt;    groupmems -a &lt;用户&gt; -g &lt;组&gt;解锁：    usermod -L &lt;用户&gt; 单锁    usermod -U &lt;用户&gt; 解单锁    passwd -l &lt;用户&gt; 双重锁    passwd -u &lt;用户&gt; 解双重锁更变用户属组:    usermod -g &lt;组&gt; &lt;用户&gt;临时切换用户属组:    newgrp &lt;组&gt; 临时加入且更换主组更改附加组：    手动更改文件：        更改附加组时，group与gshadow最后一个字段必须一模一样    使用命令更改附加组    usermod -G &lt;组&gt; &lt;用户名&gt;       给用户添加附加组    groupmems -g &lt;组&gt; -a &lt;用户名&gt;  给用户添加附加组    gpasswd -a &lt;用户名&gt; &lt;组&gt;       给用户添加附加组newusers（作用待实验）chpasswd命令：更改密码，用法如下：用户名：密码    [root@Souler7 ~]# chpasswd      xu:123456</code></pre><hr><h1 id="文件权限：读read、写wirte、执行excute，简称rwx"><a href="#文件权限：读read、写wirte、执行excute，简称rwx" class="headerlink" title="文件权限：读read、写wirte、执行excute，简称rwx"></a>文件权限：读read、写wirte、执行excute，简称rwx</h1><p><strong>文件属性：</strong></p><pre><code>eg:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># ls -i xcb.log</span></span><br><span class="line">-rw-r--r-- 1 root root 100 Jul 18 15:08 xcb.log</span><br><span class="line"></span><br><span class="line">对应关系如下：</span><br><span class="line">-rw-r--r--   --&gt;权限</span><br><span class="line">1            --&gt;引用计数</span><br><span class="line">root         --&gt;所属组</span><br><span class="line">root         --&gt;所有者</span><br><span class="line">100          --&gt;文件大小</span><br><span class="line">Jul 18 15:08 --&gt;创建时间</span><br><span class="line">xcb.log      --&gt;文件名</span><br></pre></td></tr></table></figure></code></pre><p><strong>权限管理：</strong></p><pre><code>rwxrwxrwx：    左三位：定义user的权限    中三位：定义group的权限    右三位：定义other的权限进程安全上下文：    进程对文件的访问权限应用模型：        进程的属主与文件的属主是否相同，若果相同，则应用owner权限        否则，检查进程的属主是否属于文件的属组，如果是，则应用group权限        否则，就只能应用other权限权限：       r：readable 可读       w：writable 可写       x：excutable 可执行        文件权限： （一般情况下，普通文件不该拥有x权限）            r：可获取文件的数据            w：可修改文件的数据            x：可将此文件运行为进程        目录权限：            r：可以使用ls命令获取其下的所有文件列表            w：可修改此目录下的文件列表；创建或删除文件            x：可cd至目录中，且可使用ll来获取所有文件的详细属性信息        mode：rwxrwxrwx        ownership：user，group权限组合机制：        --- 000 0        --x 001 1        -w- 010 2        -wx 011 3        r-- 100 4        r-x 101 5        rw- 110 6        rwx 111 7权限管理命令：        chmod命令三种用法            chmod [OPTION]... MODE[,MODE]... FILE...            chmod [OPTION]... OCTAL-MODE FILE...            chmod [OPTION]... --reference=RFILE FILE...            三类用户：                u：所有者user                g：所属组group                o：其他人other                a：所有人            （1）chmod [OPTION]... MODE[,MODE]... FILE...                MODE表示法：                    赋权表示法：直接操作一类用户的所有权限位rwx                        u=                        g=                        o=                         a=                    授权表示法：直接操作一类用户的一个权限位r,w,x                        u+,u-                        g+,g-                        o+,o-                        a+,a-                  （2）chmod [OPTION]... OCTAL-MODE FILE...                八进制表示法：                    eg：chmod 777 文件名                    777表示 rwxrwxrwx            （3）chmod [OPTION]... --reference=RFILE FILE...                引用表示法：             选项：             -R，递归修改从属关系管理命令：chown，chgrp        chown命令：            chown [OPTION]... [OWNER][:[GROUP]] FILE...               chown [OPTION]... --reference=RFILE FILE...               选项：                   -R 递归修改           chgrp命令：            chown [OPTION]... [OWNER][:[GROUP]] FILE...               chown [OPTION]... --reference=RFILE FILE...umask：文件的权限反向掩码，遮罩码           文件：rw-rw-rw-               666-umask 默认权限           目录：rwxrwxrwx               777-umask 默认权限        注意：之所以文件用666去减，是因为文件默认不得拥有执行权限，如果减得的结果中有执行权限，则需要将其加1               666-022=644               777-022=756           umask命令：               umask：查看当前umask               umask MASK:设置umask           注意：此类设定仅对当前shell进程有效 特殊权限：SUID、SGID、Stick         SUID 权限表示为：s             作用在可执行、二进制程序             当用户运行时继承此程序所有者的权限        SGID 权限表示为：s            文件：作用在可执行、二进制程序                继承此程序所属组的权限            文件夹：作用于目录上                当用户在目录新建文件时继承目录所属组        Sticky 权限表示为：t            作用于目录上，目录中的文件只能被所有者删除限制root权限    chattr命令        chattr +i 加锁，禁止删除,改名，更改      chattr -i 解除+i      chattr +a 可追加内容，不可删除      chattr -a 解除 +a      chattr +A 禁用读时间的功能      chattr -A 解除 -A      lsattr      查看特殊属性访问控制列表：ACL，自定义权限    setfacl命令        setfacl -m u：wang：rw f1 自定义用户权限        setfacl -m g：wang：rw wang 自定义组权限        getfacl 文件 查看文件的acl权限        setfacl -x wang f1 删除文件中用户wang的acl权限        setfacl -b     清除文件中所有acl权限        setfacl -R  目录  递归acl        setfacl -M  调用文本，批量创建权限        setfacl -X  调用文本批量删除权限        --set选项(待补充)    mask限高杆        setfacl -m mask::r f1 文件中的acl权限最高只有r--        setfacl -m mask:rw f1 文件中的acl权限最高只有rw-    注意：在设定了acl自定义权限之后        chmod g= file 修改的是mask的权限，而不是group权限    acl生效顺序：所有者、自定义用户、自定义组、其他人     FAT分区不支持设置权限</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DAY-6&quot;&gt;&lt;a href=&quot;#DAY-6&quot; class=&quot;headerlink&quot; title=&quot;DAY 6&quot;&gt;&lt;/a&gt;DAY 6&lt;/h1&gt;&lt;hr&gt;
&lt;h1 id=&quot;linux的安全模型、用户账号以及用户组的介绍&quot;&gt;&lt;a href=&quot;#linux的安全模型、用户
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>命令、索引节点、标准I/O和管道</title>
    <link href="http://yoursite.com/2018/07/26/%E7%AC%AC%E4%BA%8C%E5%91%A8-%E5%91%BD%E4%BB%A4%E3%80%81%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E3%80%81%E6%A0%87%E5%87%86IO%E5%92%8C%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2018/07/26/第二周-命令、索引节点、标准IO和管道/</id>
    <published>2018-07-26T12:00:00.000Z</published>
    <updated>2018-07-26T12:42:58.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DAY-4"><a href="#DAY-4" class="headerlink" title="DAY 4"></a>DAY 4</h1><hr><p><strong>内容概括：个人梳理命令、索引节点、标准I/O和管道相关知识</strong></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><pre><code>mv        单个文件重命名与移动rename    多个文件重命名rm        删除shred     覆盖式删除tree      目录树dd        创建指定大小的文件mkdir     创建空目录redir     删除空目录file      判断文件类型tr        标准输入和标准输出tee       配合管道使用|         管道</code></pre><h1 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h1><pre><code>inode（index node）硬链软链接关于磁盘存储内部工作原理inode 表结构的直接指针与间接指针</code></pre><h1 id="标准I-O和管道"><a href="#标准I-O和管道" class="headerlink" title="标准I/O和管道"></a>标准I/O和管道</h1><pre><code>关于重定向的语法…多行STDIN&quot;&lt;&lt;终止词&quot;</code></pre><hr><h1 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h1><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>mv &lt;选项&gt; &lt;文件名&gt; &lt;文件名&gt;<br>用于移动覆盖文件或者给文件改名 （仅能单个改名）<br>常用选项：<br>-i 覆盖前询问<br>-f 强制覆盖</p><p>eg：改名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ls</span></span><br><span class="line">dir1 f1 f2 f3 f4</span><br><span class="line">[root@Souler6 app]<span class="comment"># mv f2 f5 #将f2改名为f5</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ls</span></span><br><span class="line">dir1 f1 f3 f4 f5</span><br></pre></td></tr></table></figure></p><p>eg：移动且改名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r–r–. 2 root root 0 Jul 26 09:35 f5 <span class="comment">#注意创建时间</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f5</span><br><span class="line">[root@Souler6 app]<span class="comment"># mv f5 dir1/f6 #移动并改名</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f5</span><br><span class="line">-rw-r–r–. 2 root root 0 Jul 26 09:35 f6 <span class="comment">#f5移动且改名的文件f6，创建时间与f5相同</span></span><br></pre></td></tr></table></figure></p><p>eg：移动改名且覆盖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># touch f5</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 f5 <span class="comment">#注意创建时间</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 2 root root 0 Jul 26 09:35 f6 <span class="comment">#注意创建时间</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># mv f5 dir1/f6</span></span><br><span class="line">mv: overwrite `dir1/f6’? y <span class="comment">##文件已存在询问是否覆盖，加-f 可以强制覆盖</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 f6 <span class="comment">#改名且覆盖后，时间也变了</span></span><br></pre></td></tr></table></figure></p><h2 id="rename命令"><a href="#rename命令" class="headerlink" title="rename命令"></a>rename命令</h2><p>批量改名字<br>eg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f2</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f3</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 f6</span><br><span class="line">[root@Souler6 dir1]<span class="comment"># rename ‘f’ ‘xcb’ f*</span></span><br><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb2</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb3</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br></pre></td></tr></table></figure></p><h2 id="rm命令-可还原的删除"><a href="#rm命令-可还原的删除" class="headerlink" title="rm命令 可还原的删除"></a>rm命令 可还原的删除</h2><p>rm &lt;选项&gt;&lt;文件名&gt;..<br>常用选项：<br>-i 交互式，删除前询问<br>-f 强制性，不询问</p><p>eg：交互式删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb2</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb3</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br><span class="line">[root@Souler6 dir1]<span class="comment"># rm xcb1 xcb2 xcb3</span></span><br><span class="line">rm: remove regular empty file xcb1? y </span><br><span class="line">rm: remove regular empty file xcb2? y</span><br><span class="line">rm: remove regular empty file xcb3? y</span><br><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br></pre></td></tr></table></figure></p><p>eg：强制删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br><span class="line">[root@Souler6 dir1]<span class="comment"># rm -f xcb4</span></span><br><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br></pre></td></tr></table></figure></p><p>eg：删除目录 需要-r递归删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 11:15 dir1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 09:35 f1</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Jul 26 09:37 f3 -&gt; /app/f1</span><br><span class="line">lrwxrwxrwx. 1 root root 9 Jul 26 09:39 f4 -&gt; ../app/f1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:01 f6</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br><span class="line">[root@Souler6 app]<span class="comment"># rm -rf dir1/</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 09:35 f1</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Jul 26 09:37 f3 -&gt; /app/f1</span><br><span class="line">lrwxrwxrwx. 1 root root 9 Jul 26 09:39 f4 -&gt; ../app/f1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:01 ll f6</span><br></pre></td></tr></table></figure></p><p>利用alias命令与mv，创建一个垃圾箱trash<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> rm=<span class="string">"mv -t /trash"</span>  <span class="comment">#利用-t选项 调换前后顺序</span></span><br></pre></td></tr></table></figure></p><p>创建一个名为bigfile，大小为100M的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=bigfile bs=1M count=100</span><br></pre></td></tr></table></figure></p><p>删除大文件，急速为系统腾出空间，使用重定向原理&gt;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ &gt; bigfile</span><br><span class="line">$ rm -rf bigfile</span><br></pre></td></tr></table></figure></p><p>未知命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof | grep deleted</span><br></pre></td></tr></table></figure></p><p>提问：删除文件的底层原理?</p><h2 id="shred命令-相对比较安全的删除"><a href="#shred命令-相对比较安全的删除" class="headerlink" title="shred命令 相对比较安全的删除"></a>shred命令 相对比较安全的删除</h2><p>shred -zv -n5 &lt;文件名&gt;</p><h2 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h2><p>tree &lt;选项&gt;&lt;目录名&gt;</p><pre><code>查看目录的树tree -d 只看目录树tree -L n 查看层数，n为层数tree -P 配合通配符使用*</code></pre><h2 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h2><pre><code>$ dd if=/dev/zero of=bigfile bs=1M count=100创建一个名为bigfile，大小为100M的文件。</code></pre><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>mkdir -p 自动创建不存在的子目录<br>创建空目录<br>eg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 ~]<span class="comment"># mkdir /app/dir1/&#123;x/&#123;a,b&#125;,y/&#123;c,d&#125;&#125;</span></span><br><span class="line">mkdir: cannot create directory /app/dir1/x/a: No such file or directory mkdir: cannot create directory/app/dir1/x/b’: No such file or directory</span><br><span class="line">mkdir: cannot create directory /app/dir1/y/c: No such file or directory mkdir: cannot create directory/app/dir1/y/d’: No such file or directory</span><br><span class="line"><span class="comment">#报错原因，因为没加-p选项，不会自动创建不存在的子目录，我们可以尝试加参数后在运行</span></span><br><span class="line">[root@Souler6 ~]<span class="comment"># mkdir -pv /app/dir1/&#123;x/&#123;a,b&#125;,y/&#123;c,d&#125;&#125;</span></span><br><span class="line">mkdir: created directory /app/dir1 mkdir: created directory/app/dir1/x</span><br><span class="line">mkdir: created directory /app/dir1/x/a mkdir: created directory/app/dir1/x/b</span><br><span class="line">mkdir: created directory /app/dir1/y mkdir: created directory/app/dir1/y/c</span><br><span class="line">mkdir: created directory /app/dir1/y/d</span><br><span class="line"><span class="comment">#加了-p选项就创建成功了，-v是显示创建过程</span></span><br></pre></td></tr></table></figure></p><pre><code>[root@Souler6 ~]# tree /app/dir1//app/dir1/├── x│   ├── a│   └── b└── y    ├── c    └── d6 directories, 0 files</code></pre><p>用目录树显示，想使用tree需自己安装。。</p><h2 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h2><p>rmdir -p 自动删除上一级空目录<br>只能删空目录<br>eg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># mkdir -pv /app/dir1/dir2/&#123;/dir3,/dir4/dir5/dir6&#125;</span></span><br><span class="line">mkdir: created directory /app/dir1 mkdir: created directory/app/dir1/dir2</span><br><span class="line">mkdir: created directory /app/dir1/dir2//dir3 mkdir: created directory/app/dir1/dir2//dir4</span><br><span class="line">mkdir: created directory /app/dir1/dir2//dir4/dir5 mkdir: created directory/app/dir1/dir2//dir4/dir5/dir6</span><br></pre></td></tr></table></figure></p><pre><code>[root@Souler6 app]# tree /app//app/└── dir1└── dir2    ├── dir3    └── dir4 有树目录可看出，dir2非空目录        └── dir5            └── dir6        6 directories, 0 files</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># rmdir -pv /app/dir1/dir2/dir4/dir5/dir6/</span></span><br><span class="line">rmdir: removing directory, /app/dir1/dir2/dir4/dir5/dir6/ rmdir: removing directory,/app/dir1/dir2/dir4/dir5</span><br><span class="line">rmdir: removing directory, /app/dir1/dir2/dir4 rmdir: removing directory,/app/dir1/dir2</span><br><span class="line">rmdir: failed to remove directory /app/dir1/dir2: Directory not empty <span class="comment">#删到过程能够看到报错了，由于目录dir2非空目录，停止删除</span></span><br></pre></td></tr></table></figure><pre><code>[root@Souler6 app]# tree /app//app/└── dir1    └── dir2        └── dir3 #对比上面的树目录中可以看到dir2目录下空的子目录已被清理3 directories, 0 files</code></pre><p>故，可印证rmdir只能删空目录，-p是将父目录为空的目录删除，逆向递归删除</p><h1 id="索引节点-1"><a href="#索引节点-1" class="headerlink" title="索引节点"></a>索引节点</h1><p>linux底层工作原理</p><h2 id="inode（index-node）"><a href="#inode（index-node）" class="headerlink" title="inode（index node）"></a>inode（index node）</h2><p>节点编号简介</p><pre><code>inode number ,inode编号，是每个文件的唯一性，inode table 节点表 属于元数据节点编号，链接数（matadata）date block 数据块 属于数据1M、1G (data)</code></pre><p>即时节点编号也有可能出现出现节点编号相同的情况<br>eg:</p><pre><code>分区所在挂载的目录节点编号相同在同一个分区中，节点编号相同即为同一个文件（涉及硬链接）</code></pre><p>在不同分区中，即时节点编号相同也不是同一文件，每个分区中的节点编号不互通（分区挂载点除外）<br>节点编号是有限的，可回收利用<br>eg:</p><pre><code>f1的节点编号为52，删除f1后又创建f2的节点编号为52原因：由于f1被删除后，节点编号52空缺，之后会被分配给新创建的文件f2使用</code></pre><p>查看节点编号</p><pre><code>$ls -l -i</code></pre><p>查看节点编号的使用情况</p><pre><code>$ df -i</code></pre><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>独立，只能在同一个分区，不能跨设备，不能跨分区，局限性。<br>且多个硬链接文件所占的空间=单个源文件。可以理解为每一个硬链接都是给文件起了个新名字，所占用的资源不增加不减少。<br>文件夹不支持创建硬链接，节点编号不增长。</p><p>eg：</p><pre><code>[root@Souler6 ~]# touch /app/f1[root@Souler6 ~]# ll -i /app/total 011 -rw-r–r–. 1 root root 0 Jul 26 09:35 f1 ##11是节点编号，2是硬链接[root@Souler6 ~]# ln /app/f1 /app/f2[root@Souler6 ~]# ll -i /app/total 011 -rw-r–r–. 2 root root 145 Jul 26 09:35 f111 -rw-r–r–. 2 root root 145 Jul 26 09:35 f2#从上面的信息可以获取到 f1与f2是硬链接的关系，其节点编号相同，都为11，这两个文件是等同的，且所占空间为145个字节，而不是290个字节。#将f1删除，f2可以运行，不受影响。#将f2删除，f1可以运行，不受影响。#可以理解为，删除硬链接仅仅是将文件多个名字中去掉一个名字#但若是将f1，f2同时删除，此文件将不存在，且节点编号空缺出来，等待分配给新的文件</code></pre><p>创建硬链接</p><pre><code>$ ln f1 f2</code></pre><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>仅仅只是一个快捷方式，每个软链接会占用一个节点编号，每个快捷方式所占空间与路径有关<br>可跨分区，依赖性：假如源文件被删除，则软链接失效。</p><p>同分区使用：</p><pre><code>[root@Souler6 ~]# ln -s /app/f1 /app/f3 （使用绝对路径）[root@Souler6 ~]# ln -s ../app/f1 /app/f4 （使用相对路径）[root@Souler6 ~]# ll -i /app/total 011 -rw-r–r–. 2 root root 145 Jul 26 09:35 f111 -rw-r–r–. 2 root root 145 Jul 26 09:35 f212 lrwxrwxrwx. 1 root root 7 Jul 26 09:37 f3 -&gt; /app/f113 lrwxrwxrwx. 1 root root 9 Jul 26 09:39 f4 -&gt; ../app/f1f3与f4都是f1的软链接，相当于f1的快捷方式，即时这样也不是同一个文件，可以看到f3与f4的节点编号不同，各自占用一个独立的节点编号。以及可以看到f3指向的路径有7个字符占用7个字节，f4指向的路径有9个字符占用了9个字节，因此可以得出每个快捷方式所占空间与源文件无关，而是与路径的字符长度有关。</code></pre><p>跨分区使用</p><pre><code>[root@Souler6 ~]# ln -s ../app/f1 f4[root@Souler6 ~]# ll -i /root/total 104134418 -rw——-. 1 root root 1456 Jul 17 11:08 anaconda-ks.cfg153481 drwxr-xr-x. 2 root root 4096 Jul 26 08:57 Desktop153485 drwxr-xr-x. 2 root root 4096 Jul 17 11:18 Documents153482 drwxr-xr-x. 2 root root 4096 Jul 17 11:18 Downloads153603 -rw-r–r–. 1 root root 0 Jul 26 09:34 f1153615 lrwxrwxrwx. 1 root root 9 Jul 26 09:38 f4 -&gt; ../app/f1可以看到快捷方式f4使用的节点编号，跟上面的f4是不一样的，差别很大跨区创建所生成的软链接会按当前分区剩余的节点编号去分配节点。可以看到/分区下 快捷方式f4的节点编号为153615而分区/app下，快捷方式f4的节点编号为13。多用相对路径，每个软链接独自分配一个不同的节点编号</code></pre><p>/dev/cdrom-&gt; sr0 光盘的快捷方式<br>创建软链接</p><pre><code>ln -s f1 f2，</code></pre><p>多用相对路径</p><h2 id="分析-mv-f1-f2-与-ln-s-f1-f2-的底层原理"><a href="#分析-mv-f1-f2-与-ln-s-f1-f2-的底层原理" class="headerlink" title="分析 mv f1 f2 与 ln -s f1 f2 的底层原理"></a>分析 mv f1 f2 与 ln -s f1 f2 的底层原理</h2><p><strong>mv f1 f2</strong><br>同分区中，改名，或者移动，并不会改变节点编号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 mv]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">131074 -rw-r–r–. 1 root root 0 Jul 26 12:25 f1 <span class="comment">#改名前</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># mv f1 ../f2 #移动f1并改名为f2</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../</span></span><br><span class="line">total 8</span><br><span class="line">131074 -rw-r–r–. 1 root root 0 Jul 26 12:25 f2 <span class="comment">#改名后，文件数据没任何变化</span></span><br><span class="line">524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln</span><br><span class="line">131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:29 mv</span><br><span class="line">同分区中，改名且覆盖</span><br><span class="line">[root@Souler6 mv]<span class="comment"># touch f22 #创建一个新的文件f22</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">131075 -rw-r–r–. 1 root root 0 Jul 26 12:31 f22 <span class="comment">#f22节点编号131075</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../</span></span><br><span class="line">total 8</span><br><span class="line">131074 -rw-r–r–. 1 root root 0 Jul 26 12:25 f2 <span class="comment">#f2节点编号为131074</span></span><br><span class="line">524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln</span><br><span class="line">131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:31 mv</span><br><span class="line">[root@Souler6 mv]<span class="comment"># mv f22 ../f2</span></span><br><span class="line">mv: overwrite `../f2’? y <span class="comment">#因已存在f2文件，故改名后覆盖</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../</span></span><br><span class="line">total 8</span><br><span class="line">131075 -rw-r–r–. 1 root root 0 Jul 26 12:31 f2 <span class="comment">#f2节点编号为131075，变了</span></span><br><span class="line">524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln</span><br><span class="line">131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:31 mv</span><br><span class="line">跨分区移动</span><br><span class="line">[root@Souler6 ~]<span class="comment"># ll -i f1</span></span><br><span class="line">153603 -rw-r–r–. 1 root root 0 Jul 26 09:34 f1</span><br><span class="line">[root@Souler6 ~]<span class="comment"># mv f1 /boot</span></span><br><span class="line">[root@Souler6 ~]<span class="comment"># ll -i /boot/f1</span></span><br><span class="line">38 -rw-r–r–. 1 root root 0 Jul 26 09:34 /boot/f1 <span class="comment">#注意，节点编号改变了</span></span><br></pre></td></tr></table></figure></p><p>根据以上分析可以得出<br>同分区中<br>mv改名后，文件数据没任何变化<br>mv移动文件时，节点编号不会发生改变<br>mv覆盖文件时，会把节点编号一起覆盖掉<br>跨分区的移动<br>mv移动后，节点编号会发生改变</p><p><strong>ln -s f1 f2</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../ln/</span></span><br><span class="line">total 0</span><br><span class="line">524290 -rw-r–r–. 1 root root 0 Jul 26 12:45 f1 <span class="comment">#源文件的节点编号为524290</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ln -s ../../app/ln/f1 /app/mv/f3 #可以理解成将相对路径下f1文件的快捷方式发送到绝对路径并起名为f3</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../mv/</span></span><br><span class="line">total 0</span><br><span class="line">131076 lrwxrwxrwx. 1 root root 10 Jul 26 13:01 f3 -&gt; ../../app/ln/f1<span class="comment">#快捷方式的节点为131076</span></span><br><span class="line"></span><br><span class="line">[root@Souler6 mv]<span class="comment"># tree /app/</span></span><br><span class="line">/app/</span><br><span class="line">├── f2</span><br><span class="line">├── ln</span><br><span class="line">│   └── f1</span><br><span class="line">└── mv</span><br><span class="line">    └── f3 -&gt; /app/ln/f1</span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure></p><p>根据以上分析可以得出，<br>创建快捷方式需指定相对路径，再指定存放的绝对路径<br>快捷方式也会被单独分配一个节点，且所占大小与路径字符有关<br>创建同分区中和跨分区的软链接<br>ln -s 软链接都会被分配一个新的节点编号</p><p><strong>xargs touch 突破创建文件个数的限制</strong></p><pre><code>[root@Souler6 ~]# echo f{1..100000} | xargs touch</code></pre><p>##inode 表结构的直接指针与间接指针<br>直接指针</p><pre><code>12共有个直接指针，每个指针指向一个大小为4k的数据块，最多存储48k，但存储的数据超过48k则需要用到间接指针来存储更大的数据</code></pre><p>间接指针</p><pre><code>一个间接指针占4个字节byte一个数据块占4k，4k=41024byte所以1个数据块中有1024个间接指针</code></pre><p>一级间接指针 4MB</p><pre><code>间接指针指向下一个文件块的指针，文件块的大小为4k，每个指针占4个byte，故可以理解为该文件块下有1024个指针，1024个指针分别指向1024个4k的数据块，故可存放文件的大小为10244k=4MB</code></pre><p>二级间接指针 4GB</p><pre><code>间接指针指向下一个文件块的指针，文件块的大小为4k，每个指针占4个byte，故可以理解为该文件块下有1024个指针，1024个指针分别指向1024个文件块，这种又衍生除了10241024个指针，这10241024个指针再次指向数据块，每个数据块大小为4k，故可存放的文件大小为102410244k=4GB</code></pre><p>三级间接指针 4TB</p><pre><code>与二级指针同理，故可存放的文件大小为102410241024*4k=4TB</code></pre><p><strong>file命令</strong><br>在linux中，不注重后缀，一般情况下更改后缀不影响程序的运行<br>file [选项] &lt;文件名&gt;</p><p>也可以通过hexdump查看开头作出判断</p><pre><code>hexdump -C -n 100 &lt;文件名&gt;</code></pre><h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>input：输入数据 ouput：输出数据<br>文件描述符</p><pre><code>打开的文件都有一个fd：file descriptor(文件描述符)进程运行会产生文件描述符自动生成的文件描述符存储在/proc/PID/fd中，PID是一个数字（进程编号）</code></pre><p>查看进程</p><pre><code>$ ps aux</code></pre><p>linux中给程序提供的三种I/O设备</p><pre><code>标准输入 STDIN 0 默认位置：键盘标准输出 STDOUT 1 默认位置：当前终端窗口标准错误 STDERR 2 默认位置：当前终端窗口</code></pre><p><strong>I/O重定向：改变默认位置</strong></p><p>把输出和错误重定向到文件</p><p>大致讲一下标准输入、标准输出、标准错误的概念<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll /app/ /error/ # 一般我们在键盘中敲入命令，这就是标准输入STDIN（0）</span></span><br><span class="line">ls: cannot access /error/: No such file or directory <span class="comment"># 执行命令后由于/error文件不存在，故，报错，这种就是标准错误STDERR（2）标准错误会默认打印在当前终端窗口</span></span><br><span class="line">/app/: <span class="comment">#/app存在，故，这是一个标准输出STDOUT（1）标准输出会默认打印在当前终端窗口</span></span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:12 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:12 d2</span><br></pre></td></tr></table></figure></p><p>下面举例子详细说明： ‘&gt;’可以用于重定向, ‘&gt;&gt;’ 用于重定向的追加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ls</span></span><br><span class="line">d1 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll /app/ /error/ &gt; 1.txt #标准输入，但是’&gt;’已经将标准输出进行了重定向，故屏幕不打印标准输出，只打印了标准错误</span></span><br><span class="line">ls: cannot access /error/: No such file or directory</span><br><span class="line">[root@Souler6 app]<span class="comment"># cat 1.txt # 查看1.txt中是不是真的打印了标准输出</span></span><br><span class="line">/app/: <span class="comment">#这是本来应该被打印在屏幕上的标准输出，但’&gt;’对其进行了重定向</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:33 1.txt <span class="comment">#这是创建用于存放标准输出的文件，因为ll在打印前就对1.txt进行了列出命令，初始大小为0，实际上它的大小已经不是0了，我们可以理解为是 ‘ll命令的速度’比‘重定向打印的速度快’。</span></span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll #查看1.txt的大小</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r–r–. 1 root root 153 Jul 26 10:33 1.txt <span class="comment">#可以看到占用了153个字节</span></span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll /app/ /error/ &gt;&gt; 1.txt #使用’&gt;&gt;’表示追加打印，不加则会覆盖</span></span><br><span class="line">ls: cannot access /error/: No such file or directory</span><br><span class="line">[root@Souler6 app]<span class="comment"># cat 1.txt # 可以看到标准输出追加到了原有内容的下边</span></span><br><span class="line">/app/:</span><br><span class="line">total 8</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:33 1.txt</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">/app/:</span><br><span class="line">total 12</span><br><span class="line">-rw-r–r–. 1 root root 153 Jul 26 10:33 1.txt</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r–r–. 1 root root 307 Jul 26 10:48 1.txt <span class="comment">#由于内容追加，文件大小从153字节增长到了307字节</span></span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br></pre></td></tr></table></figure></p><p>从上文可以看到三种I/O他们都带着一个数字<br>STDIN（0）,STDOUT（1）,STDERR2（2）<br>那这些数字是代表什么呢</p><pre><code>实际上 ‘&gt;’是’1&gt;’ 我们可以这样理解 1&gt;重定向标准输出（数字具体表现在这）有’1&gt;’当然还有’2&gt;’ 我们可以这样理解 2&gt;重定向标准错误（数字具体表现在这）</code></pre><p>通过上面的例子<br>eg:我们直接尝试把标准错误追加到1.txt （也可以）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll /app/ /error/ 2&gt; 1.txt #把标准错误重定向至1.txt中打印</span></span><br><span class="line">/app/: <span class="comment">#没有重定向标准输出，故默认在屏幕中打印</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r–r–. 1 root root 53 Jul 26 11:07 1.txt</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># cat 1.txt # 查看1.txt是否打印了标准错误</span></span><br><span class="line">ls: cannot access /error/: No such file or directory <span class="comment">#可以看到打印了标准错误，文件中内容不再有之前的标准输出，可以说明由于不是重定向追加，所以直接覆盖了原文件1.txt</span></span><br></pre></td></tr></table></figure></p><h2 id="关于重定向的语法…"><a href="#关于重定向的语法…" class="headerlink" title="关于重定向的语法…"></a>关于重定向的语法…</h2><p>eg：</p><pre><code>&gt;    重定向标准输出&gt;&gt;   重定向标准输出追加2&gt;   重定向标准错误2&gt;&gt;  重定向标准错误追加set -C 重定向不覆盖set +C 重定向覆盖&gt;|   重定向强行覆盖 （用于忽略set -C）2&gt;&amp;1 将2（标准错误）重定向到1（标准输出）1&gt;&amp;2 将1（标准输出）重定向到2（标准错误）’&amp;&gt;’ 等同于’2&gt;&amp;1’把标准错误重定向为标准输出,(‘&amp;&gt;’兼容性不如’2&gt;&amp;1’,二者重定向意思等同)</code></pre><p><strong>面试题:以下哪个与众不同</strong></p><p>A app.sh &gt; f1.log 2&gt;&amp;1<br>B app.sh 2&gt;&amp;1 &gt; f1.log<br>C app.sh 2&gt;f1.log 1&gt;&amp;2<br>D app.sh &amp;&gt;f1.log</p><p>答案：<strong>B</strong></p><h2 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h2><p>既有标准输入，也有标准输出<br>tr可以使用’&lt;’重定向输入，’&gt;’重定向输入<br>举个简单例子：将1.txt内容中的小写字母转换为大写字母<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># cat 1.txt</span></span><br><span class="line">ls: cannot access /error/: No such file or directory</span><br><span class="line">ls: cannot access /error/: No such file or directory</span><br><span class="line">[root@Souler6 app]<span class="comment"># tr ‘a-z’ ‘A-Z’ &lt; 1.txt #将1.txt的内容重定向为标准输入</span></span><br><span class="line">LS: CANNOT ACCESS /ERROR/: NO SUCH FILE OR DIRECTORY</span><br><span class="line">LS: CANNOT ACCESS /ERROR/: NO SUCH FILE OR DIRECTORY</span><br></pre></td></tr></table></figure></p><h2 id="多行STDIN"><a href="#多行STDIN" class="headerlink" title="多行STDIN"></a>多行STDIN</h2><p>使用“&lt;&lt;终止词”命令从键盘把多行重导向给STDIN直到终止词位置<br><strong>cat &gt; file &lt;&lt; EOF</strong><br>举个简单的例子:</p><pre><code>[root@Souler6 app]# cat &gt; 1.txt &lt;&lt;EOF&gt;123&gt;456&gt;789EOF[root@Souler6 app]# cat 1.txt123456789</code></pre><p>（EOF可以是任意字符）</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>用符号 <strong>|</strong> 表示<br>用法：cmd1 <strong>|</strong> cmd2 <strong>|</strong> cmd3 <strong>|</strong> …<br>多个命令的链接，最后的命令会基于上一命令的基础，对内容进行再处理进行输出<br>举个简单例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll 1.txt #未加管道</span></span><br><span class="line">-rw-r–r–. 1 root root 106 Jul 26 11:15 1.txt</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll 1.txt | tr ‘a-z’ ‘A-Z’ #加管道进行大小写字母转换，并输出</span></span><br><span class="line">-RW-R–R–. 1 ROOT ROOT 106 JUL 26 11:15 1.TXT</span><br></pre></td></tr></table></figure></p><h2 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h2><p>用于管道中打印子shell的标准输出</p><p>（待补充）<br>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DAY-4&quot;&gt;&lt;a href=&quot;#DAY-4&quot; class=&quot;headerlink&quot; title=&quot;DAY 4&quot;&gt;&lt;/a&gt;DAY 4&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;内容概括：个人梳理命令、索引节点、标准I/O和管道相关知识&lt;/strong&gt;&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于文件系统，以及history、cd、ls、touch、cp命令以及通配符</title>
    <link href="http://yoursite.com/2018/07/25/%E7%AC%AC%E4%BA%8C%E5%91%A8-%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BB%A5%E5%8F%8Ahistory%E3%80%81cd%E3%80%81ls%E3%80%81touch%E3%80%81cp%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/25/第二周-关于文件系统，以及history、cd、ls、touch、cp命令/</id>
    <published>2018-07-25T12:00:00.000Z</published>
    <updated>2018-07-29T12:18:36.658Z</updated>
    
    <content type="html"><![CDATA[<p><strong>==DAY 3==</strong></p><p><strong>命令行扩展、被括起来的集合</strong></p><pre><code>``  $()  把一个命令的输出打印给另一个命令的参数&quot;&quot;弱引用 ，&apos;&apos;强引用{} 打印重复字符串的简化形式</code></pre><p><strong>文件通配符</strong></p><pre><code>*        --&gt; 匹配任意个字符？       --&gt; 匹配单个字符~        --&gt; 当前用户家目录~mage    --&gt; 用户mage家目录~+       --&gt; 当前工作目录~-       --&gt; 前一个工作目录[0-9]:   --&gt; 匹配数字范围[a-z]:   --&gt; 小写字母[A-Z]:   --&gt; 大写字母[qwer]   --&gt; 匹配列表中的任何的一个字符[^qwer]  --&gt; 匹配列表中的所有字符以外的字符预定义支付类： man 7 glob[:digit:]：任意数字，相当于0-9[:lower:]：任意小写字母[:upper:]: 任意大写字母[:alpha:]: 任意大小写字母[:alnum:]：任意数字或字母[:blank:]：水平空白字符[:space:]：水平或垂直空白字符[:punct:]：标点符号[:print:]：可打印字符[:cntrl:]：控制（非打印）字符[:graph:]：图形字符[:xdigit:]：十六进制字符</code></pre><p><strong>TAB键补全命令</strong></p><pre><code>前提是安装了程序 bash-completion查看该安装包版本 $rpm -qa bash-completion&lt;&gt;.noarch centos 6支持命令、目录的补全；不支持补全命令选项参数centos 7支持命令、目录的补全；支持补全命令选项参数</code></pre><p><strong>history命令</strong></p><pre><code>history命令用于显示指定数目的指令命令，读取历史命令文件中的目录到历史缓存区和将历史命令缓存区中的目录写入命令文件。该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入!2。历史命令是被保存在内存中的，当退出或者登录Shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。  每个用户的家目录下有个 .bash_history的文件，是专门存放用户所输入的命令历史。.bash_history（并非即时记录，用户登出才会将history追加入文件，不正常关机则无法写入文件）1.命令格式history [选项][参数]2.命令功能可单独用于查看历史命令，也可配合参数调用或删除历史命令。3.命令参数-c  (常用)清除内存中的历史列表-d &lt;n&gt; 清除第n条命令&lt;n&gt;（常用）显示最近n条历史记录-a将当前的历史记录行追加到历史记录文件-r 读取未读取的历史-w &lt;文件名&gt; 将当前历史写到指定文件中-p  执行且不留历史记录-s  伪造历史记录，但不执行</code></pre><p><strong>关于history调用</strong></p><pre><code>调用历史命令，n是命历史命令编号!n 执行上一条命令!!      执行前一条命令，去除参数!:0     补全上一个命令Esc，.     补全上一个命令按住alt+. </code></pre><p><strong>关于命令历史相关变量</strong></p><pre><code>HISTSIZE  历史记录条数HISTFILE  存储历史文件HISTFILESIZE  命令历史文件记录历史条数HISTTIMEFORMAT= &quot;%F %T&quot; 显示时间HISTIGNORE=&quot;str1:str2* &quot; 忽略str1命令，str2开头的历史</code></pre><p><strong>控制历史命令记录的方式</strong></p><pre><code>环境变量：HISTCONTROLignoredups: 忽略重复的命令；连续且相同方为”重复“ignorespace: 忽略所有空白开头的命令ignoreboth: ignoredups,ignorespaceerasedups: 删除重复命令Export 变量名=&quot;值存放在 /etc/profile或 ~/.bash_profile</code></pre><p><strong>bash快捷键</strong></p><pre><code>Ctrl + l清屏，相当于clear命令 Ctrl + o执行当前命令，并重新显示本命令 Ctrl + s阻止屏幕输出，锁定 Ctrl + q 允许屏幕输出 Ctrl + c终止命令Ctrl + z挂起命令bash的快捷键Ctrl + a光标移到命令行首，相当于HomeCtrl + e光标移到命令行尾，相当于EndCtrl + f光标向右移动一个字符Ctrl + b光标向左移动一个字符Alt + f光标向右移动一个单词尾Alt + b光标向左移动一个单词首Ctrl + xx光标在命令行首和光标之间移动Ctrl + u从光标处删除至命令行首Ctrl + k从光标处删除至命令行尾Alt + r    删除当前整行bash的快捷键Ctrl + w从光标处向左删除至单词首Alt + d从光标处向右删除至单词尾Ctrl + d删除光标处的一个字符Ctrl + h删除光标前的一个字符Ctrl + y将删除的字符粘贴至光标后Alt + c从光标处开始向右更改为首字母大写的单词Alt + u从光标处开始，将右边一个单词更改为大写Alt + l从光标处开始，将右边一个单词更改为小写Ctrl + t交换光标处和之前的字符位置Alt + t交换光标处和之前的单词位置Alt + N提示输入指定字符后，重复显示该字符N次注意：Alt组合快捷键经常和其它软件冲突</code></pre><p><strong>实验：录屏</strong>（多用于动态演示）</p><pre><code> 创建一个录屏命令 （用于复现）复现$ script -t 2&gt; time.log -a cmd.session$ .....$ .....$ ..... 退出录屏$exit 复现录像$ scriptptreplay time.log cmd.session</code></pre><p><strong>文件系统分层结构  LSB</strong></p><pre><code>/bin -&gt;/usr/bin 存放供用户使用的二进制程序/boot 引导程序文件，例如：kernel/dev  存放设备文件   brw------- b打头  块设备，随机访问   crw------- c打头  字符设备，线性访问/etc  存放系统范围内的配置文件，，可编辑的文本配置  /etc/opt  opt的配置文件  /etc/X11  X Windows系统的配置文件  /etc/sgml SGML的配置文件  /etc/xml  XML的配置文件/usr   用户存储只读用户数据的第二层次，包含绝大多数的（多）用户工具和应用程序/home  普通用户的家目录，保存用户个人的配置文件，一般为单独的分区/lib   /bin/和/sbin/中二进制文件必要的库文件/sbin  给管理员使用的二进制程序/media 可移除媒体的挂载点，图形界面下，自动充当光盘挂载点，代替/run/media/misc  命令行界面,普通用户手动挂载（进入该文件夹/misc/cd，则自动挂载光盘，不进入则不挂在）     $ systemctl start autofs     $ systemctl enable autofs       查看块设备      $ df/mnt   临时挂载的文件系统，超级用户手动挂载 $ mount /dev/sr0 /mnt/opt   可选应用软件包/proc  虚拟文件系统，，将内核与进程状态归档为文本文件，存放于内存，磁盘中所占空间为0，修改文件立即生效，但断电后数据丢失，数据修改不保存。/sys  虚拟文件系统，存放于内存，映射硬件信息      当识别不出块设备，扫描所有磁盘      $ echo &apos;- - -&apos; &gt; /sys/class/scsi_host/host2/scan/root  超级用户的家目录/sbin  必要的系统二进制文件/srv   站点的具体数据，由系统提供/data/run  不属于linux标准目录，代替/var/run/var  动态文件————在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区，亦可称为变量文件/tmp  临时文件，在系统重启时目录中文件不会被保留标准可参考 FHS国际规范 </code></pre><p><strong>文件系统</strong></p><pre><code>rootfs： root filesystem文件名大小写区分看文件系统：eg：  文件系统 xfs 严格区分大小写  文件系统 vfat 不区分大小写 文件有两类数据： 数据：data   存放数据的内容 元数据：metadata 存放数据的属性     </code></pre><p><strong>文件特性</strong></p><pre><code>查看文件类型的颜色规则$ cat /etc/DIR_COLOR   蓝色--&gt;目录绿色--&gt;可执行文件红色--&gt;压缩文件浅蓝色--&gt;链接文件灰色--&gt;其他文件亮黄色--&gt;设备文件查看文件类型drwxr-xr-x.  5 root root      231 Jul 18 14:49 vmware-toolseg： 文件类型由字符串drwxr-xr-x的第一位来表示，当前字符串第一位为d，由此我们可以得出该文件类型是目录文件-：普通文件d：目录文件b：块设备c：字符设备l：符号链接文件p：管道文件pises：套接字文件socker</code></pre><p><strong>显示当前工作目录</strong></p><pre><code>pwd命令$ pwd 显示连接路径$ pwd -P  显示真实物理路径  路径分为两种：相对路径，绝对路径  相对路径（方便文件转移后的运行）    不以正斜杠开始    指定相对于当前工作目录或某目录的位置    eg：      $ cd home/xu     在每个目录下都有&apos;.&apos;和&apos;..&apos; ，相对路径中经常会使用到     &apos;.&apos;表当前目录，&apos;..&apos;表父目录  绝对路径    以正斜杠开始    完整的路径位置    eg:      $cd /home/xu基名：basename目录名：dirname</code></pre><p><strong>cd命令</strong></p><pre><code>用于切换目录1.命令格式 cd &lt;路径&gt;2.命令功能 使用绝对或相对路径切换目录3.命令参数cd   切换至当前用户主目录cd ..  切换至父目录cd ~  切换到当前登录用户的家目录cd ~用户名  切换到指定用户家目录cd -    切换回上次的目录，原理：由变量$OLDPWD控制  可以手动更改变量 $OLDPWD=/路径名</code></pre><p><strong>ls命令</strong></p><pre><code>ls命令是linux下最常用的命令。ls命令就是list的缩写，ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多!1.命令格式ls [选项][参数]2.命令功能列出名表目录中所有的子目录和文件3.命令参数-d，列出目录本身，而不是其内容-a，列出所有文件以及文件夹（包括隐藏）-l使用长列表格式-A，不列出&apos;.&apos;(表当前目录)和&apos;..&apos;（表当前目录的父目录）-u，--time=atime, --time=access,--time= use与-l配合使用，显示访问时间-c，--time=ctime, --time=status与-l配合使用，显示权限修改时间-1 显示另一列文件-S 按文件从大到小排序-r，排序时的逆序-Sr 反转，按文件小到大排序-R，以递归方式列出子目录-X 按后缀排序  -U不排序;按目录顺序列出条目-p，追加/指标到目录-n， -num-uid-gid像-l，但列出数字用户和组ID-o像-l，但不列出组信息（还有一些不懂怎么用，没列出来）</code></pre><p><strong>touch命令</strong></p><pre><code>linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。1.命令格式touch [选项]..文件名..2.命令功能创建一个不存在的文件。touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。3.命令参数-r &lt;指定文档&gt; &lt;参考文档&gt;将文件时间与指定参考文件时间对齐。-c &lt;文件名&gt;若文件名不存在，则不创建。-t[[CC]YY]MMDDhhmm[.SS] &lt;文件名&gt; 设定文件的时间戳[[CC]YY]MMDDhhmm[.SS]eg：2018年07月24日14点20分00秒;对应格式：201807241420.00 -m 配合-t使用，修改Modify time 修改时间-a 配合-t使用，修改Acess time 访问时间</code></pre><p><strong>cp命令</strong></p><pre><code>cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 1.命令格式cp[选项].. 源 目的2.命令功能将源文件复制至目标文件，或将多个源文件复制至目标目录。3.命令参数-a,-archive与-dR --preserve = all相同--attributes-only不要复制文件数据，只复制属性 -i 覆盖前询问-n不覆盖已存在的文件--backup[=CONTROL]备份每个现有目标文件,接受参数-b像--backup但不接受参数--copy-contents递归时复制特殊文件的内容-d与--no-dereference --preserve=links相同-f,--force如果无法打开现有目标文件，请将其删除并尝试再次（当使用-n选项时忽略此选项）-H遵循SOURCE中的命令行符号链接-l,--link硬链接文件而不是复制-L,--dereference始终遵循SOURCE中的符号链接-P,--no-dereference永远不要在SOURCE中关注符号链接-p与--preserve = mode，ownership，timestamps相同</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;==DAY 3==&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令行扩展、被括起来的集合&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;``  $()  把一个命令的输出打印给另一个命令的参数

&amp;quot;&amp;quot;弱引用 ，&amp;apos;&amp;apo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人blog搭建（纯属笔记，不做任何解释）</title>
    <link href="http://yoursite.com/2018/07/22/%E4%B8%AA%E4%BA%BAblog%E6%90%AD%E5%BB%BA%EF%BC%88%E7%BA%AF%E5%B1%9E%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%B8%8D%E5%81%9A%E4%BB%BB%E4%BD%95%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2018/07/22/个人blog搭建（纯属笔记，不做任何解释）/</id>
    <published>2018-07-22T04:35:00.000Z</published>
    <updated>2018-07-22T05:14:49.345Z</updated>
    
    <content type="html"><![CDATA[<p>==<strong>windows下搭建hexo</strong>==</p><p>大致浏览即可，细节操作在下面的总结那<br>一.环境准备</p><p>1.安装node.js(npm也在安装包中)（默认安装即可，一路Next。。）<br>    安装包：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><pre><code>为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的</code></pre><p>   检查安装是否成功,出现版本号则说明 Node.js 环境配置成功<br>    node -v、npm -v</p><p>2.安装git（默认安装即可，也是一路Next。。）<br>    安装包：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p><pre><code>为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上</code></pre><p>   检查安装是否成功,出现版本号则说明 git 环境配置成功<br>    git -v<br>3.安装控制台Cmder（默认安装即可）<br>    安装包：<a href="http://cmder.net/" target="_blank" rel="noopener">http://cmder.net/</a></p><p>#个人使用爱好，可不装，用Windows自带cmd即可</p><p>4.安装Sublime Text 3（默认安装即可）<br>    安装包：<a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">https://www.sublimetext.com/3</a></p><p>#只要是支持.md的文本工具即可</p><p>二.GitHub的注册和配置<br>    官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>1.拥有一个GitHub账号，没有的话去官网注册一下，很简单就不多说了<br>    官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>2.在GitHub创建一个仓库</p><h1 id="yourname-必须是你的用户名。"><a href="#yourname-必须是你的用户名。" class="headerlink" title="yourname 必须是你的用户名。"></a>yourname 必须是你的用户名。</h1><pre><code>图片1（待上传）图片2（待上传） . . .</code></pre><p>3.配置SSH密钥</p><p>   1）在桌面空白处鼠标右键打开Git bash here,键入命令（$ 无需键入..）<br>    $ ssh-keygen -t rsa -C “your’s emaill address”<br>   引号内填入你注册时所用的邮箱，回车<br>   显示你ssh密钥生成后保存的目录，直接回车确认（记住目录名，后面要找它拿东西的）<br>   会提示你设置密码（需要输入两次，密码看不见的）设置完密码之后<br>   会生成两个文件&lt;id_rsa&gt;、&lt;id_rsa.pub&gt;<br>   前往目录寻找文件&lt;id_rsa.pub&gt;，使用sublime text3 打开，并复制所有内容<br>   2）将SSH密钥存入GitHub</p><h1 id="ssh-T-git-github-com-选择性设置，用于设置自动填入密码"><a href="#ssh-T-git-github-com-选择性设置，用于设置自动填入密码" class="headerlink" title="$ ssh -T git@github.com(选择性设置，用于设置自动填入密码)"></a>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>(选择性设置，用于设置自动填入密码)</h1><pre><code>图片1（待上传）图片2（待上传） . .</code></pre><p>三.环境配置完成，开始安装Hexo，以及利用hexo建立本地网站</p><p>1.win+r 打开Cmder控制台，键入命令</p><pre><code>$ npm install -g hexo-cli</code></pre><p>  会报错，正常现象<br>    npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\chokidar\node_modules\fsevents):<br>    npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href="mailto:fsevents@1.0.17" target="_blank" rel="noopener">fsevents@1.0.17</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”win32”,”arch”:”x64”})<br>关于这个两个报错：fsevent是mac osx系统的，你是在win或者Linux下使用了 所以会有警告，忽略即可</p><p>   安装需要点时间，请耐心等待，安装成功后会有提示<br>    $ hexo -v<br>   检查安装是否成功,出现版本号则说明 hexo 安装成功</p><p>2.在任意一个分区创建任意一个文件夹，并该目录建立网站</p><p>#路径中不要有中文<br>    eg:创建test文件夹，路径为F:\test<br>git<br>    hexo init f:\test         创建一个网站，可能需要等待一小会，耐心等待<br>  成功提示：INFO  Start blogging with Hexo!</p><p>3.配置test目录下的_config.yml，生成静态文件<br>    配置_config.yml，用sublime text3 打开编辑并保存<br>  直接到文本尾部</p><pre><code># Deployment   deploy:     type: git     repository: https://github.com/xucanbin/xucanbin.github.io.git     branch: master$ npm install hexo-deployer-git --save         安装一个插件</code></pre><p>  在test目录中，鼠标右键打开git bash  </p><pre><code>$ ls            检查下目录下是不是出现多个文件，都是用于搭建网站的，这就是hexo的强大之处了$ hexo g        生成静态文件。$ hexo s        启动服务器。默认情况下，访问网址为： http://localhost:4000/</code></pre><p>   尝试能否访问<a href="http://localhost:4000/，当然这只是本地的网页，没什么用。" target="_blank" rel="noopener">http://localhost:4000/，当然这只是本地的网页，没什么用。</a><br>   成功则如图<br>   由于source目录下自带一篇hello world文章，所以你网页上自动生成了。</p><p>四.配置test目录下的_config.yml</p><p>五.将hexo建立网站的目录（亦可称为本地仓库）与github同步</p><p> 在test目录下，新建一个README.md，并鼠标右键打开git bash<br> 并新建一个README.md ，用sublime text 3 打开编辑随意写点东西，后面会用到</p><p>将当前目录转变成一个 Git 仓库</p><pre><code>$ git init </code></pre><p>配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息</p><pre><code>$ git config --global user.name &quot;Your&apos;s name&quot;           引号中填自己的GitHub账号$ git config --global user.email &quot;Your&apos;s email address&quot; 引号中填注册GitHub的邮箱$ git add README.md       将README.md添加到索引$ git commit -m &quot;first commit&quot;添加远程仓库$ git remote add origin git@github.com:yourname/yourname.github.io.git$ ssh -T git@github.com$ git push -u origin master$ hexo g$ hexo d</code></pre><p>二次总结</p><p>关于搭建个人博客的事情我自己总结了几点</p><p>hexo 是帮你搭建了一个本地网站</p><p>git 是用于配置giuhub上的仓库以及ssh密钥</p><p>node.js的话，主要是其环境下的npm，依赖npm去安装hexo </p><p>我们创建自己的博客网站 其实就是把hexo创建的本地网站 所生成的静态页面部署到GitHub上<br>请准备好<git>好&lt;node.js&gt;环境，才能开始下列操作<br>实现部署的前提，拥有一个github账号以及在github上创建一个库命名格式为&lt;账号名.github.io.git&gt;</git></p><p>#命名格式必须遵守，不然无法成功（目前我是找不到其他方法啦）<br>1.安装并使用hexo,生成本地网站之后，配置本地网站中的_config.yml</p><pre><code>$ npm install -g hexo-cli   (还未分清楚用cmd还是git-bash安装，待测试)$ hexo --version    </code></pre><p>2.使用hexo建立本地网站</p><pre><code>$ hexo init &lt;目录名&gt;         亦可进入目录下打开git-bash键入</code></pre><p>3.生成静态页面，也就是你未来的blog网站，</p><pre><code>$ hexo g</code></pre><p>##｛以下操作可跳过<br>       $ hexo s       启动服务器，尝试进入本地网站，正常的话可以访问：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> </p><p>##以上操作可跳过｝</p><p>4.配置本地网站中的_config.yml</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><pre><code>deploy:  type: git  repository: https://github.com/xucanbin/xucanbin.github.io.git  branch: master</code></pre><p>5.安装hexo的deployer插件（必须装的插件）</p><pre><code>$ npm install hexo-deployer-git --save  (成功提示待测试)</code></pre><p>6.本地git仓库（这是把本地网站目录转换为git仓库的操作，我记得会有有一个.git）</p><pre><code>$ git init &lt; 目录名&gt;    亦可进入目录下打开git bash 直接键入</code></pre><p>7.ssh密钥   (使用git-bash)</p><pre><code>$ ssh-keygen -t rsa -C &quot;your&apos;s emaill address&quot; </code></pre><p>   引号内填入你注册时所用的邮箱，回车<br>   显示你ssh密钥生成后保存的目录，直接回车确认（记住目录名，后面要找它拿东西的）<br>   会提示你设置密码（需要输入两次，密码看不见的）设置完密码之后<br>   会生成两个文件&lt;id_rsa&gt;、&lt;id_rsa.pub&gt;<br>   前往目录寻找文件&lt;id_rsa.pub&gt;，使用sublime text3 打开，并复制所有内容<br>   将SSH密钥存入GitHub，附图片</p><p>##（待上传）##<br>8.配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息<br>      （在仓库目录下打开git-bash） </p><pre><code>$ git config --global user.name &quot;Your&apos;s name&quot;           引号中填自己的GitHub账号$ git config --global user.email &quot;Your&apos;s email address&quot; 引号中填注册GitHub的邮箱$ git add README.md               将README.md添加到索引$ git commit -m &quot;first commit&quot;    记录对存储库的更改,使用给定的&quot;&quot;first commit&quot;&quot;作为提交消息</code></pre><p>9.添加git远程仓库（在仓库目录下打开git-bash）<br>  添加远程仓库</p><pre><code>$ git remote add origin git@github.com:xucanbin/xucanbin.github.io.git</code></pre><p>10.推送到远程仓库（将 master 分支推送到 origin 服务器）（在仓库目录下打开git-bash）</p><pre><code>$ git push origin master</code></pre><p>11.基于被配置完后的_config.yml,再次生成静态网页（在仓库目录下打开git-bash）</p><pre><code>$hexo g</code></pre><p>12.将第二次生成的静态网页部署到git的远程仓库中（在仓库目录下打开git-bash）</p><pre><code>$hexo d        后续弹出一个窗口 输入git用户名以及密码</code></pre><p>基础搭建完成<br>test目录下 f:\test\source_post\<br>上传文章的方法</p><p>以后写的博客直接放在里面，格式要求 后缀的.md<br>git-bash下</p><pre><code>$ hexo g$ hexo d$ git push origin master</code></pre><p>最后，打开自己的博客就能看到文章所在。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;==&lt;strong&gt;windows下搭建hexo&lt;/strong&gt;==&lt;/p&gt;
&lt;p&gt;大致浏览即可，细节操作在下面的总结那&lt;br&gt;一.环境准备&lt;/p&gt;
&lt;p&gt;1.安装node.js(npm也在安装包中)（默认安装即可，一路Next。。）&lt;br&gt;    安装包：&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机基础知识</title>
    <link href="http://yoursite.com/2018/07/21/%E7%AC%AC%E4%B8%80%E5%91%A8-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/07/21/第一周-计算机基础知识/</id>
    <published>2018-07-21T07:45:00.000Z</published>
    <updated>2018-07-29T12:15:34.633Z</updated>
    
    <content type="html"><![CDATA[<p>==<strong>DAY 1</strong>==</p><h2 id="认识计算机"><a href="#认识计算机" class="headerlink" title="认识计算机"></a>认识计算机</h2><p><strong>世界上第一台计算机</strong></p><pre><code>计算机：一种能接受和存储信息，对海量数据进行自动、高速地处理，并输出结果的现代化智能设备。</code></pre><p><strong>冯·诺依曼体系结构</strong>：1946年数学家冯·诺依曼提出计算机有5个组成部分：运算器、控制器、存储器（主存储器、辅助存储器）、输入设备、输出设备。</p><pre><code>1946年，世界上第一台计算机在美国滨州大学诞生。占地170平方米，重达30吨。</code></pre><p>计算机发展历史：</p><pre><code>第一代（电子管时代）：1946-1957  第二代（晶体管时代）：1958-1964第三代（集成电路时代）：1965-1970第四代（大规模集成电路时代）：1971以后```</code></pre><p><strong>计算机系统</strong></p><p>1.硬件系统</p><pre><code>主机     中央处理器CPU          运算器ALU          控制器CU     内部存储器          rom          ram（断电丢失数据） 外部设备     外部存储器：硬盘、U盘     输入设备：鼠标、键盘     输出设备：显示屏、打印机、音频</code></pre><p>2.软件系统</p><pre><code>系统软件：     操作系统：win7、linux、mac     程序语言处理系统     数据库服务系统     服务程序：检查、诊断、调试程序应用软件：     通用应用软件--如QQ、office办公     专用应用软件--用户程序</code></pre><p><strong>服务器种类</strong></p><pre><code> 塔式服务器tower机架式服务器rack规格：宽度为19英寸，高度以U为单位，如42U（约2米高）。       1U=44.45毫米=1.75英寸。配件：     KVM（Keyboard Video Mouse）     PDU (Power Distribution Unit)刀片式服务器blade</code></pre><p><strong>存储网络：</strong></p><pre><code>DAS---直接连接存储(direct attached storage)与主机紧密相连     优点：         管理成本低，实施简单。     缺点：         存储共享受到限制。         不利于CPU的指令周期优化，增加系统负担。NAS---网络连接存储(network attached storage)基于文件协议（NFS、SMB/CIFS）,实现文件共享，适用于局域网或较小的网络     优点：         集中管理数据，从而释放带宽，提高性能。         可提供跨平台文件共享功能。     缺点：         可靠性差。    SAN---存储区域网络(storage area networks)基于SCSI、IP、ATM等多种高级协议，实现存储共享     优点：         服务器跟储存装置两者各司其职，         高效能、高稳定度的存储环境。     缺点：         实施复杂，管理成本高。</code></pre><p><strong>操作系统</strong><br>(Operating System)：</p><pre><code>OS功能：     硬件驱动、进程管理、内存管理、网络管理、安全管理、文件管理。OS分类：     服务器OS:REHL,CentOS,window server,AIX     桌面OS:WIN7,WIN10,MAC0S,Fedora     移动设备OS:Android,IOS,YunOS</code></pre><p><strong>开发接口</strong></p><p>ABI接口 （应用接口）</p><pre><code>OS与应用程序的底层接口,允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行如.apk无法在win7上运行如.exe无法在Android上运行</code></pre><p>API接口 （开发接口）</p><pre><code>库调用源代码和库之间的接口，实现库调用，因此同样的源代码可以在支持这个API的任何系统中编译</code></pre><p>POSIX:Portable Operating System Interface</p><pre><code>IEEE（国际组织）在操作系统上定义的一系列API标准</code></pre><p><strong>==练习==：</strong></p><pre><code>1.显示当前时间，格式：2016-06-18 10：20：30 2.显示前天是星期几3.设置当前时间为2019-08-07 06：05：10</code></pre><p>1.答：</p><pre><code>$ date %F&apos; &apos;%T</code></pre><p>2.答：</p><pre><code>$ date -d “2 days ago” +%A</code></pre><p>3.答：</p><pre><code>$ date 080706052019.10</code></pre><p>==<strong>DAY 2</strong>==</p><p>用户和内核空间</p><p>用户空间 user space</p><pre><code>用户空间必须通过系统接口（system call），才能向内核发出指令。</code></pre><p>内核空间 kerneL space</p><pre><code>内核空间可以执行任意命令，调用系统的一切资源。</code></pre><p>用户与内核的联系</p><pre><code>用户的程序无法直接访问硬件，只能通过操作系统间接访问硬件。两个空间相对独立，防止损害硬件，但用户能通过操作系统间接访问硬件。</code></pre><p>原理：</p><pre><code>上下文切换，会带来额外的资源损耗，减少上下文切换的次数，可以降低资源损耗。相当于用户空间与内核空间的来回切换。user space     user land application     #library#函数库,API接口     ↓↓↓     ↓↓↓（invoke）     ↓↓↓kernel space     #system call#系统调用接口     kernel     device driver     ↓↓↓hardware</code></pre><p>查看库调用</p><pre><code>$ ldd /bin/command$ ldd /bin/command</code></pre><p>跟踪底层系统调用</p><pre><code>$ strace command </code></pre><p>跟踪底层库调用</p><pre><code>$ ltrace command </code></pre><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>低级语言</p><pre><code> 机器语言：0、1汇编语言:和机器语言一一对应(学汇编，不会编)</code></pre><p>中级语言:系统级应用、驱动程序</p><pre><code>C语言</code></pre><p>高级语言：应用级程序开发</p><pre><code>Java、Python、Go、PHP、Objective-C、C#</code></pre><p>查看16进制的2进制代码</p><pre><code>$ hexdump -c  /bin/ls </code></pre><p>兼容分时系统工作原理</p><pre><code>原理：时间片 1s对于计算机来讲，相当的漫长 eg：1s分为100个时间片，每个时间片10ms任务绑定cpu：task cpu（主要是利用cpu中的三级缓存&quot;cache，L1,L2,L3&quot;，提高任务处理效率)</code></pre><p><strong>Linux起源</strong></p><pre><code>1991年的10月5日，完全免费的内核kernel诞生了</code></pre><p>兼容分时系统：Multics（多路信息计算系统）</p><pre><code>1964年发起了开发计划，于1969年失败，贝尔实验室退出计划。而后，ken thompson 为了打游戏，写了一个系统UNICS.（unix雏形）1969 ，雏形初现unics，基于B语言开发   1973，正式命名unix，基于C语言开发1977，BSD,伯克利大学流派开始开发1979，贝尔实验室流派，system V架构，因版权问题，不对学生提供源码，开始收费1984，minix操作系统，由Andrew S.Tanenbaum开发</code></pre><p>GUN（GNU is Not Unix）</p><pre><code>1984，由Richard Stallman发起并创建目的是为了所有软件开源、自由</code></pre><p>GPL(GUN General Public License)</p><pre><code>允许用户任意复制、传递、修改及再发布</code></pre><p>LGPL(Lesser General Public License)</p><pre><code>LGPL相对GPL较为宽松，允许不公开所有源码</code></pre><p>查看bash遵守GPL协议</p><pre><code>$ rpm -qi bash </code></pre><p>完整的类UNIX操作系统</p><pre><code>Linux内核+GNU工具</code></pre><p>linux三大主流</p><pre><code>Debian --UbantuRedHat --CentOSSlackware  --S.U.S.E</code></pre><p><strong>查看内核版本</strong></p><pre><code>$ uname -r </code></pre><p><strong>版本号解读</strong></p><pre><code>3.10.0-862.el7.x86_64 内核版本号 &apos;3.10.0&apos; 编译次数 &apos;862&apos;  次 厂商版本 &apos;el&apos; 商业Lunix 版本号 &apos;7&apos; centos7  &apos;x86-64&apos;  64位</code></pre><p><strong>登录前界面的配置文件</strong></p><pre><code>$ cat /etc/issue</code></pre><p><strong>哈希值校验</strong>（安装系统后检查系统的完整性）</p><pre><code>$ sha1sum /dev/sr0   </code></pre><p><strong>虚拟机软件:模拟硬件环境</strong></p><pre><code>vmware</code></pre><p><strong>windows下CMD命令行转换分区格式，数据不丢失（单向的FAT格式转NTFS ）</strong></p><pre><code>$ conver H:/fs:ntfs</code></pre><p><strong>Linux 准备</strong></p><pre><code>/dev/sda==硬盘/home/xu==c:\user/etc==注册表/usr==C:\Windows and C:\program files/boot 启动 mount point 挂载点</code></pre><p><strong>引导分区格式 MBR &amp; GPT</strong></p><p>MBR（主分区与扩展分区合起来不超过4个）</p><pre><code>MBR（主分区与扩展分区合起来不超过4个）主分区：     一个硬盘最多4个，主分区最小单位，只有一个活动的主分区。扩展分区：     一个硬盘最多只有一个扩展分区。但不可存储，需再次划分为更小的分区才能存储数据，即逻辑分区。逻辑驱动器：     由扩展分区二次划分。</code></pre><p>GPT（待补充）</p><p><strong>linux中分区格式</strong></p><pre><code>主分区编号：/dev/sda1~4 扩展分区编号：：/dev/sda5，6...</code></pre><p><strong>centos分区大小</strong> （建议）</p><pre><code>/boot 1g   系统挂载点/     50g   根目录/data 20g   做实验用的目录swap  2g    虚拟内存，大小一般为内存的1.5倍或者2倍</code></pre><p><strong>更改主机名</strong></p><pre><code>centos6$ nano /etc/sysconfig/networkcentos7$ nano /etc/hostname</code></pre><p>引导程序：</p><pre><code>$ grub</code></pre><p>查看内存：  </p><pre><code>$ free$ cat /proc/meminfo</code></pre><p>查看内存使用：</p><pre><code>$ free -h</code></pre><p><strong>用户id号：</strong></p><pre><code>id为0，则为管理员，与root名字无关</code></pre><p>uid</p><pre><code>超级用户root   uid：0普通用户       uid：500+或者1000+</code></pre><p>查看uid</p><pre><code>$ id -u   centos6 id 普通用户从500开始计算。。501 centos7 id 普通用户从1000开始计算。。1001</code></pre><p><strong>终端：</strong></p><p>物理终端</p><pre><code>/dev/tty* </code></pre><p>虚拟终端</p><pre><code>/dev/pts*</code></pre><p>查看当前终端：</p><pre><code>$ tty$ whoami$ who am i</code></pre><p>查看所有在线终端：</p><pre><code>$ who</code></pre><p>切换终端：</p><pre><code>$ chvt &lt;终端号&gt;$ ctrl+F1~F6</code></pre><p>关机命令：</p><pre><code>$ halt；$ poweroff；$ shutdown -r now</code></pre><p>设置登录前界面显示</p><pre><code>$ nano /etc/issue \d 天数  \l 显示当前登录终端号 \n 显示主机名字 \t 显示当前时间 \r 显示内核版本 \s 显示系统版本</code></pre><p><strong>==练习==：</strong></p><pre><code>1.在本机字符终端登录时，除显示原有信息外，再显示当前登录终端号，主机名和当前时间2.今天18：30自动关机，并提示用户</code></pre><p>1.答：  </p><pre><code>$ nano /etc/issue 在文件中加入以下代码 You are login on \l The hostname is \n It&apos;s \t now!</code></pre><p>2.答：</p><pre><code>$ shutdown 18：30 “you were be shutdown”</code></pre><p>==<strong>DAY</strong> 3==</p><p>多数企业基于安全问题，防止被针对版本漏洞而受到攻击，有关版本号的信息会进行自主修改。</p><p>许多公司在生产中所用系统版本相对滞后，以求稳定。</p><p>linux的系统相关配置皆放在文本文件中。</p><p><strong>查看centos版本</strong></p><p>centos6</p><pre><code>$ lsb_release -a （此程序centos7默认没有安装）</code></pre><p>centos7</p><pre><code>$ cat /etc/centos-release</code></pre><h6 id="字符界面下的编辑文本工具"><a href="#字符界面下的编辑文本工具" class="headerlink" title="字符界面下的编辑文本工具"></a>字符界面下的编辑文本工具</h6><pre><code>$ nano &lt;目录&gt;</code></pre><p>指定用户开机自动登录</p><pre><code>   编辑配置文件$ nano /etc/gdm/custom.conf   在字符 [daemon]下加入两行代码 [daemon] AutomaticLoginEnable=true AutomaticLogin=&lt;user&gt;</code></pre><p>查看cpu详细信息</p><pre><code>$ lscpu    Flags:所带有的关键特性，eg：mmx，针对视频加速处理的一个特性</code></pre><p>查看块设备</p><pre><code>$ lsblk</code></pre><p>查看网卡</p><pre><code>$ dmesg</code></pre><h3 id="交互式口"><a href="#交互式口" class="headerlink" title="交互式口"></a>交互式口</h3><p><strong>操作linux需要交互式接口</strong></p><p>图形化用户接口GUI(Graphic User Interface)</p><pre><code>GNOME(C,GTK)KDE(C++,QT)XFCE(轻量级桌面)应用于：X protocol, window manager, desktop三者之间的区别：底层库不同</code></pre><p>命令行接口CLI （效率高）</p><pre><code>shell程序：sh(bourn史蒂夫·伯恩)cshtcshksh(korn)bash (bournagain shell)GPLzshshell也被称为命令解释器。shell也属于开发语言，是一种简化、功能较弱的高级语言。</code></pre><h6 id="除了以上常提到的shell，还有一种shell较为特殊的shell-：nologin"><a href="#除了以上常提到的shell，还有一种shell较为特殊的shell-：nologin" class="headerlink" title="除了以上常提到的shell，还有一种shell较为特殊的shell ：nologin"></a>除了以上常提到的shell，还有一种shell较为特殊的shell ：nologin</h6><h6 id="用于底层系统服务，而非用户使用。"><a href="#用于底层系统服务，而非用户使用。" class="headerlink" title="用于底层系统服务，而非用户使用。"></a>用于底层系统服务，而非用户使用。</h6><p>查看当前所用shell</p><pre><code>$ echo $SHELL</code></pre><p>查看系统含有的所有shell</p><pre><code>$ cat /bin/shells</code></pre><p><strong>PS1变量 （用于命令行提示符）</strong></p><p>临时更改命令行提示符颜色</p><pre><code>$ PS1=&quot;\[\e[1;40;31m\][\u@\h \W]$\[\e[0m\]&quot;</code></pre><h6 id="1代表高亮-31-37代表字体颜色-40代表背景色"><a href="#1代表高亮-31-37代表字体颜色-40代表背景色" class="headerlink" title="1代表高亮,31~37代表字体颜色,40代表背景色"></a>1代表高亮,31~37代表字体颜色,40代表背景色</h6><p>永久更改命令提示符行颜色</p><pre><code>1.在/etc/profile.d/目录下2.创建&lt;任意名&gt;.sh3.将PS1=&quot;\[\e[1;40;31m\][\u@\h\W]$\[\e[0m\]&quot; 复制进去，保存4.source 文件，或者重启即可</code></pre><p><strong>PATH变量（用于存放外部命令的所有路径点）</strong></p><pre><code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><p><strong>帮助命令</strong></p><pre><code>$ help commandhelp中带*的表示被禁用</code></pre><h6 id="（）16进制中，0a换行符号，0d回车"><a href="#（）16进制中，0a换行符号，0d回车" class="headerlink" title="（）16进制中，0a换行符号，0d回车"></a>（）16进制中，0a换行符号，0d回车</h6><h3 id="三大类命令"><a href="#三大类命令" class="headerlink" title="三大类命令"></a>三大类命令</h3><p><strong>内部命令</strong></p><p>集成于当前系统所使用shell中的一些命令</p><p>查看所有内部命令</p><pre><code>$ enable</code></pre><p>禁用内部命令</p><pre><code>$ enable -n command</code></pre><p>启用内部命令</p><pre><code>$ enable command</code></pre><p>查看被禁用命令 </p><pre><code>$ enable -n</code></pre><p>查看可用命令</p><pre><code>$ enable -p</code></pre><p><strong>外部命令</strong></p><p>外部命令是在磁盘中独立的文件，使用的时候需要到磁盘中读取。</p><p>外部命令执行一次会产生缓存，有个命令叫hash，会从$PATH这个变量中定义的路径去搜索外部命令，从而执行该命令。</p><p>原理：</p><pre><code>外部命令一旦执行过后，命令所在路径会被hash缓存到内存中，下次再执行命令的时候就不必再到路径中去搜索，直接从hash中的路径读取，不用再到各个路径中去搜索，从而提升速度。</code></pre><p>关于hash的使用：</p><pre><code>$ hash                显示 hash 缓存 $ hash – l            显示 hash 缓存，可作为输入使用 $ hash – p path name  将命令全路径 path 起 别名为 name $ hash – t name       打印缓存中 name 的路径 $ hash – d name       清除 name 缓存 $ hash – r            清除缓存</code></pre><p><strong>别名命令</strong> <strong>alias</strong></p><p>外部命令与内部命令都可以被写为别名。</p><p>要想别名重启后不丢失永久生效，需将命令写当前用户目录下的.bashrc中</p><pre><code>$ nano /home/name/.bashrc      (普通用户,name换成你的用户名)$ nano /root/.bashrc           (超级用户)$ nano /etc/.bashrc            (所有用户）</code></pre><p>查看所有别名</p><pre><code>$ alias</code></pre><p>创建别名命令</p><pre><code>eg：  $ ailas copy=&apos;cp&apos; | &quot;cp&quot;  （&apos;&apos;跟&quot;&quot;都能学习）  $ alias -p copy=&apos;cp&apos;  （创建别名并打印出所有别名，仅支持&apos;&apos;）</code></pre><p>取消别名</p><pre><code>$ unalias </code></pre><p>取消所有别名</p><pre><code>$ unalias -r</code></pre><p>忽视别名的存在，强制执行原始命令</p><pre><code>$ \command$ `command`</code></pre><p><strong>判断命令的类别</strong> （tpye）</p><p>外部命令显示（路径）：</p><pre><code>eg：$ type echo    $ echo is /usr/bin/echo</code></pre><p>内部命令显示：</p><pre><code>eg：$ type type    $ type is a shell builtin</code></pre><p>别名命令则显示：（假设存在别名 alias copy=’cp’）</p><pre><code>eg：$ type copy    $ copy is aliased to `cp&apos;  </code></pre><p>显示命令的所有路径（或者类别）：</p><pre><code>$ type -a </code></pre><h6 id="优先级：别名命令-gt-内部命令-gt-外部命令"><a href="#优先级：别名命令-gt-内部命令-gt-外部命令" class="headerlink" title="优先级：别名命令&gt;内部命令&gt;外部命令"></a>优先级：别名命令&gt;内部命令&gt;外部命令</h6><p>在linux中，内存，属于易失性，要想配置永久生效，就要写到文件中。</p><p><strong>command</strong><br>组成部分</p><pre><code>[短选项]:-（可多个选项合并使用）eg:    $ ls -a -l    $ ls -la     $ ls -al  等同[长选项]:--eg：    $ ls --all    $ ls --help[参数]    可以是文件，也可以是路径等等。</code></pre><p><strong>快捷键</strong>（待补充）</p><p>快速退出终端</p><pre><code>ctrl+d </code></pre><p>强制结束</p><pre><code>ctrl+c </code></pre><p><strong>日期和时间</strong></p><p>硬件时间</p><pre><code>$ clock = $ hwclock $ clock   显示硬件时间$ clock -s，--systohc修正系统时间，以硬件时间为准$ clock -w，--hctosys修正硬件时间，以系统时间为准</code></pre><p>系统时间</p><pre><code>$ date     显示系统时间$ date +%s 计算从1970.1.1至今一共多少秒$ date -s  根据描述设置时间$ date -d  根据描述显示时间$ date -d  @&lt;秒&gt; +&quot;%F %T&quot;$ date -d &quot;2018-08-08 20:00:00&quot;+%s</code></pre><p>时区路径 /etc/localtime</p><p>更改时区</p><p>centos6.x</p><pre><code>$ tzselect</code></pre><p>centos7.x</p><pre><code>$ timedatectl set-timezone &lt;时区路径&gt;</code></pre><p>日历</p><pre><code>$ cal 显示当月日历$ cal -y 显示当年日历$ cal &lt;年份&gt; 显示该年份日历</code></pre><h6 id="与远程服务器同步时间"><a href="#与远程服务器同步时间" class="headerlink" title="与远程服务器同步时间"></a>与远程服务器同步时间</h6><pre><code>$ ntpdate &lt;ip&gt;      （ip较为特殊，需配置过的ip地址才能同步）</code></pre><h6 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h6><p>发送消息给所有在线主机，多用于提示</p><pre><code>$ wall “system will shutdown at 19：00 ”</code></pre><h4 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h4><p>获取帮助的能力决定了技术的能力</p><p>了解外部命令的基本功能</p><pre><code>$ whatis</code></pre><p>系统使用一定时间后，会生成生成数据库或者手动创建数据库</p><pre><code>$ whatis command数据库</code></pre><p><strong>手动创建whatis数据库</strong></p><p>centos 6.x</p><pre><code>$ makewhatis</code></pre><p>centos 7.x</p><pre><code>$ mandb</code></pre><p>了解命令的基本功能</p><pre><code>内部命令：$ help command外部命令：$ command --help</code></pre><p>寻找命令所在路径</p><pre><code>$ whereis</code></pre><h6 id="man-and-info（有待详细说明）"><a href="#man-and-info（有待详细说明）" class="headerlink" title="man and info（有待详细说明）"></a>man and info（有待详细说明）</h6><p>man帮助（manual用户手册）</p><p>man章节分类</p><pre><code>1.用户命令2.系统调用3.C库调用4.设备文件及特殊文件5.配置文件格式6.游戏7.杂项8.管理类命令9.Linux内核API</code></pre><p>使用命令获取章节号</p><pre><code>$ whatis command</code></pre><p>指定man章节号寻找帮助</p><pre><code>$ man &lt;章节号&gt; command</code></pre><p>在man中搜索关键词</p><pre><code>/ &lt;关键词&gt;  or ?&lt;关键词&gt;</code></pre><p>man的配置文件目录</p><p>centos6</p><pre><code>man.conf(作用待了解)</code></pre><p>centos7</p><pre><code>man_db.conf(作用待了解)</code></pre><p>待续….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;==&lt;strong&gt;DAY 1&lt;/strong&gt;==&lt;/p&gt;
&lt;h2 id=&quot;认识计算机&quot;&gt;&lt;a href=&quot;#认识计算机&quot; class=&quot;headerlink&quot; title=&quot;认识计算机&quot;&gt;&lt;/a&gt;认识计算机&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;世界上第一台计算机&lt;/stron
      
    
    </summary>
    
    
  </entry>
  
</feed>
