<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Souler ACan’s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Souler ACan’s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Souler ACan’s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Souler ACan’s blog">
  
    <link rel="alternate" href="/atom.xml" title="Souler ACan’s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Souler ACan’s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">who am i ？</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-第三周-shell脚本编程基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/05/第三周-shell脚本编程基础知识/" class="article-date">
  <time datetime="2018-08-05T08:00:00.000Z" itemprop="datePublished">2018-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/05/第三周-shell脚本编程基础知识/">shell脚本编程基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="shell脚本编程基础"><a href="#shell脚本编程基础" class="headerlink" title="shell脚本编程基础"></a>shell脚本编程基础</h1><h2 id="编程基础"><a href="#编程基础" class="headerlink" title="编程基础"></a>编程基础</h2><p><strong>程序:为了更好的处理数据</strong>  </p>
<pre><code>程序:算法+数据结构  
数据:是程序的核心   
数据结构：数据在计算集中的类型和组织方式  
算法： 处理数据的方式  
</code></pre><p><strong>程序编程风格：</strong>  </p>
<pre><code>过程式：以指令为中心，数据服务于指令（shell编程基于过程式）  
对象式：以数据为中心，（开发语言推崇使用）  
</code></pre><p>shell程序：提供了编程能力，解释执行的过程<br>shell编程：过程式、解释执行  </p>
<p><strong>程序的执行方式：</strong></p>
<pre><code>运行二进制指令
    编程语言：人于计算机之间交互的语言
低级编程语言：
    机器：二进制的0和1的序列，称为机器指令
    汇编：艰涩难懂，贴近硬件
高级编程语言：
    编译型语言：
        英文句子--&gt;编译器--&gt;编译成机器代码--&gt;执行 （时间短）
        典型：C
    解释型语言：
        英文句子--&gt;执行--&gt;解释器--&gt;解释成机器代码（每次执行都要有一个解释的过程，时间长）
        典型：shell、python、perl
Java的程序比较特殊： 转换中间代码（处理数据运行于虚拟机），屏蔽底层的接口，实现（一次编译到处运行）
</code></pre><p><strong>编程的基本概念：</strong></p>
<pre><code>编程逻辑处理方式：
    顺序循环
    循环执行
    选择执行
编程的基本结构：
    各种系统命令的组合
    数据存储：变量、数组
    表达式：a+b
    语句：if
</code></pre><hr>
<h2 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h2><p>—shell脚本：包含一些命令或声明，并符合一定格式的文本文件</p>
<p><strong>格式要求：</strong> 首行shebang机制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  使用bash</span></span><br><span class="line"><span class="meta">#!/bin/csh   使用csh</span></span><br><span class="line"><span class="comment">#!/bin/python 使用python    //格式要求：首行shebang机制，命名与所用解释器有关</span></span><br></pre></td></tr></table></figure></p>
<p><strong>shell脚本的用途：</strong> 减少重复操作</p>
<pre><code>自动化常用命令
执行系统管理和故障排除
创建简单的应用程序
处理文本或文件
</code></pre><p><strong>创建shell脚本：</strong><br>    第一步：使用文本编辑器来创建文本文件<br>      脚本内容的第一行必须是shebang机制#!/bin/bash  ，后续可以跟注释，注释以#开头，用于提醒其他人<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg：vim test.sh  //创建文本</span><br><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="comment">#the first foot book   //此处为注释</span></span><br><span class="line">hellowold</span><br></pre></td></tr></table></figure></p>
<p>第二步：运行脚本<br>        运行的方法有很多种 </p>
<pre><code>直接运行解释器，将脚本作为解释器程序的参数运行  
    bash test.sh  
给予执行权限，将脚本放入$PATH变量中的所指定的路径  
    chmod +x test.sh  
    test.sh  
亦可用绝对路径运行脚本  
    /path/to/test  
</code></pre><p>注意：脚本属于外部命令，外部命令执行需要通过$PATH变量所在路径去搜索命令  </p>
<pre><code>将当前目录作为PATH变量中的路径(基于安全，此方法少用为好) 
    PATH=.:$PATH
        &apos;.&apos;表示当前目录，&apos;:&apos;为了保留之前的变量，用冒号隔开，将此变量加入配置文件中，并且source使配置文件生效即可  
不常用的脚本运行方式：因为会改变环境变量
    . test.sh      
    source test.sh 
</code></pre><p><strong>脚本规范：</strong>   脚本代码开头约定（除了shebang机制必须添加，其它注释看个人喜好添加）  </p>
<pre><code>第一行一般为shebang机制
作者
日期
版本号
程序名
程序作用
版本更新的简要说明
</code></pre><p><strong>脚本的基本结构：</strong>  </p>
<pre><code>#!shebang 声明机制  
configuration_variables 配置变量  
function_definitions 函数定义  
main_code 主程序代码  
</code></pre><p><strong>脚本调试：</strong></p>
<pre><code>检测脚本的语法错误：有时候报错的行数不是很精确，但是可在该行数附近找找错误
    bash -n &lt;脚本程序&gt;
跟踪调试命令的执行过程：    
    bash -x &lt;脚本程序&gt;
</code></pre><p><strong>脚本名字：</strong> 见名知义</p>
<pre><code>命名方法驼峰法
    小驼峰 studentName  第二个单词首字母大写
    大驼峰 StudentName  全部的单词首字母大写
</code></pre><p>bug：程序错误<br>debug：调试错误，解决错误</p>
<hr>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量：</strong> 代表一块内存空间，人为的命名  </p>
<pre><code>变量：任何一种编程语言都应该有变量，为程序提供数据
程序：是由指令加数据组成
    指令：由程序文件提供
    数据：IO设备、文件、管道、变量

程序也有另外一种说法：是由算法+数据结构来组成的

变量名：指向内存空间中某一段空间中的起始地址
变量名+指向的内存空间

变量赋值：name=value
变量类型：存储格式、表示数据范围、参与的运算
    用于编程语言：
        强类型变量：
        弱类型变量：
            bash中把所有变量都被视为字符型，不支持浮点数据
            bash中的变量无需事先声明，同时实现声明和赋值。
                声明的意思：说明变量类型，定义变量名称
变量替换：把变量名出现的位置替换为其所指向的内存空间中的数据
变量引用：$(变量名),$变量名        null视为空
变量命名法则：见名知义
    不能使用程序中的保留至：如if，for
    只能使用数字、字母、下划线，且不能以数字开头
    统一命名规则：驼峰法
        小驼峰studentName
        大驼峰StudentName
</code></pre><p><strong>bash进程：</strong>  bash子进程与bash父进程</p>
<pre><code>显示进程树
    pstree -p

查看bash父进 程编号
    echo $PPID

查看当前bash进程编号
    echo $$ 

开启bash子进程，脚本在子进程中运行，不影响环境变量
    bash &lt;脚本程序&gt; 

不开启bash子进程，执行脚本将影响环境变量
    source &lt;脚本程序&gt; 

()开启子进程执行命令，{}当前进程执行命令 
</code></pre><p><strong>bash中变量种类:</strong>  局部变量、环境变量、只读变量、位置变量</p>
<p>局部变量：当前进程使用</p>
<pre><code>生效范围在当前终端的shell进程中，若切换终端窗口，变量失效
</code></pre><p>   eg：name=xcb<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># name=xcb   //变量赋值</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $name  //当前终端窗取变量</span></span><br><span class="line">xcb         //当前终端窗口打印了xcb</span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $name  //新开终端窗口去变量</span></span><br><span class="line">            //新的终端窗口打印为空，变量失效</span><br><span class="line">[root@Souler7 ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>环境变量：可以传给子进程使用，但不可传给父进程  </p>
<pre><code>由bash内建的变量
    PATH  外部命令的搜索路径
    SHELL 当前使用的shell
    USER  用户名
    UID   用户ID
    HOME  用户家目录
    PWD   当前路径
    SHLVL 当前子进程嵌套数
    LANG  语言
    MAIL  邮箱路径
    HOSTNAME 主机名
    HISTSIZE 最大历史记录条数
    RANDOM  随机数
显示前一个命令的参数
    echo $_  
删除变量，但无法删除只读变量
    unset &lt;变量名&gt; 
将局部变量定义为环境变量
    exprot 

查看环境变量
    env 
    printenv
    export 
    declare -x
</code></pre><p> eg:RANDOM的使用<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># echo $[RANDOM%7]  表示对7取模，0-6随机数</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $[RANDOM%7+31]]  取31到37的随机数</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># color=$[RANDOM%7+31];echo -e "\e[1;$&#123;color&#125;mCLOOR\e[0m"    取随机颜色</span></span><br></pre></td></tr></table></figure></p>
<p>只读变量：不可删除</p>
<pre><code>声明只读变量
    declare -r
    readonly
查看只读变量
    readonly -p  
</code></pre><p>位置变量：灵活  </p>
<pre><code>$1,$2...: 对应第1、第2等参数，
    shift 每个数据往左移动1位，原先第一个数据被覆盖
    shift n 同理

$* 所有变量 例如：a b c 参数被视为一个字符串
$@ 所有变量 例如：a b c 每个参数是独立的字符串
    注意：$*与$@只有在被双引号抱起来的时候才会有差异，否则，为相同意思
$# 传递给脚本的参数个数
$0 显示命令本身，脚本所在路径
    basename $0 只显示脚本名称
set-- 清空所有位置变量
</code></pre><p>退出状态：特殊变量$?的使用  </p>
<pre><code>查看上一命令执行结果成功或失败
    echo $?
默认退出状态码    
    0 代表成功， 1-255 代表失败
自定义退出状态码
    exit [n]
</code></pre><p>注意：脚本中一旦遇到exit命令，脚本会立即终止，终止退出状态取决于exit命令后面的数字<br>注意：如果脚本未指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码</p>
<hr>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p><strong>bash中的算数运算：</strong>  仅支持整数运算</p>
<pre><code>bash中的算数运算：let
运算符号：+、-、*、/、%（取余）、**（乘方）
数字运算符号
        -eq 等于
        -ne 不等于
        -lt 小于
        -le 小于等于
        -gt 大于
        -ge 大于等于
</code></pre><p>方法1：let sum=a+b 默认是let，可不加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># a=2</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># b=3</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># let sum=a+b</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $sum</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>
<p>方法2：echo $[a*b] ，a=$[算术表达式]可用于逻辑运算<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    [root@Souler7 bin]<span class="comment"># a=2</span></span><br><span class="line">    [root@Souler7 bin]<span class="comment"># b=3</span></span><br><span class="line">    [root@Souler7 bin]<span class="comment"># echo $[a*b]</span></span><br><span class="line">    6</span><br><span class="line">```     </span><br><span class="line">方法3：<span class="built_in">echo</span> $((a-b))  ((a=10+11)) <span class="built_in">echo</span> <span class="variable">$a</span> 会显示a运算的值为21</span><br><span class="line">```bash</span><br><span class="line">    [root@Souler7 bin]<span class="comment"># a=2</span></span><br><span class="line">    [root@Souler7 bin]<span class="comment"># b=3</span></span><br><span class="line">    [root@Souler7 bin]<span class="comment"># echo $((a-b))</span></span><br><span class="line">    -1</span><br></pre></td></tr></table></figure></p>
<p>方法4：expr命令，专门做运算的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># expr 3 \* 3   (每个参数之间都需要空格，且*需要转义，+不用转义)</span></span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<p>方法5：declare -i (个人不推荐使用，给每个变量赋值都需要加declare -i)单独使用可用于查看变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># declare -i a=5</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># declare -i b=6</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># declare -i sum=$a*$b</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $sum</span></span><br><span class="line">30</span><br></pre></td></tr></table></figure></p>
<p>方法6：使用bc命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># echo 30/5|bc</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p><strong>赋值：</strong></p>
<p>增强型赋值：+=、-=、*=、/=、%=<br>eg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># let n=10</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $n </span></span><br><span class="line">10</span><br><span class="line">[root@Souler7 bin]<span class="comment"># let n+=10  (表示为n=n+10)</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $n  </span></span><br><span class="line">20</span><br></pre></td></tr></table></figure></p>
<p>自增自减：  </p>
<pre><code>let n++   表示为n=n+1,先赋值后加1
let n--   表示为n=n-1,同上
let ++n   表示为n=n+1，先加1后赋值
let --n   表示为n=n-1,同上
</code></pre><p>eg：<br>let m=n++, echo $m ,m=10<br>eg：<br>let m=++n, echo $m ,m=11</p>
<p><strong>逻辑运算：</strong></p>
<p>true or false：  </p>
<pre><code>true：1    //此处1表示真
false：0   //0表示假
</code></pre><p>与或非运算、异或运算：</p>
<p>与：符号&amp;表示与</p>
<pre><code>有0则为假
    1与1=1
    1与0=0
    0与1=0
    0与0=0
</code></pre><p>或：符号|表示或<br>    有1则为真<br>        1或1=1<br>        1或0=1<br>        0或1=1<br>        0或0=0<br>非：符号！表示非</p>
<pre><code>对结果取反
    ！1=0
    ！0=1
</code></pre><p>异或：符号^表示异或：</p>
<pre><code>异或的两个值，相同为假，不同为真
    1^1=0 假
    1^0=1 真
    0^1=1 真
    0^0=0 假               
存在公式：a^b=c,b=c^a,a=c^b
</code></pre><p>eg：判断a大于b是否为真，并使用逻辑取反<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># a=5</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># b=10</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ $a -gt $b ]   //判断逻辑运算是否为真</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $?</span></span><br><span class="line">1   //结果为假</span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ ! $a -gt $b ]  //对逻辑运算取反</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $?</span></span><br><span class="line">0   //取反后，结果为真</span><br></pre></td></tr></table></figure></p>
<p>eg：利用异或运算，互换a与b的值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># a=10</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># b=5</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># a=$[a^b]  //a此时拿到了中间值c</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># b=$[a^b]  //c与b异或且赋值给b，此时b得到了a的初始值10，b=10</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># a=$[a^b]  //c与b(a的初始值)异或,此时a的值为b的初始值5，a=5</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo a=$a b=$b </span></span><br><span class="line">a=5 b=10   //从该结果可看到实现了a与b的值互换</span><br></pre></td></tr></table></figure></p>
<p>短路运算：</p>
<pre><code>短路与：符号&amp;&amp;表示短路与
    cmd1 &amp;&amp; cmd2 若cmd1为true ，则执行cmd2
    cmd1 &amp;&amp; cmd2 若cmd1为false，则不执行cmd2
短路或：符号||表示短路或
    cmd1 || cmd2 若cmd1为ture ，则不执行cmd2
    cmd1 || cmd2 若cmd1为false，则执行cmd2
组合使用：    
    如果cmd1成功，就执行cmd2，如果cmd2成功(此处假设cmd2总成功)，就执行cmd3
        cmd1 &amp;&amp; cmd2 || cmd3
    如果cmd1失败，就执行cmd2，如果cmd2成功(此处假设cmd2总成功)，就执行cmd3
        cmd1 || cmd2 &amp;&amp; cmd3
</code></pre><hr>
<h2 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h2><p><strong>描述：</strong><br>判断某需求是否满足，需要由测试机制来实现  </p>
<pre><code>专用的测试表达式需要由测试命令辅助完成测试过程
</code></pre><p>评估布尔声明，以便用在条件性执行中  </p>
<pre><code>若真，则返回0
若假，则返回1

注意：此处的0、1不同于逻辑运算中的0、1
</code></pre><p><strong>测试命令：</strong> test命令</p>
<pre><code>三种用法：
    test EXPRESSION
    [ EXPRESSION ]
    [[ EXPRESSION ]]
注意：[ ]内有字符即为真，无字符则为假，空格也算字符
</code></pre><p>用法1：test EXPRESSION  (不常用)<br>eg：判断a是否小于b<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># a=5</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># b=10</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># test $a -lt $b</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $? //查看结果</span></span><br><span class="line">0     //结果为真,故a小于b</span><br><span class="line">[root@Souler7 bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>用法2：[ EXPRESSION ]</p>
<pre><code>选项：
    用于文件类型测试：
        [ -a &quot;文件路径&quot; ] 判断文件的存在性，存在为真，不存在为假
        [ -b &quot;文件路径&quot; ] 判断文件是否为 块设备，存在为真，不存在为假
        [ -c &quot;文件路径&quot; ] 判断文件是否为字符设备，存在为真，不存在为假
        [ -d &quot;文件路径&quot; ] 判断文件是否为文件夹，是为真，否为假
        [ -f &quot;文件路径&quot; ] 判断文件是否为普通文件，是为真，否为假
            -f无法识别软链接，而是直接识别软链接所指向的文件
        [ -L &quot;文件路径&quot; ] 判断文件是否为软链接，是为真，否为假
            -L针对判断软链接
    用于文件权限测试：
        [ -u &quot;文件路径&quot; ] 判断文件是否为有suid权限，是为真，否为假
        [ -g &quot;文件路径&quot; ] 判断文件是否为有sgid权限，是为真，否为假
        [ -k &quot;文件路径&quot; ] 判断文件是否为有sticky权限，是为真，否为假
        [ -r &quot;文件路径&quot; ] 判断对文件是否为有r权限，是为真，否为假
        [ -w &quot;文件路径&quot; ] 判断对文件是否为有w权限，是为真，否为假
        [ -x &quot;文件路径&quot; ] 判断对文件是否为有x权限，是为真，否为假
    用于文件大小测试：
        [ -s &quot;文件路径&quot; ] 判断对文件是否存在且非空，是为真，否为假
    用于测试文件是否打开：
        [ -t fd ] 判断文件描述符是否在某终端已经打开，是为真，否为假
        [ -N &quot;文件路径&quot; ] 判断文件从上一次被读取之后是否被修改过，是为真，否为假
        [ -O &quot;文件路径&quot; ] 判断对文件属主是否为当前登录用户，是为真，否为假
        [ -G &quot;文件路径&quot; ] 判断对文件属组是否为当前登录用户，是为真，否为假
    双目测试：
        [ &quot;文件1&quot; -ef &quot;文件2&quot; ] 判断文件1是否为文件2的硬链接，是为真，否为假
        [ &quot;文件1&quot; -nt &quot;文件2&quot; ] 判断文件1是否比文件2新，是为真，否为假
        [ &quot;文件1&quot; -ef &quot;文件2&quot; ] 判断文件1是否比文件2旧，是为真，否为假
    同时判断多个条件，
        用-a来实现，表示与的关系
        用-o来实现，表示或的关系
        用！来实现，表示非,取反的关系
</code></pre><p>eg：判断a是否小于b<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># a=5</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># b=10</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ $a -lt $b ]</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># echo $? //查看结果</span></span><br><span class="line">0     //结果为真,故a小于b</span><br><span class="line">[root@Souler7 bin]<span class="comment">#</span></span><br></pre></td></tr></table></figure></p>
<p>eg：判断字符串是否相等,以及使用双引号””，避免出现语法错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 bin]<span class="comment"># name=xcb   //变量赋值xcb   </span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># i=xcb      //变量赋值xcb</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ name = i ] &amp;&amp; echo ture || echo false  //语法错误，变量名前没有加$符号</span></span><br><span class="line"><span class="literal">false</span>   //此判断不成立</span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "$name" = "$i" ] &amp;&amp; echo ture || echo false //加上$再次判断</span></span><br><span class="line"><span class="literal">true</span>    //name=i，结果为真,输出<span class="literal">true</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># i=xxx    //对i赋一个新的值xxx</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "$name" = "$i" ] &amp;&amp; echo ture || echo false //判断变量name字符串是否等于变量i的字符串</span></span><br><span class="line"><span class="literal">false</span>  //name≠i，结果为假，输出<span class="literal">false</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "$name" = "xcb" ] &amp;&amp; echo ture || echo false //判断变量name的字符串是否为xcb</span></span><br><span class="line"><span class="literal">true</span>  //name=xcb，结果为真，输出<span class="literal">true</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ $name = xxx ] &amp;&amp; echo ture || echo false  //判断变量n的字符串是否为xxx</span></span><br><span class="line"><span class="literal">false</span>  //name≠xxx，结果为假，输出<span class="literal">false</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># unset name  //删除变量name</span></span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ $name = xcb ] &amp;&amp; echo ture || echo false //当变量不存在，且变量名没有用双引号引起来，进行判断</span></span><br><span class="line">-bash: [: =: unary operator expected // 此处提示语法错误</span><br><span class="line"><span class="literal">false</span>  //此判断不成立</span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "$name" = xcb ] &amp;&amp; echo ture || echo false //当变量不存在，且变量名加了双引号，进行判断</span></span><br><span class="line"><span class="literal">false</span>  //此处没有提示语法错误，而是把引号内的变量名作为空字符，进行判断，结果为假</span><br><span class="line">[root@Souler7 bin]<span class="comment"># [ "" = xcb ] &amp;&amp; echo ture || echo false     </span></span><br><span class="line"><span class="literal">false</span>  //此处的结果，等同上一句的意思，亦可得出结论：加双引号可避免出现语法错误</span><br></pre></td></tr></table></figure></p>
<p>eg：判断变量是否为空，-z，-n的使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># name=xcb  //变量赋值</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $name</span></span><br><span class="line">xcb</span><br><span class="line">[root@Souler7 ~]<span class="comment"># [ -z "$name" ] &amp;&amp; echo true ||echo false //判断变量是否为空，空为true，非空为false</span></span><br><span class="line"><span class="literal">false</span> //变量非空，结果为<span class="literal">false</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># [ -n "$name" ] &amp;&amp; echo true ||echo false //判断变量是否非空，空为false，非空为true</span></span><br><span class="line"><span class="literal">true</span>  //变量非空</span><br><span class="line">[root@Souler7 ~]<span class="comment"># unset name //删除变量</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># [ -z "$name" ] &amp;&amp; echo true ||echo false //判断变量是否为空，空为true，非空为false</span></span><br><span class="line"><span class="literal">true</span> //变量为空，结果为<span class="literal">true</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># [ -n "$name" ] &amp;&amp; echo true ||echo false //判断变量是否非空，空为false，非空为true</span></span><br><span class="line"><span class="literal">false</span> //变量为空，结果为<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>用法3：[[ EXPRESSION ]] 支持扩展正则表达式，=~引用正则表达式，变量用双引号引起来，扩展正则表达式不需要加引号</p>
<pre><code>[[ =~ ]] 支持扩展正则模式
[[ == ]] 支持通配符
[[ != ]] 表示取反
</code></pre><p>eg：使用扩展正则表达式，判断变量是否符合要求<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 bin]<span class="comment"># file=abc.sh        </span></span><br><span class="line">[root@Souler6 bin]<span class="comment"># [[ $file =~ \.sh$ ]] &amp;&amp; echo true || echo false //判断变量是否为.sh结尾的字符串</span></span><br><span class="line"><span class="literal">true</span>   //变量条件符合，结果为真</span><br><span class="line">[root@Souler6 bin]<span class="comment"># [[ $file =~ \.s$ ]] &amp;&amp; echo true || echo false  //判断变量是否为.s结尾的字符串</span></span><br><span class="line"><span class="literal">false</span>  //变量条件不符合，结果为假</span><br></pre></td></tr></table></figure></p>
<p>eg：判断输出的数字是否为合法IP地址<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 bin]<span class="comment"># ip=1.1.1.1; [[ "$ip" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2[0-5][0-5])\.)&#123;3&#125;([1-9]?[0-9]|1[0-9][0-9]|2[0-5][0-5])$ ]] &amp;&amp; echo ip right || echo ip error  </span></span><br><span class="line">ip right  //ip符合</span><br><span class="line">[root@Souler6 bin]<span class="comment"># ip=111.111.111.1111; [[ "$ip" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2[0-5][0-5])\.)&#123;3&#125;([1-9]?[0-9]|1[0-9][0-9]|2[0-5][0-5])$ ]] &amp;&amp; echo ip right || echo ip error  </span></span><br><span class="line">ip error  //ip不符合</span><br></pre></td></tr></table></figure></p>
<p>注意：EXPRESSION前后必须有空白字符  </p>
<hr>
<h2 id="配置用户环境"><a href="#配置用户环境" class="headerlink" title="配置用户环境"></a>配置用户环境</h2><p><strong>bash的配置文件:</strong> 按生效范围划分，存在两类：</p>
<pre><code>全局配置：
    /etc/profile
    /etc/profile.d/*.sh
    /etc/bashrc
个人配置：
    ~/.bashrc
    ~/.bash_profile
</code></pre><p><strong>shell登录的两种方式：</strong></p>
<p>交互式登录：</p>
<pre><code>1.通过终端输入账号密码登录
2.使用su - username 切换的用户
    配置文件的生效顺序：
        1--&gt;/etc/profile
        2--&gt;/etc/profile.d/*.sh
        3--&gt;~/.bash_profile
        4--&gt;~/.bashrc
        5--&gt;/etc/bashrc
</code></pre><p>非交互式登录:</p>
<pre><code>1.su username
2.图形界面打开的终端
3.执行脚本       
4.任何其他的bash实例
    配置文件的生效顺序：
        1--&gt;~/.bashrc
        2--&gt;/etc/bashrc
        3--&gt;/etc/profile.d/*.sh
</code></pre><p><strong>类：</strong></p>
<p>profile类:为交互式登录的shell提供配置</p>
<pre><code>全局配置：
    /etc/profile
    /etc/profile.d/*.sh
个人配置：
    ~/.bash_profile
        实现环境变量和函数启动程序的文件

功用：
    用于定义环境变量
    运行命令或脚本
</code></pre><p>bashrcl类：为非交互式和交互式登录的shell提供配置</p>
<pre><code>全局设置:
    /etc/bashrc
个人设置：
    ~/.bashrc
        实现别名和函数的文件
功用：
    定义命令别名和函数
    定义本地变量
</code></pre><p><strong>编辑配置文件生效：</strong></p>
<pre><code>修改profile和bashrc文件后需生效
    两种方法：
        重启
        source或.
    eg：. ~/.bashrc
</code></pre><p><strong>bash退出任务:</strong></p>
<pre><code>~/.bash_logout文件：用于自动备份，删除临时文件

用户退出登录shell时，自动执行

在/etc/目录下创建nologin文件，可禁止普通用户登录
</code></pre><hr>
<p><strong>关于bash如何展开命令行</strong>  (此处并不能很好的诠释，见谅..)</p>
<pre><code>把命令行分成单个命令词
展开别名
展开大括号的声明{}
展开波浪符声明~
命令替换$()和``
再次把命令行分成命令词
展开文件通配*、？、[abc]
准备I/O重定向&lt;、&gt;
运行命令
</code></pre><p>防止扩展：  </p>
<pre><code>加引号
    双引号&quot;&quot;防止部分扩展(本人目前还未搞懂..)
    单引号&apos;&apos;防止所有扩展
    反斜杆 \防止所有扩展
</code></pre><p>eg：反斜杆 \,转义符，单引号’’也能防止所有扩展，除了’本身，双引号则行不通<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># name=xcb</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $name</span></span><br><span class="line">xcb</span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo \$name  //此处转义，$name只当为普通字符串</span></span><br><span class="line"><span class="variable">$name</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo '$name'  //此处''转义</span></span><br><span class="line"><span class="variable">$name</span></span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo "$name"</span></span><br><span class="line">xcb</span><br></pre></td></tr></table></figure></p>
<p><strong>read命令：</strong> 把输入值分配给一个或多个shell变量常用于脚本</p>
<pre><code>选项： 
    -p        指定要显示的提示
    -s        静默输入，一般用于密码
    -n        N指定输出的字符长度N，达到字符长度自动退出
    -d &apos;字符&apos; 指定输入字符为结束符，结束符出现立即退出
    -t n      等待n秒，时间到自动退出
对多个变量赋值
    read x y z &lt;&lt;&lt; &quot;aaa bbb ccc&quot;
</code></pre><p>eg：read -p用法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># read -p "Please input your name:" -t 30 xcb //定义变量名称为xcb，且该命令执行后等待输入</span></span><br><span class="line">Please input your name:xucanbin   //此处输入字符串xucanbin并自动赋值给变量xcb</span><br><span class="line">[root@Souler7 ~]<span class="comment"># echo $xcb   //打印变量xcb的值</span></span><br><span class="line">xucanbin    //显示为xcb的值为xucanbin</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/05/第三周-shell脚本编程基础知识/" data-id="cjkgkimqx00061oisqspibep8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第三周-文本处理工具和正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/01/第三周-文本处理工具和正则表达式/" class="article-date">
  <time datetime="2018-08-01T08:00:00.000Z" itemprop="datePublished">2018-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/01/第三周-文本处理工具和正则表达式/">文本处理工具和正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="文本处理工具"><a href="#文本处理工具" class="headerlink" title="文本处理工具"></a>文本处理工具</h1><p><strong>抽取文本的工具</strong></p>
<p>cat命令：用于查看文本  </p>
<pre><code>选项
-A 查看隐藏符号,控制符
-n 显示行号
-b 忽略空行显示行号
-s 合并空行
-E 显示回车结束符$
</code></pre><p>less命令：用于查看文本，支持文本分页和翻页显示(man帮助中的翻页功能用的就是less)</p>
<pre><code>使用空格翻页，翻到底部不会退出文本
/ 搜索 同man搜索
(man帮助中的翻页以及搜索功能用的就是less命令)
</code></pre><p>more命令：用于查看文本，支持文本分页和翻页显示</p>
<pre><code>使用空格翻页，翻到底部自动退出文本
</code></pre><p>tac命令：用于查看文本</p>
<pre><code>将文本纵向倒着显示
</code></pre><p>rev命令：用于查看文本</p>
<pre><code>将文本横向倒着显示
</code></pre><p><strong>显示文件内容的头或者尾</strong></p>
<p>head命令：查看文本首部，不加选项默认前10行</p>
<pre><code>选项：
    -n # 行数
    -c # 字节数
eg:显示前5行
    head 1.txt -n 5
</code></pre><p>tail命令：查看文本末尾，不加选项默认后10行</p>
<pre><code>选项：
    -n # 行数
    -c # 字节数
    -f 跟踪文件
    -F 跟踪文件名
eg：显示最后5行
        tail 1.txt -n 5
    跟踪文件内容，即时文件被删除，依旧继续跟踪
        tail -f 1.txt
    跟踪文件名，当文件被删除时，不再跟踪文件内容，并提示用户
        tail -F 1.txt
(tailf命令 跟踪文件，内容不增长则不继续跟踪，虽然已是等同于tail -f但是效率更高）
</code></pre><p><strong>按列抽取文本</strong></p>
<p>cut命令：将文本切割为列并取出指定列</p>
<pre><code>选项：
    -d分隔符 指明分隔符
    -f：取字段
        #    取指定的第n个字段
        #,# 取离散的指定字段
        #-# 取连续的指定字段
    -c# 取字节数
    --output-delimiter=&lt;&gt;指定输出分隔符 取出信息并指定输出分隔符
</code></pre><p><strong>合并文件</strong></p>
<p>paste命令：合并文本内容 </p>
<pre><code>用法：
    paste file1 file2
    paste f1 f2&gt;f3
选项：
    -s 合成一行
    -d 
    分隔符
</code></pre><p><strong>分析文本的工具</strong></p>
<p>wc命令（word count）：用于统计行数，单词数，字节数</p>
<pre><code>选项：
    -l 行数
    -w 单词数
    -c 字节数
    -m 字符数
字典：/usr/share/dict/linux.words
eg：统计字典中的单词数
    wc -w /usr/share/dict/linux.words
</code></pre><p>sort命令：用于排序，去重，不修改文件原内容（待添加eg）</p>
<pre><code>选项：
    -t  分隔符
    -k  取第几列
    -n  按数字排序
    -r  倒序
    -u  去重
    -R  随机排序
eg：
</code></pre><p>uniq命令：合并相邻的重复行 （待添加eg）</p>
<pre><code>选项：
    -c 显示重复的次数
    -u 去重复的行数
    -d 只要重复的行数
eg：
</code></pre><p>diff命令：查看文件的不同之处（待分析）</p>
<pre><code>用法：
    diff f1 f2
    diff f1 f2 &gt; diff.log 生成补丁
选项：
    -u 详细
    patch命令：补丁
        patch f1 diff.log
            选项：
                -b    备份
</code></pre><hr>
<h1 id="文本处理三剑客之一：grep"><a href="#文本处理三剑客之一：grep" class="headerlink" title="文本处理三剑客之一：grep"></a>文本处理三剑客之一：grep</h1><p>（Global search REgular expression an Print out the line）</p>
<p>grep命令：文本过滤工具，主要是过滤‘行’ （待添加eg）</p>
<pre><code>用法：
    grep [选项] [模式] file
        模式：指的是正则表达式的提出过滤条件
选项：
    -v 取反
    -i 忽略大小写
    -n 显示行号
    -c 显示有多少行含有关键词
    -o 打印关键词
    -q 静默
        echo $? 显示0或1（多用于编脚本）
    -A 搜索结果的后三行
    -B 搜索结果的前三行
    -C 搜索结果的前三行和后三行
    -e 搜索多个关键字
    -w 匹配单词
    -E 扩展表达式，等同egrep
    -F 不支持正则表达式
    -f （不理解）
</code></pre><p><strong>正则表达式</strong><br>使用特殊字符编写模式，配合grep命令匹配文本中的字符串</p>
<p>正则表达式有两类：BRE、ERE</p>
<ol>
<li><p>基本正则表达式:BRE</p>
<pre><code>元字符匹配：
    .    匹配一个任意字符
    []   匹配指定范围
    [^]  匹配指定范围外，就是将[]取反
    [:alnum:] 字母和数字
    [:alpha:] 任意大小写字母
    [:lower:] 任意小写字母
    [:upper:] 任意大写字母
    [:space:] 空格符
    [:digit:] 任意数字
    [:punct:] 标点符号
    [:print:] 可打印字符 （不常用） 
    [:cntrl:] 不可打印的控制字符（退格、删除）
    [:graph:] 可打印的非空白字符

匹配次数：
    *    匹配*前字符出现任意次包括0次，贪婪模式
    \?   匹配字符出现一次或者零次，懒惰模式
    \+   匹配字符至少出现一次
    \{n\}    匹配字符出现n次
    \{n,\}   匹配字符至少出现n次
    \{,n\}   匹配字符至多出现n次
    \{m,n\}  匹配字符至少m次，至多n次

位置锚定
    ^  锚定行首&lt;^关键词&gt;
    $  锚定行尾&lt;关键词$&gt;
    \&gt; 词尾锚定 
    \&lt; 词首锚定 
    \&lt;关键词\&gt; 匹配整个单词，等同 &apos;\b关键词\b&apos;
    eg：
        ^[[:space:]]*$  匹配0次或者任意次空格字符，即空行,等同^$
        ^[[:space:]]\+.*$ 匹配至少一个空格字符，用于行首带空格的非空白行

分组
    \(关键词\) 表示整体
    \|  表示或
    \1  表示第一个括号，匹配最终结果    
    \2  表示第二个括号
</code></pre></li>
</ol>
<ol start="2">
<li><p>扩展正则表达式:ERE</p>
<pre><code>字符匹配:同基本正则,故不再说明

匹配次数：
    * 匹配前面字符出现任意次
    ? 匹配前面字符出现0或1次  #对比基本正则少了&apos;\&apos;
    + 匹配前面字符至少出现一次 #对比基本正则少了&apos;\&apos;
    {n}   匹配前面字符出现n次 #对比基本正则少了&apos;\&apos;
    {n,}  匹配前面字符至少出现n次 #对比基本正则少了&apos;\&apos;
    {,n}  匹配前面字符至多出现n次 #对比基本正则少了&apos;\&apos;
    {n,m} 匹配前面字符至少出现n次，至多出现m次 #对比基本正则少了&apos;\&apos;

位置锚定:同基本正则，故不再说明

分组：
    () 表示整体 #对比基本正则少了&apos;\&apos;
    |  表示或   #对比基本正则少了&apos;\&apos;
    再次引用定义的分组结果
        \1,\2,\3
    eg:
</code></pre></li>
</ol>
<p>练习：<br>1、利用扩展正则表达式分别表示0-9、10-99、100-199、200-249、250-255  </p>
<pre><code>答：seq 0 255 &gt; num.txt #创建一个包含了0 - 255的文本  
分别表示
    0-9: grep -E -w &quot;^[0-9]&quot; num.txt  
  10-99: grep -E -w &quot;((^[1-9])[0-9])&quot; num.txt  
100-199: grep -E -w &quot;^1([0-9]{2})&quot; num.txt  
200-249: grep -E -w &quot;^2[0-4][[:digit:]]&quot; num.txt  
250-255: grep -E -w &quot;^2[5][0-5]&quot; num.txt  
</code></pre><p>2、显示ifconfig命令结果中所有IPv4地址  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：[root@Souler7 ~]<span class="comment"># ifconfig |grep -w -E "inet" |tr -s " "|cut -d" " -f3</span></span><br></pre></td></tr></table></figure>
<p>3、将此字符串：welcome to magedu linux 中的每个字符去重并排序，重复次数多的排到前面<br>    答：  </p>
<pre><code class="bash">[root@Souler7 ~]<span class="comment"># echo welcome to magedu linux|grep -Eo "[[:alpha:][:space:]]"|sort|uniq -c|sort -nr</span>
</code></pre>
<pre><code>其他编辑器：
    gedit 简单的图形编辑器
    gvim  vim图形版本
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/01/第三周-文本处理工具和正则表达式/" data-id="cjkgkimq200001ois2ob764uv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第二周-用户和组的管理以及权限管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/29/第二周-用户和组的管理以及权限管理/" class="article-date">
  <time datetime="2018-07-29T12:00:00.000Z" itemprop="datePublished">2018-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/29/第二周-用户和组的管理以及权限管理/">用户和组的管理以及权限管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="DAY-6"><a href="#DAY-6" class="headerlink" title="DAY 6"></a>DAY 6</h1><hr>
<h1 id="linux的安全模型、用户账号以及用户组的介绍"><a href="#linux的安全模型、用户账号以及用户组的介绍" class="headerlink" title="linux的安全模型、用户账号以及用户组的介绍"></a>linux的安全模型、用户账号以及用户组的介绍</h1><p><strong>介绍安全3A</strong></p>
<pre><code>资源分派：
    Authentication：认证
    Authorization：授权
    Accouting|Audition：审计
</code></pre><p><strong>用户user</strong></p>
<pre><code>令牌token,identity
Linux用户：Username/UID
管理员：root, 0
普通用户：1-60000 自动分配
    系统用户：1-499, 1-999（CentOS7）
        对守护进程获取资源进行权限分配
登录用户：500+, 1000+（CentOS7）
    交互式登录
</code></pre><p><strong>组group</strong></p>
<pre><code>Linux组：Groupname/GID
管理员组：root, 0
普通组：
    系统组：1-499, 1-999（CENTOS7）
    普通组：500+, 1000+（CENTOS7）
</code></pre><p><strong>安全上下文</strong></p>
<pre><code>Linux安全上下文
    运行中的程序：进程(process)
    以进程发起者的身份运行：
        root: /bin/cat
        mage: /bin/cat
进程所能够访问资源的权限取决于进程的运行者的身份
</code></pre><p><strong>组的类别</strong></p>
<pre><code>Linux组的类别
    用户的主要组(primary group)
        用户必须属于一个且只有一个主组组名同用户名，且仅包含一个用户，私有组
    用户的附加组(supplementary group)
        一个用户可以属于零个或多个辅助组
</code></pre><p><strong>关于ps aux</strong></p>
<pre><code>许多进程在系统启动了就已经自动运行，这些进程属于系统用户，非人使用的。        
    系统用户使用的shell类型为/bin/nologin，
</code></pre><h1 id="用户和组的管理"><a href="#用户和组的管理" class="headerlink" title="用户和组的管理"></a>用户和组的管理</h1><p><strong>关于用户和组的一些关键文件</strong></p>
<pre><code>/etc/passwd  存放用户信息
    eg: xu:x:1000:1000:xu,can,bin,13048973251:/home/xu:/bin/bash
    对应格式: 用户名：口令：uid：gid：用户信息注释：家目录：shell类型

/etc/shadow  存放用户口令
    eg：xu:$6$./CWkeEIb89Q$mmkk1xypAQ1vLXkAQZENBGI8dtXmflwU0npV4UaMhB7BI2hGmHtQFNYvz30BkY7sRaYvyq1tIblxH/lZi4CAO.:17741:0:99999:7:::
    对应格式：用户名：口令：口令创建日期：口令最短有效期：密码有效期：密码过期前几天提示：密码过期后的宽限期：账户的有效期：保留未使用

        shadow文件格式，shadow中8个冒号隔成9个字段

        第一段 用户登录名
        第二段 加密口令很长
            （！！表示加锁） 
            sha512加密算法512位 $1:md5加密算法（已被破解）
            $6:sha512加密算法（！！表示加锁）
            算法的后面会加$（salt）$ 称为salt盐
            salt盐 不一样
            王小云：破解md5，sha1
            /etc/login.defs 用户口令相关文件，存放了默认的加密算法
            更改算法：
            authconfig --passalgo=sha256 --update
        第三段
            上一次口令更改时间天数（以1970位参考，）
        第四段
            更换密码所需时间间隔（例如，3，则表示每更换一次密码后，想再次更改密码需要等待3天才能更换密码）
        第五段
            密码有效期
        第六段
            密码过期的前几天会提示你更换密码
        第七段
            密码过期后的宽限期
        第八段
            账户的有效期
            chage &lt;用户名&gt; 
            可以更改指定用户的shadow中第3段到第8段的信息
        第九段
            保留未使用


/etc/group   存放组信息
    eg：xu:x:1000:xu
    对应格式：组名：口令：组id：该组作为附加组时的成员

/etc/gshadow 存放组口令
    eg：xu:$6$V63Bs/1moqF/$GqgjT3Nj8bBSW4xxF0IAn7MCdf2ClS8fZLPOwSJ5n8M8X.MXKgY1GoTNFbTyw8da0kN5wtKZrnC6bSvW3YMf//::
    对应格式：组名：口令：组管理员列表：以当前组为附加组的用户列表

/etc/default/useradd
    该文件存放了用户口令相关文件，该文件中定义了创建新用户的默认配置
        [root@Souler7 ~]# useradd -D
        GROUP=100
        HOME=/home  #默认家目录创建路径
        INACTIVE=-1  #口令过期后，默认不锁定
        EXPIRE=   #有效期
        SHELL=/bin/bash #默认shell
        SKEL=/etc/skel  #新建家目录的模板，都是隐藏文件
        CREATE_MAIL_SPOOL=yes  #默认创建邮箱
    列出/etc/default/useradd的内容
        useradd -D
        useradd -D=cat /etc/default/useradd

/etc/login.defs
    该文件最后两行配置了了口令的加密算法
    eg：# Use SHA512 to encrypt password.
        ENCRYPT_METHOD SHA512
/etc/skel/ -a
    该文件是存放了家目录的模板文件
        [root@Souler7 ~]# ll -a /etc/skel/
        total 24
        drwxr-xr-x.   3 root root   78 Apr 11 12:59 .
        drwxr-xr-x. 139 root root 8192 Jul 29 16:05 ..
        -rw-r--r--.   1 root root   18 Apr 11 08:53 .bash_logout
        -rw-r--r--.   1 root root  193 Apr 11 08:53 .bash_profile
        -rw-r--r--.   1 root root  231 Apr 11 08:53 .bashrc
        drwxr-xr-x.   4 root root   39 Jul 18 14:47 .mozilla
</code></pre><p><strong>关于getent</strong></p>
<pre><code>列出/etc/passwd的内容
    getent passwd
    getent passwd=cat /etc/passwd  
    getent passwd &lt;username&gt; 查看指定用户的passwd信息

列出/etc/shadow的内容
    getent shadow
    getent shadow=cat /etc/shadow
    getent shadow &lt;username&gt; 查看指定用户的shadow信息

列出/etc/group的内容
    getent group
    getent group=cat /etc/group
    getent group &lt;username&gt; 查看指定组的group信息

列出/etc/gshadow的内容
    getent gshadow
    getent gshadow=cat /etc/gshadow
    getent gshadow &lt;username&gt; 查看指定的gshadow信息
</code></pre><p><strong>关于用户的创建和管理</strong><br>（常用与给系统服务创建账号）</p>
<pre><code>useradd命令： 用于创建用户
    useradd = adduser
    useradd -D =cat /etc/default/useradd
    （rpm -q -scripts postfix 查看useradd的常用格式）
    选项：
        useradd -d &lt;路径&gt;      指定家目录
        useradd -M             不创建家目录
        useradd -g &lt;groupname&gt; 指定主组
        useradd -G &lt;groupname&gt; 附加组
        useradd -c &quot;注释&quot;       用户的注释信息
        useradd -s shell       指定使用shell类型，不指定默认使用/bin/bash
        useradd -r             创建系统，创建目录默认不创建家目录
        useradd -u &lt;uid&gt;       指定uid
        useradd -N             自动加入users组
        useradd -o &lt;uid&gt;       避免同id冲突

usermod命令：用于修改用户属性（不常用）
    选项：
        usermod -G 组 用户     增加附加组，且覆盖已有附加组
        usermod -aG 组 用户    追加附加组
        usermod -G &quot;&quot; 用户     清除所有附加组
        usermod -L 用户        给用户加锁
        usermod -U 用户        给用户解锁

userdel命令：用于删除用户
    userdel &lt;用户&gt;    删除用户
    选项：
        userdel -r &lt;用户&gt; 删除用户及其家目录

用户相关的其他命令

    chfn命令（修改用户的描述信息）
        用法：
        chfn &lt;用户&gt;修改指定用户描述信息，不指定用户名则默认修改当前用户的描述信息

    finger命令（查看用户的描述信息，需自行安装，否则无效）
        用法：
        finger &lt;用户&gt; 查看指定用户描述信息

    chsh命令（修改用户shell类型）
        用法：
        chsh -s shell &lt;用户&gt; 更改用户的shell类型
</code></pre><p><strong>关于用户口令</strong></p>
<pre><code>passwd命令：用与更改用户口令
    选项：            
        passwd -l &lt;用户&gt; 双重锁               类似：usermod -L &lt;用户&gt; 单锁
        passwd -u &lt;用户&gt; 解双重锁             类似：usermod -U &lt;用户&gt; 解单锁
        passwd -d &lt;用户&gt; 清空用户口令
        passwd -e &lt;用户&gt; 强制下次登录，提示用户改口令（常用）
        passwd -f &lt;用户&gt; 强制操作

批量改口令（多用于写程序时的命令）
    echo 密码 | passwd --stdin 用户名（常用）

chage命令（更改shadow）
    选项：
        chage &lt;用户&gt;    交互式更改指定用户密码策略
        chage -l &lt;用户&gt; 查看指定用户密码策略
        chage -d 0 &lt;用户&gt; 指定用户口令立即过期
</code></pre><p><strong>关于用户组的创建和管理</strong></p>
<pre><code>groupadd命令：用于创建组
    选项：
        groupadd -g &lt;gid&gt; &lt;groupname&gt; 创建指定id号的用户组
            系统用户id默认设置
            centos6&lt;500
            centos7&lt;1000
        groupadd -r &lt;groupname&gt; 创建指定系统用户组

groupmod命令：用于修改组属性
    选项：
        groupmod -n &lt;new_name&gt; &lt;groupname&gt; 更改用户组名
        groupmod -g &lt;new_id&gt; &lt;groupname&gt;   更改用户组id

groupdel命令：用于删除组
    groupdel &lt;groupname&gt;  删除用户组
    选项：
        groupdel -R
    注意：主组不能删，附加组可以

groupmems命令：用于更改和查看组成员
选项：
    groupmems -g &lt;group&gt;   更改为指定组(只有root)
配合-g使用的参数：
    groupmems -g &lt;group&gt; -a &lt;user&gt;  指定用户加入组
    groupmems -g &lt;group&gt; -d &lt;user&gt;  从组中删除用户
    groupmems -g &lt;group&gt; -p         从组中清除所有成员
    groupmems -g &lt;group&gt; -l         显示组成员列表

groups命令：用于查看组成员
    groups[OPTION].[USERNAME]... 查看用户所属组列表
</code></pre><p><strong>关于组密码</strong></p>
<pre><code>gpasswd命令：用于更改组密码 
    gpasswd &lt;group&gt; 更改组的密码
    选项：
        gpasswd -a &lt;用户&gt; &lt;组&gt; ，将用户添加至指定组中
        gpasswd -d &lt;用户&gt; &lt;组&gt; ，从指定组中移除用户
</code></pre><p><strong>查看用户相关的id信息以及切换用户</strong></p>
<pre><code>id命令：用于判断用户的存在性
    id &lt;用户&gt; 显示uid，gid，属组和附加组
    uid=0(root) gid=0(root) groups=0(root)
    选项：
        id -n &lt;用户&gt; 显示名字
        id -g &lt;用户&gt; 显示组id
        id -u &lt;用户&gt; 显示uid
        id -G &lt;用户&gt; 显示附加组id，全部组

su命令（switch user）：用于切换账号，普通用户需要口令
    su &lt;用户&gt; 切换用户，环境没变
    su - &lt;用户&gt;  相当于重新登录，环境改变
    su - &lt;用户&gt; -c &quot;command&quot; 切换用户，且执行命令后退出 
    尽量不要多次切换
</code></pre><p><strong>检查</strong></p>
<pre><code>pwck 检查用户
grpck 检查组
</code></pre><h1 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h1><pre><code>给用户添加附加组的办法:

    usermod -aG &lt;组&gt; &lt;用户&gt;
    gpasswd -a &lt;用户&gt; &lt;组&gt;
    groupmems -a &lt;用户&gt; -g &lt;组&gt;

解锁：

    usermod -L &lt;用户&gt; 单锁
    usermod -U &lt;用户&gt; 解单锁
    passwd -l &lt;用户&gt; 双重锁
    passwd -u &lt;用户&gt; 解双重锁

更变用户属组:

    usermod -g &lt;组&gt; &lt;用户&gt;

临时切换用户属组:

    newgrp &lt;组&gt; 临时加入且更换主组

更改附加组：

    手动更改文件：
        更改附加组时，group与gshadow最后一个字段必须一模一样
    使用命令更改附加组
    usermod -G &lt;组&gt; &lt;用户名&gt;       给用户添加附加组
    groupmems -g &lt;组&gt; -a &lt;用户名&gt;  给用户添加附加组
    gpasswd -a &lt;用户名&gt; &lt;组&gt;       给用户添加附加组

newusers（作用待实验）

chpasswd命令：更改密码，用法如下：用户名：密码

    [root@Souler7 ~]# chpasswd 
     xu:123456
</code></pre><hr>
<h1 id="文件权限：读read、写wirte、执行excute，简称rwx"><a href="#文件权限：读read、写wirte、执行excute，简称rwx" class="headerlink" title="文件权限：读read、写wirte、执行excute，简称rwx"></a>文件权限：读read、写wirte、执行excute，简称rwx</h1><p><strong>文件属性：</strong></p>
<pre><code>eg:
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler7 ~]<span class="comment"># ls -i xcb.log</span></span><br><span class="line">-rw-r--r-- 1 root root 100 Jul 18 15:08 xcb.log</span><br><span class="line"></span><br><span class="line">对应关系如下：</span><br><span class="line">-rw-r--r--   --&gt;权限</span><br><span class="line">1            --&gt;引用计数</span><br><span class="line">root         --&gt;所属组</span><br><span class="line">root         --&gt;所有者</span><br><span class="line">100          --&gt;文件大小</span><br><span class="line">Jul 18 15:08 --&gt;创建时间</span><br><span class="line">xcb.log      --&gt;文件名</span><br></pre></td></tr></table></figure>
</code></pre><p><strong>权限管理：</strong></p>
<pre><code>rwxrwxrwx：

    左三位：定义user的权限
    中三位：定义group的权限
    右三位：定义other的权限

进程安全上下文：

    进程对文件的访问权限应用模型：
        进程的属主与文件的属主是否相同，若果相同，则应用owner权限
        否则，检查进程的属主是否属于文件的属组，如果是，则应用group权限
        否则，就只能应用other权限

权限：

       r：readable 可读
       w：writable 可写
       x：excutable 可执行

        文件权限： （一般情况下，普通文件不该拥有x权限）
            r：可获取文件的数据
            w：可修改文件的数据
            x：可将此文件运行为进程

        目录权限：
            r：可以使用ls命令获取其下的所有文件列表
            w：可修改此目录下的文件列表；创建或删除文件
            x：可cd至目录中，且可使用ll来获取所有文件的详细属性信息

        mode：rwxrwxrwx
        ownership：user，group

权限组合机制：

        --- 000 0
        --x 001 1
        -w- 010 2
        -wx 011 3
        r-- 100 4
        r-x 101 5
        rw- 110 6
        rwx 111 7

权限管理命令：

        chmod命令三种用法
            chmod [OPTION]... MODE[,MODE]... FILE...
            chmod [OPTION]... OCTAL-MODE FILE...
            chmod [OPTION]... --reference=RFILE FILE...
            三类用户：
                u：所有者user
                g：所属组group
                o：其他人other
                a：所有人
            （1）chmod [OPTION]... MODE[,MODE]... FILE...
                MODE表示法：
                    赋权表示法：直接操作一类用户的所有权限位rwx
                        u=
                        g=
                        o= 
                        a=
                    授权表示法：直接操作一类用户的一个权限位r,w,x
                        u+,u-
                        g+,g-
                        o+,o-
                        a+,a-      
            （2）chmod [OPTION]... OCTAL-MODE FILE...
                八进制表示法：
                    eg：chmod 777 文件名    
                777表示 rwxrwxrwx
            （3）chmod [OPTION]... --reference=RFILE FILE...
                引用表示法：
             选项：
             -R，递归修改

从属关系管理命令：chown，chgrp

        chown命令：
            chown [OPTION]... [OWNER][:[GROUP]] FILE...
               chown [OPTION]... --reference=RFILE FILE...
               选项：
                   -R 递归修改
           chgrp命令：
            chown [OPTION]... [OWNER][:[GROUP]] FILE...
               chown [OPTION]... --reference=RFILE FILE...

umask：文件的权限反向掩码，遮罩码

           文件：rw-rw-rw-
               666-umask 默认权限
           目录：rwxrwxrwx
               777-umask 默认权限
        注意：之所以文件用666去减，是因为文件默认不得拥有执行权限，如果减得的结果中有执行权限，则需要将其加1
               666-022=644
               777-022=756

           umask命令：
               umask：查看当前umask
               umask MASK:设置umask

           注意：此类设定仅对当前shell进程有效 


特殊权限：SUID、SGID、Stick

         SUID 权限表示为：s
             作用在可执行、二进制程序
             当用户运行时继承此程序所有者的权限
        SGID 权限表示为：s
            文件：作用在可执行、二进制程序
                继承此程序所属组的权限
            文件夹：作用于目录上
                当用户在目录新建文件时继承目录所属组
        Sticky 权限表示为：t
            作用于目录上，目录中的文件只能被所有者删除

限制root权限

    chattr命令
        chattr +i 加锁，禁止删除,改名，更改
      chattr -i 解除+i
      chattr +a 可追加内容，不可删除
      chattr -a 解除 +a
      chattr +A 禁用读时间的功能
      chattr -A 解除 -A
      lsattr      查看特殊属性

访问控制列表：ACL，自定义权限

    setfacl命令
        setfacl -m u：wang：rw f1 自定义用户权限
        setfacl -m g：wang：rw wang 自定义组权限
        getfacl 文件 查看文件的acl权限
        setfacl -x wang f1 删除文件中用户wang的acl权限
        setfacl -b     清除文件中所有acl权限

        setfacl -R  目录  递归acl
        setfacl -M  调用文本，批量创建权限
        setfacl -X  调用文本批量删除权限
        --set选项(待补充)
    mask限高杆
        setfacl -m mask::r f1 文件中的acl权限最高只有r--
        setfacl -m mask:rw f1 文件中的acl权限最高只有rw-

    注意：在设定了acl自定义权限之后
        chmod g= file 修改的是mask的权限，而不是group权限

    acl生效顺序：所有者、自定义用户、自定义组、其他人

     FAT分区不支持设置权限
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/29/第二周-用户和组的管理以及权限管理/" data-id="cjkgkimqt00051oisgrfplor2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第二周-命令、索引节点、标准IO和管道" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/26/第二周-命令、索引节点、标准IO和管道/" class="article-date">
  <time datetime="2018-07-26T12:00:00.000Z" itemprop="datePublished">2018-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/26/第二周-命令、索引节点、标准IO和管道/">命令、索引节点、标准I/O和管道</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="DAY-4"><a href="#DAY-4" class="headerlink" title="DAY 4"></a>DAY 4</h1><hr>
<p><strong>内容概括：个人梳理命令、索引节点、标准I/O和管道相关知识</strong></p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><pre><code>mv        单个文件重命名与移动
rename    多个文件重命名
rm        删除
shred     覆盖式删除
tree      目录树
dd        创建指定大小的文件
mkdir     创建空目录
redir     删除空目录
file      判断文件类型
tr        标准输入和标准输出
tee       配合管道使用
|         管道
</code></pre><h1 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h1><pre><code>inode（index node）
硬链
软链接
关于磁盘存储内部工作原理
inode 表结构的直接指针与间接指针
</code></pre><h1 id="标准I-O和管道"><a href="#标准I-O和管道" class="headerlink" title="标准I/O和管道"></a>标准I/O和管道</h1><pre><code>关于重定向的语法…
多行STDIN&quot;&lt;&lt;终止词&quot;
</code></pre><hr>
<h1 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h1><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>mv &lt;选项&gt; &lt;文件名&gt; &lt;文件名&gt;<br>用于移动覆盖文件或者给文件改名 （仅能单个改名）<br>常用选项：<br>-i 覆盖前询问<br>-f 强制覆盖</p>
<p>eg：改名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ls</span></span><br><span class="line">dir1 f1 f2 f3 f4</span><br><span class="line">[root@Souler6 app]<span class="comment"># mv f2 f5 #将f2改名为f5</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ls</span></span><br><span class="line">dir1 f1 f3 f4 f5</span><br></pre></td></tr></table></figure></p>
<p>eg：移动且改名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r–r–. 2 root root 0 Jul 26 09:35 f5 <span class="comment">#注意创建时间</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f5</span><br><span class="line">[root@Souler6 app]<span class="comment"># mv f5 dir1/f6 #移动并改名</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f5</span><br><span class="line">-rw-r–r–. 2 root root 0 Jul 26 09:35 f6 <span class="comment">#f5移动且改名的文件f6，创建时间与f5相同</span></span><br></pre></td></tr></table></figure></p>
<p>eg：移动改名且覆盖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># touch f5</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 f5 <span class="comment">#注意创建时间</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 2 root root 0 Jul 26 09:35 f6 <span class="comment">#注意创建时间</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># mv f5 dir1/f6</span></span><br><span class="line">mv: overwrite `dir1/f6’? y <span class="comment">##文件已存在询问是否覆盖，加-f 可以强制覆盖</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 f6 <span class="comment">#改名且覆盖后，时间也变了</span></span><br></pre></td></tr></table></figure></p>
<h2 id="rename命令"><a href="#rename命令" class="headerlink" title="rename命令"></a>rename命令</h2><p>批量改名字<br>eg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f2</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f3</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 f5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 f6</span><br><span class="line">[root@Souler6 dir1]<span class="comment"># rename ‘f’ ‘xcb’ f*</span></span><br><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb2</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb3</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br></pre></td></tr></table></figure></p>
<h2 id="rm命令-可还原的删除"><a href="#rm命令-可还原的删除" class="headerlink" title="rm命令 可还原的删除"></a>rm命令 可还原的删除</h2><p>rm &lt;选项&gt;&lt;文件名&gt;..<br>常用选项：<br>-i 交互式，删除前询问<br>-f 强制性，不询问</p>
<p>eg：交互式删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb2</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb3</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br><span class="line">[root@Souler6 dir1]<span class="comment"># rm xcb1 xcb2 xcb3</span></span><br><span class="line">rm: remove regular empty file xcb1? y </span><br><span class="line">rm: remove regular empty file xcb2? y</span><br><span class="line">rm: remove regular empty file xcb3? y</span><br><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br></pre></td></tr></table></figure></p>
<p>eg：强制删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br><span class="line">[root@Souler6 dir1]<span class="comment"># rm -f xcb4</span></span><br><span class="line">[root@Souler6 dir1]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br></pre></td></tr></table></figure></p>
<p>eg：删除目录 需要-r递归删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 11:15 dir1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 09:35 f1</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Jul 26 09:37 f3 -&gt; /app/f1</span><br><span class="line">lrwxrwxrwx. 1 root root 9 Jul 26 09:39 f4 -&gt; ../app/f1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:01 f6</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll dir1/</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</span><br><span class="line">[root@Souler6 app]<span class="comment"># rm -rf dir1/</span></span><br><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 09:35 f1</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Jul 26 09:37 f3 -&gt; /app/f1</span><br><span class="line">lrwxrwxrwx. 1 root root 9 Jul 26 09:39 f4 -&gt; ../app/f1</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 11:01 ll f6</span><br></pre></td></tr></table></figure></p>
<p>利用alias命令与mv，创建一个垃圾箱trash<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> rm=<span class="string">"mv -t /trash"</span>  <span class="comment">#利用-t选项 调换前后顺序</span></span><br></pre></td></tr></table></figure></p>
<p>创建一个名为bigfile，大小为100M的文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dd <span class="keyword">if</span>=/dev/zero of=bigfile bs=1M count=100</span><br></pre></td></tr></table></figure></p>
<p>删除大文件，急速为系统腾出空间，使用重定向原理&gt;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ &gt; bigfile</span><br><span class="line">$ rm -rf bigfile</span><br></pre></td></tr></table></figure></p>
<p>未知命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsof | grep deleted</span><br></pre></td></tr></table></figure></p>
<p>提问：删除文件的底层原理?</p>
<h2 id="shred命令-相对比较安全的删除"><a href="#shred命令-相对比较安全的删除" class="headerlink" title="shred命令 相对比较安全的删除"></a>shred命令 相对比较安全的删除</h2><p>shred -zv -n5 &lt;文件名&gt;</p>
<h2 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h2><p>tree &lt;选项&gt;&lt;目录名&gt;</p>
<pre><code>查看目录的树
tree -d 只看目录树
tree -L n 查看层数，n为层数
tree -P 配合通配符使用*
</code></pre><h2 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h2><pre><code>$ dd if=/dev/zero of=bigfile bs=1M count=100
创建一个名为bigfile，大小为100M的文件。
</code></pre><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>mkdir -p 自动创建不存在的子目录<br>创建空目录<br>eg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 ~]<span class="comment"># mkdir /app/dir1/&#123;x/&#123;a,b&#125;,y/&#123;c,d&#125;&#125;</span></span><br><span class="line">mkdir: cannot create directory /app/dir1/x/a: No such file or directory mkdir: cannot create directory/app/dir1/x/b’: No such file or directory</span><br><span class="line">mkdir: cannot create directory /app/dir1/y/c: No such file or directory mkdir: cannot create directory/app/dir1/y/d’: No such file or directory</span><br><span class="line"><span class="comment">#报错原因，因为没加-p选项，不会自动创建不存在的子目录，我们可以尝试加参数后在运行</span></span><br><span class="line">[root@Souler6 ~]<span class="comment"># mkdir -pv /app/dir1/&#123;x/&#123;a,b&#125;,y/&#123;c,d&#125;&#125;</span></span><br><span class="line">mkdir: created directory /app/dir1 mkdir: created directory/app/dir1/x</span><br><span class="line">mkdir: created directory /app/dir1/x/a mkdir: created directory/app/dir1/x/b</span><br><span class="line">mkdir: created directory /app/dir1/y mkdir: created directory/app/dir1/y/c</span><br><span class="line">mkdir: created directory /app/dir1/y/d</span><br><span class="line"><span class="comment">#加了-p选项就创建成功了，-v是显示创建过程</span></span><br></pre></td></tr></table></figure></p>
<pre><code>[root@Souler6 ~]# tree /app/dir1/
/app/dir1/
├── x
│   ├── a
│   └── b
└── y
    ├── c
    └── d

6 directories, 0 files
</code></pre><p>用目录树显示，想使用tree需自己安装。。</p>
<h2 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h2><p>rmdir -p 自动删除上一级空目录<br>只能删空目录<br>eg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># mkdir -pv /app/dir1/dir2/&#123;/dir3,/dir4/dir5/dir6&#125;</span></span><br><span class="line">mkdir: created directory /app/dir1 mkdir: created directory/app/dir1/dir2</span><br><span class="line">mkdir: created directory /app/dir1/dir2//dir3 mkdir: created directory/app/dir1/dir2//dir4</span><br><span class="line">mkdir: created directory /app/dir1/dir2//dir4/dir5 mkdir: created directory/app/dir1/dir2//dir4/dir5/dir6</span><br></pre></td></tr></table></figure></p>
<pre><code>[root@Souler6 app]# tree /app/
/app/
└── dir1
└── dir2
    ├── dir3
    └── dir4 有树目录可看出，dir2非空目录
        └── dir5
            └── dir6
        6 directories, 0 files
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># rmdir -pv /app/dir1/dir2/dir4/dir5/dir6/</span></span><br><span class="line">rmdir: removing directory, /app/dir1/dir2/dir4/dir5/dir6/ rmdir: removing directory,/app/dir1/dir2/dir4/dir5</span><br><span class="line">rmdir: removing directory, /app/dir1/dir2/dir4 rmdir: removing directory,/app/dir1/dir2</span><br><span class="line">rmdir: failed to remove directory /app/dir1/dir2: Directory not empty <span class="comment">#删到过程能够看到报错了，由于目录dir2非空目录，停止删除</span></span><br></pre></td></tr></table></figure>
<pre><code>[root@Souler6 app]# tree /app/
/app/
└── dir1
    └── dir2
        └── dir3 #对比上面的树目录中可以看到dir2目录下空的子目录已被清理
3 directories, 0 files
</code></pre><p>故，可印证rmdir只能删空目录，-p是将父目录为空的目录删除，逆向递归删除</p>
<h1 id="索引节点-1"><a href="#索引节点-1" class="headerlink" title="索引节点"></a>索引节点</h1><p>linux底层工作原理</p>
<h2 id="inode（index-node）"><a href="#inode（index-node）" class="headerlink" title="inode（index node）"></a>inode（index node）</h2><p>节点编号简介</p>
<pre><code>inode number ,inode编号，是每个文件的唯一性，
inode table 节点表 属于元数据
节点编号，链接数（matadata）
date block 数据块 属于数据
1M、1G (data)
</code></pre><p>即时节点编号也有可能出现出现节点编号相同的情况<br>eg:</p>
<pre><code>分区所在挂载的目录节点编号相同
在同一个分区中，节点编号相同即为同一个文件（涉及硬链接）
</code></pre><p>在不同分区中，即时节点编号相同也不是同一文件，每个分区中的节点编号不互通（分区挂载点除外）<br>节点编号是有限的，可回收利用<br>eg:</p>
<pre><code>f1的节点编号为52，删除f1后又创建f2的节点编号为52
原因：由于f1被删除后，节点编号52空缺，之后会被分配给新创建的文件f2使用
</code></pre><p>查看节点编号</p>
<pre><code>$ls -l -i
</code></pre><p>查看节点编号的使用情况</p>
<pre><code>$ df -i
</code></pre><h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>独立，只能在同一个分区，不能跨设备，不能跨分区，局限性。<br>且多个硬链接文件所占的空间=单个源文件。可以理解为每一个硬链接都是给文件起了个新名字，所占用的资源不增加不减少。<br>文件夹不支持创建硬链接，节点编号不增长。</p>
<p>eg：</p>
<pre><code>[root@Souler6 ~]# touch /app/f1
[root@Souler6 ~]# ll -i /app/
total 0
11 -rw-r–r–. 1 root root 0 Jul 26 09:35 f1 ##11是节点编号，2是硬链接
[root@Souler6 ~]# ln /app/f1 /app/f2
[root@Souler6 ~]# ll -i /app/
total 0
11 -rw-r–r–. 2 root root 145 Jul 26 09:35 f1
11 -rw-r–r–. 2 root root 145 Jul 26 09:35 f2
#从上面的信息可以获取到 f1与f2是硬链接的关系，其节点编号相同，都为11，这两个文件是等同的，且所占空间为145个字节，而不是290个字节。
#将f1删除，f2可以运行，不受影响。
#将f2删除，f1可以运行，不受影响。
#可以理解为，删除硬链接仅仅是将文件多个名字中去掉一个名字
#但若是将f1，f2同时删除，此文件将不存在，且节点编号空缺出来，等待分配给新的文件
</code></pre><p>创建硬链接</p>
<pre><code>$ ln f1 f2
</code></pre><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>仅仅只是一个快捷方式，每个软链接会占用一个节点编号，每个快捷方式所占空间与路径有关<br>可跨分区，依赖性：假如源文件被删除，则软链接失效。</p>
<p>同分区使用：</p>
<pre><code>[root@Souler6 ~]# ln -s /app/f1 /app/f3 （使用绝对路径）
[root@Souler6 ~]# ln -s ../app/f1 /app/f4 （使用相对路径）
[root@Souler6 ~]# ll -i /app/
total 0
11 -rw-r–r–. 2 root root 145 Jul 26 09:35 f1
11 -rw-r–r–. 2 root root 145 Jul 26 09:35 f2
12 lrwxrwxrwx. 1 root root 7 Jul 26 09:37 f3 -&gt; /app/f1
13 lrwxrwxrwx. 1 root root 9 Jul 26 09:39 f4 -&gt; ../app/f1

f3与f4都是f1的软链接，相当于f1的快捷方式，即时这样也不是同一个文件，可以看到f3与f4的节点编号不同，各自占用一个独立的节点编号。
以及可以看到f3指向的路径有7个字符占用7个字节，f4指向的路径有9个字符占用了9个字节，因此可以得出每个快捷方式所占空间与源文件无关，而是与路径的字符长度有关。
</code></pre><p>跨分区使用</p>
<pre><code>[root@Souler6 ~]# ln -s ../app/f1 f4
[root@Souler6 ~]# ll -i /root/
total 104
134418 -rw——-. 1 root root 1456 Jul 17 11:08 anaconda-ks.cfg
153481 drwxr-xr-x. 2 root root 4096 Jul 26 08:57 Desktop
153485 drwxr-xr-x. 2 root root 4096 Jul 17 11:18 Documents
153482 drwxr-xr-x. 2 root root 4096 Jul 17 11:18 Downloads
153603 -rw-r–r–. 1 root root 0 Jul 26 09:34 f1
153615 lrwxrwxrwx. 1 root root 9 Jul 26 09:38 f4 -&gt; ../app/f1

可以看到快捷方式f4使用的节点编号，跟上面的f4是不一样的，差别很大
跨区创建所生成的软链接会按当前分区剩余的节点编号去分配节点。
可以看到/分区下 快捷方式f4的节点编号为153615
而分区/app下，快捷方式f4的节点编号为13。

多用相对路径，每个软链接独自分配一个不同的节点编号
</code></pre><p>/dev/cdrom-&gt; sr0 光盘的快捷方式<br>创建软链接</p>
<pre><code>ln -s f1 f2，
</code></pre><p>多用相对路径</p>
<h2 id="分析-mv-f1-f2-与-ln-s-f1-f2-的底层原理"><a href="#分析-mv-f1-f2-与-ln-s-f1-f2-的底层原理" class="headerlink" title="分析 mv f1 f2 与 ln -s f1 f2 的底层原理"></a>分析 mv f1 f2 与 ln -s f1 f2 的底层原理</h2><p><strong>mv f1 f2</strong><br>同分区中，改名，或者移动，并不会改变节点编号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 mv]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">131074 -rw-r–r–. 1 root root 0 Jul 26 12:25 f1 <span class="comment">#改名前</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># mv f1 ../f2 #移动f1并改名为f2</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../</span></span><br><span class="line">total 8</span><br><span class="line">131074 -rw-r–r–. 1 root root 0 Jul 26 12:25 f2 <span class="comment">#改名后，文件数据没任何变化</span></span><br><span class="line">524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln</span><br><span class="line">131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:29 mv</span><br><span class="line">同分区中，改名且覆盖</span><br><span class="line">[root@Souler6 mv]<span class="comment"># touch f22 #创建一个新的文件f22</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i</span></span><br><span class="line">total 0</span><br><span class="line">131075 -rw-r–r–. 1 root root 0 Jul 26 12:31 f22 <span class="comment">#f22节点编号131075</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../</span></span><br><span class="line">total 8</span><br><span class="line">131074 -rw-r–r–. 1 root root 0 Jul 26 12:25 f2 <span class="comment">#f2节点编号为131074</span></span><br><span class="line">524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln</span><br><span class="line">131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:31 mv</span><br><span class="line">[root@Souler6 mv]<span class="comment"># mv f22 ../f2</span></span><br><span class="line">mv: overwrite `../f2’? y <span class="comment">#因已存在f2文件，故改名后覆盖</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../</span></span><br><span class="line">total 8</span><br><span class="line">131075 -rw-r–r–. 1 root root 0 Jul 26 12:31 f2 <span class="comment">#f2节点编号为131075，变了</span></span><br><span class="line">524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln</span><br><span class="line">131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:31 mv</span><br><span class="line">跨分区移动</span><br><span class="line">[root@Souler6 ~]<span class="comment"># ll -i f1</span></span><br><span class="line">153603 -rw-r–r–. 1 root root 0 Jul 26 09:34 f1</span><br><span class="line">[root@Souler6 ~]<span class="comment"># mv f1 /boot</span></span><br><span class="line">[root@Souler6 ~]<span class="comment"># ll -i /boot/f1</span></span><br><span class="line">38 -rw-r–r–. 1 root root 0 Jul 26 09:34 /boot/f1 <span class="comment">#注意，节点编号改变了</span></span><br></pre></td></tr></table></figure></p>
<p>根据以上分析可以得出<br>同分区中<br>mv改名后，文件数据没任何变化<br>mv移动文件时，节点编号不会发生改变<br>mv覆盖文件时，会把节点编号一起覆盖掉<br>跨分区的移动<br>mv移动后，节点编号会发生改变</p>
<p><strong>ln -s f1 f2</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../ln/</span></span><br><span class="line">total 0</span><br><span class="line">524290 -rw-r–r–. 1 root root 0 Jul 26 12:45 f1 <span class="comment">#源文件的节点编号为524290</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ln -s ../../app/ln/f1 /app/mv/f3 #可以理解成将相对路径下f1文件的快捷方式发送到绝对路径并起名为f3</span></span><br><span class="line">[root@Souler6 mv]<span class="comment"># ll -i ../mv/</span></span><br><span class="line">total 0</span><br><span class="line">131076 lrwxrwxrwx. 1 root root 10 Jul 26 13:01 f3 -&gt; ../../app/ln/f1<span class="comment">#快捷方式的节点为131076</span></span><br><span class="line"></span><br><span class="line">[root@Souler6 mv]<span class="comment"># tree /app/</span></span><br><span class="line">/app/</span><br><span class="line">├── f2</span><br><span class="line">├── ln</span><br><span class="line">│   └── f1</span><br><span class="line">└── mv</span><br><span class="line">    └── f3 -&gt; /app/ln/f1</span><br><span class="line">2 directories, 3 files</span><br></pre></td></tr></table></figure></p>
<p>根据以上分析可以得出，<br>创建快捷方式需指定相对路径，再指定存放的绝对路径<br>快捷方式也会被单独分配一个节点，且所占大小与路径字符有关<br>创建同分区中和跨分区的软链接<br>ln -s 软链接都会被分配一个新的节点编号</p>
<p><strong>xargs touch 突破创建文件个数的限制</strong></p>
<pre><code>[root@Souler6 ~]# echo f{1..100000} | xargs touch
</code></pre><p>##inode 表结构的直接指针与间接指针<br>直接指针</p>
<pre><code>12共有个直接指针，每个指针指向一个大小为4k的数据块，最多存储48k，但存储的数据超过48k则需要用到间接指针来存储更大的数据
</code></pre><p>间接指针</p>
<pre><code>一个间接指针占4个字节byte
一个数据块占4k，4k=41024byte
所以1个数据块中有1024个间接指针
</code></pre><p>一级间接指针 4MB</p>
<pre><code>间接指针指向下一个文件块的指针，文件块的大小为4k，每个指针占4个byte，故可以理解为该文件块下有1024个指针，1024个指针分别指向1024个4k的数据块，故可存放文件的大小为10244k=4MB
</code></pre><p>二级间接指针 4GB</p>
<pre><code>间接指针指向下一个文件块的指针，文件块的大小为4k，每个指针占4个byte，故可以理解为该文件块下有1024个指针，1024个指针分别指向1024个文件块，这种又衍生除了10241024个指针，这10241024个指针再次指向数据块，每个数据块大小为4k，故可存放的文件大小为102410244k=4GB
</code></pre><p>三级间接指针 4TB</p>
<pre><code>与二级指针同理，故可存放的文件大小为102410241024*4k=4TB
</code></pre><p><strong>file命令</strong><br>在linux中，不注重后缀，一般情况下更改后缀不影响程序的运行<br>file [选项] &lt;文件名&gt;</p>
<p>也可以通过hexdump查看开头作出判断</p>
<pre><code>hexdump -C -n 100 &lt;文件名&gt;
</code></pre><h2 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h2><p>input：输入数据 ouput：输出数据<br>文件描述符</p>
<pre><code>打开的文件都有一个fd：file descriptor(文件描述符)
进程运行会产生文件描述符
自动生成的文件描述符存储在/proc/PID/fd中，PID是一个数字（进程编号）
</code></pre><p>查看进程</p>
<pre><code>$ ps aux
</code></pre><p>linux中给程序提供的三种I/O设备</p>
<pre><code>标准输入 STDIN 0 默认位置：键盘
标准输出 STDOUT 1 默认位置：当前终端窗口
标准错误 STDERR 2 默认位置：当前终端窗口
</code></pre><p><strong>I/O重定向：改变默认位置</strong></p>
<p>把输出和错误重定向到文件</p>
<p>大致讲一下标准输入、标准输出、标准错误的概念<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll /app/ /error/ # 一般我们在键盘中敲入命令，这就是标准输入STDIN（0）</span></span><br><span class="line">ls: cannot access /error/: No such file or directory <span class="comment"># 执行命令后由于/error文件不存在，故，报错，这种就是标准错误STDERR（2）标准错误会默认打印在当前终端窗口</span></span><br><span class="line">/app/: <span class="comment">#/app存在，故，这是一个标准输出STDOUT（1）标准输出会默认打印在当前终端窗口</span></span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:12 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:12 d2</span><br></pre></td></tr></table></figure></p>
<p>下面举例子详细说明： ‘&gt;’可以用于重定向, ‘&gt;&gt;’ 用于重定向的追加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ls</span></span><br><span class="line">d1 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll /app/ /error/ &gt; 1.txt #标准输入，但是’&gt;’已经将标准输出进行了重定向，故屏幕不打印标准输出，只打印了标准错误</span></span><br><span class="line">ls: cannot access /error/: No such file or directory</span><br><span class="line">[root@Souler6 app]<span class="comment"># cat 1.txt # 查看1.txt中是不是真的打印了标准输出</span></span><br><span class="line">/app/: <span class="comment">#这是本来应该被打印在屏幕上的标准输出，但’&gt;’对其进行了重定向</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:33 1.txt <span class="comment">#这是创建用于存放标准输出的文件，因为ll在打印前就对1.txt进行了列出命令，初始大小为0，实际上它的大小已经不是0了，我们可以理解为是 ‘ll命令的速度’比‘重定向打印的速度快’。</span></span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll #查看1.txt的大小</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r–r–. 1 root root 153 Jul 26 10:33 1.txt <span class="comment">#可以看到占用了153个字节</span></span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll /app/ /error/ &gt;&gt; 1.txt #使用’&gt;&gt;’表示追加打印，不加则会覆盖</span></span><br><span class="line">ls: cannot access /error/: No such file or directory</span><br><span class="line">[root@Souler6 app]<span class="comment"># cat 1.txt # 可以看到标准输出追加到了原有内容的下边</span></span><br><span class="line">/app/:</span><br><span class="line">total 8</span><br><span class="line">-rw-r–r–. 1 root root 0 Jul 26 10:33 1.txt</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">/app/:</span><br><span class="line">total 12</span><br><span class="line">-rw-r–r–. 1 root root 153 Jul 26 10:33 1.txt</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r–r–. 1 root root 307 Jul 26 10:48 1.txt <span class="comment">#由于内容追加，文件大小从153字节增长到了307字节</span></span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br></pre></td></tr></table></figure></p>
<p>从上文可以看到三种I/O他们都带着一个数字<br>STDIN（0）,STDOUT（1）,STDERR2（2）<br>那这些数字是代表什么呢</p>
<pre><code>实际上 ‘&gt;’是’1&gt;’ 我们可以这样理解 1&gt;重定向标准输出（数字具体表现在这）
有’1&gt;’当然还有’2&gt;’ 我们可以这样理解 2&gt;重定向标准错误（数字具体表现在这）
</code></pre><p>通过上面的例子<br>eg:我们直接尝试把标准错误追加到1.txt （也可以）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll /app/ /error/ 2&gt; 1.txt #把标准错误重定向至1.txt中打印</span></span><br><span class="line">/app/: <span class="comment">#没有重定向标准输出，故默认在屏幕中打印</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r–r–. 1 root root 53 Jul 26 11:07 1.txt</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1</span><br><span class="line">drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</span><br><span class="line">[root@Souler6 app]<span class="comment"># cat 1.txt # 查看1.txt是否打印了标准错误</span></span><br><span class="line">ls: cannot access /error/: No such file or directory <span class="comment">#可以看到打印了标准错误，文件中内容不再有之前的标准输出，可以说明由于不是重定向追加，所以直接覆盖了原文件1.txt</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关于重定向的语法…"><a href="#关于重定向的语法…" class="headerlink" title="关于重定向的语法…"></a>关于重定向的语法…</h2><p>eg：</p>
<pre><code>&gt;    重定向标准输出
&gt;&gt;   重定向标准输出追加
2&gt;   重定向标准错误
2&gt;&gt;  重定向标准错误追加
set -C 重定向不覆盖
set +C 重定向覆盖
&gt;|   重定向强行覆盖 （用于忽略set -C）
2&gt;&amp;1 将2（标准错误）重定向到1（标准输出）
1&gt;&amp;2 将1（标准输出）重定向到2（标准错误）
’&amp;&gt;’ 等同于’2&gt;&amp;1’把标准错误重定向为标准输出,
(‘&amp;&gt;’兼容性不如’2&gt;&amp;1’,二者重定向意思等同)
</code></pre><p><strong>面试题:以下哪个与众不同</strong></p>
<p>A app.sh &gt; f1.log 2&gt;&amp;1<br>B app.sh 2&gt;&amp;1 &gt; f1.log<br>C app.sh 2&gt;f1.log 1&gt;&amp;2<br>D app.sh &amp;&gt;f1.log</p>
<p>答案：<strong>B</strong></p>
<h2 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h2><p>既有标准输入，也有标准输出<br>tr可以使用’&lt;’重定向输入，’&gt;’重定向输入<br>举个简单例子：将1.txt内容中的小写字母转换为大写字母<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># cat 1.txt</span></span><br><span class="line">ls: cannot access /error/: No such file or directory</span><br><span class="line">ls: cannot access /error/: No such file or directory</span><br><span class="line">[root@Souler6 app]<span class="comment"># tr ‘a-z’ ‘A-Z’ &lt; 1.txt #将1.txt的内容重定向为标准输入</span></span><br><span class="line">LS: CANNOT ACCESS /ERROR/: NO SUCH FILE OR DIRECTORY</span><br><span class="line">LS: CANNOT ACCESS /ERROR/: NO SUCH FILE OR DIRECTORY</span><br></pre></td></tr></table></figure></p>
<h2 id="多行STDIN"><a href="#多行STDIN" class="headerlink" title="多行STDIN"></a>多行STDIN</h2><p>使用“&lt;&lt;终止词”命令从键盘把多行重导向给STDIN直到终止词位置<br><strong>cat &gt; file &lt;&lt; EOF</strong><br>举个简单的例子:</p>
<pre><code>[root@Souler6 app]# cat &gt; 1.txt &lt;&lt;EOF
&gt;123
&gt;456
&gt;789
EOF
[root@Souler6 app]# cat 1.txt
123
456
789
</code></pre><p>（EOF可以是任意字符）</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>用符号 <strong>|</strong> 表示<br>用法：cmd1 <strong>|</strong> cmd2 <strong>|</strong> cmd3 <strong>|</strong> …<br>多个命令的链接，最后的命令会基于上一命令的基础，对内容进行再处理进行输出<br>举个简单例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@Souler6 app]<span class="comment"># ll 1.txt #未加管道</span></span><br><span class="line">-rw-r–r–. 1 root root 106 Jul 26 11:15 1.txt</span><br><span class="line">[root@Souler6 app]<span class="comment"># ll 1.txt | tr ‘a-z’ ‘A-Z’ #加管道进行大小写字母转换，并输出</span></span><br><span class="line">-RW-R–R–. 1 ROOT ROOT 106 JUL 26 11:15 1.TXT</span><br></pre></td></tr></table></figure></p>
<h2 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h2><p>用于管道中打印子shell的标准输出</p>
<p>（待补充）<br>未完待续…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/26/第二周-命令、索引节点、标准IO和管道/" data-id="cjkgkimqq00031oisv1l8ypcw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第二周-关于文件系统，以及history、cd、ls、touch、cp命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/25/第二周-关于文件系统，以及history、cd、ls、touch、cp命令/" class="article-date">
  <time datetime="2018-07-25T12:00:00.000Z" itemprop="datePublished">2018-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/25/第二周-关于文件系统，以及history、cd、ls、touch、cp命令/">关于文件系统，以及history、cd、ls、touch、cp命令以及通配符</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>==DAY 3==</strong></p>
<p><strong>命令行扩展、被括起来的集合</strong></p>
<pre><code>``  $()  把一个命令的输出打印给另一个命令的参数

&quot;&quot;弱引用 ，&apos;&apos;强引用

{} 打印重复字符串的简化形式
</code></pre><p><strong>文件通配符</strong></p>
<pre><code>*        --&gt; 匹配任意个字符
？       --&gt; 匹配单个字符
~        --&gt; 当前用户家目录
~mage    --&gt; 用户mage家目录
~+       --&gt; 当前工作目录
~-       --&gt; 前一个工作目录
[0-9]:   --&gt; 匹配数字范围
[a-z]:   --&gt; 小写字母
[A-Z]:   --&gt; 大写字母
[qwer]   --&gt; 匹配列表中的任何的一个字符
[^qwer]  --&gt; 匹配列表中的所有字符以外的字符

预定义支付类： man 7 glob

[:digit:]：任意数字，相当于0-9
[:lower:]：任意小写字母
[:upper:]: 任意大写字母
[:alpha:]: 任意大小写字母
[:alnum:]：任意数字或字母
[:blank:]：水平空白字符
[:space:]：水平或垂直空白字符
[:punct:]：标点符号
[:print:]：可打印字符
[:cntrl:]：控制（非打印）字符
[:graph:]：图形字符
[:xdigit:]：十六进制字符
</code></pre><p><strong>TAB键补全命令</strong></p>
<pre><code>前提是安装了程序 bash-completion
查看该安装包版本 
$rpm -qa bash-completion&lt;&gt;.noarch 
centos 6
支持命令、目录的补全；不支持补全命令选项参数
centos 7
支持命令、目录的补全；支持补全命令选项参数
</code></pre><p><strong>history命令</strong></p>
<pre><code>history命令用于显示指定数目的指令命令，读取历史命令文件中的目录到历史缓存区和将历史命令缓存区中的目录写入命令文件。
该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入!2。
历史命令是被保存在内存中的，当退出或者登录Shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。
  每个用户的家目录下有个 .bash_history的文件，是专门存放用户所输入的命令历史。
.bash_history（并非即时记录，用户登出才会将history追加入文件，不正常关机则无法写入文件）

1.命令格式
history [选项][参数]
2.命令功能
可单独用于查看历史命令，也可配合参数调用或删除历史命令。
3.命令参数
-c  (常用)
清除内存中的历史列表
-d &lt;n&gt; 
清除第n条命令
&lt;n&gt;（常用）
显示最近n条历史记录
-a
将当前的历史记录行追加到历史记录文件
-r 
读取未读取的历史
-w &lt;文件名&gt; 
将当前历史写到指定文件中
-p  
执行且不留历史记录
-s  
伪造历史记录，但不执行
</code></pre><p><strong>关于history调用</strong></p>
<pre><code>调用历史命令，n是命历史命令编号
!n 
执行上一条命令
!!      
执行前一条命令，去除参数
!:0     
补全上一个命令
Esc，.     
补全上一个命令
按住alt+. 
</code></pre><p><strong>关于命令历史相关变量</strong></p>
<pre><code>HISTSIZE  历史记录条数
HISTFILE  存储历史文件
HISTFILESIZE  命令历史文件记录历史条数
HISTTIMEFORMAT= &quot;%F %T&quot; 显示时间
HISTIGNORE=&quot;str1:str2* &quot; 忽略str1命令，str2开头的历史
</code></pre><p><strong>控制历史命令记录的方式</strong></p>
<pre><code>环境变量：HISTCONTROL
ignoredups: 忽略重复的命令；连续且相同方为”重复“
ignorespace: 忽略所有空白开头的命令
ignoreboth: ignoredups,ignorespace
erasedups: 删除重复命令
Export 变量名=&quot;值
存放在 /etc/profile或 ~/.bash_profile
</code></pre><p><strong>bash快捷键</strong></p>
<pre><code>Ctrl + l
清屏，相当于clear命令
 Ctrl + o
执行当前命令，并重新显示本命令
 Ctrl + s
阻止屏幕输出，锁定
 Ctrl + q 
允许屏幕输出
 Ctrl + c
终止命令
Ctrl + z
挂起命令bash的快捷键
Ctrl + a
光标移到命令行首，相当于Home
Ctrl + e
光标移到命令行尾，相当于End
Ctrl + f
光标向右移动一个字符
Ctrl + b
光标向左移动一个字符
Alt + f
光标向右移动一个单词尾
Alt + b
光标向左移动一个单词首
Ctrl + xx
光标在命令行首和光标之间移动
Ctrl + u
从光标处删除至命令行首
Ctrl + k
从光标处删除至命令行尾
Alt + r    
删除当前整行bash的快捷键
Ctrl + w
从光标处向左删除至单词首
Alt + d
从光标处向右删除至单词尾
Ctrl + d
删除光标处的一个字符
Ctrl + h
删除光标前的一个字符
Ctrl + y
将删除的字符粘贴至光标后
Alt + c
从光标处开始向右更改为首字母大写的单词
Alt + u
从光标处开始，将右边一个单词更改为大写
Alt + l
从光标处开始，将右边一个单词更改为小写
Ctrl + t
交换光标处和之前的字符位置
Alt + t
交换光标处和之前的单词位置
Alt + N
提示输入指定字符后，重复显示该字符N次

注意：Alt组合快捷键经常和其它软件冲突
</code></pre><p><strong>实验：录屏</strong>（多用于动态演示）</p>
<pre><code> 创建一个录屏命令 （用于复现）复现
$ script -t 2&gt; time.log -a cmd.session
$ .....
$ .....
$ .....
 退出录屏
$exit
 复现录像
$ scriptptreplay time.log cmd.session
</code></pre><p><strong>文件系统分层结构  LSB</strong></p>
<pre><code>/bin -&gt;/usr/bin 存放供用户使用的二进制程序

/boot 引导程序文件，例如：kernel

/dev  存放设备文件
   brw------- b打头  块设备，随机访问
   crw------- c打头  字符设备，线性访问

/etc  存放系统范围内的配置文件，，可编辑的文本配置
  /etc/opt  opt的配置文件
  /etc/X11  X Windows系统的配置文件
  /etc/sgml SGML的配置文件
  /etc/xml  XML的配置文件

/usr   用户存储只读用户数据的第二层次，包含绝大多数的（多）用户工具和应用程序

/home  普通用户的家目录，保存用户个人的配置文件，一般为单独的分区

/lib   /bin/和/sbin/中二进制文件必要的库文件

/sbin  给管理员使用的二进制程序

/media 可移除媒体的挂载点，图形界面下，自动充当光盘挂载点，代替/run/media

/misc  命令行界面,普通用户手动挂载（进入该文件夹/misc/cd，则自动挂载光盘，不进入则不挂在）
     $ systemctl start autofs
     $ systemctl enable autofs
       查看块设备 
     $ df

/mnt   临时挂载的文件系统，超级用户手动挂载 $ mount /dev/sr0 /mnt

/opt   可选应用软件包

/proc  虚拟文件系统，，将内核与进程状态归档为文本文件，存放于内存，磁盘中所占空间为0，修改文件立即生效，但断电后数据丢失，数据修改不保存。

/sys  虚拟文件系统，存放于内存，映射硬件信息
      当识别不出块设备，扫描所有磁盘
      $ echo &apos;- - -&apos; &gt; /sys/class/scsi_host/host2/scan
/root  超级用户的家目录

/sbin  必要的系统二进制文件

/srv   站点的具体数据，由系统提供

/data

/run  不属于linux标准目录，代替/var/run

/var  动态文件————在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区，亦可称为变量文件

/tmp  临时文件，在系统重启时目录中文件不会被保留

标准可参考 FHS国际规范 
</code></pre><p><strong>文件系统</strong></p>
<pre><code>rootfs： root filesystem
文件名大小写区分看文件系统：
eg：
  文件系统 xfs 严格区分大小写
  文件系统 vfat 不区分大小写 
文件有两类数据：
 数据：data   存放数据的内容
 元数据：metadata 存放数据的属性     
</code></pre><p><strong>文件特性</strong></p>
<pre><code>查看文件类型的颜色规则
$ cat /etc/DIR_COLOR   
蓝色--&gt;目录
绿色--&gt;可执行文件
红色--&gt;压缩文件
浅蓝色--&gt;链接文件
灰色--&gt;其他文件
亮黄色--&gt;设备文件

查看文件类型
drwxr-xr-x.  5 root root      231 Jul 18 14:49 vmware-tools
eg： 文件类型由字符串drwxr-xr-x的第一位来表示，当前字符串第一位为d，由此我们可以得出该文件类型是目录文件
-：普通文件
d：目录文件
b：块设备
c：字符设备
l：符号链接文件
p：管道文件pise
s：套接字文件socker
</code></pre><p><strong>显示当前工作目录</strong></p>
<pre><code>pwd命令
$ pwd 显示连接路径
$ pwd -P  显示真实物理路径  
路径分为两种：相对路径，绝对路径
  相对路径（方便文件转移后的运行）
    不以正斜杠开始
    指定相对于当前工作目录或某目录的位置
    eg：
      $ cd home/xu 
    在每个目录下都有&apos;.&apos;和&apos;..&apos; ，相对路径中经常会使用到
     &apos;.&apos;表当前目录，&apos;..&apos;表父目录

  绝对路径
    以正斜杠开始
    完整的路径位置
    eg:
      $cd /home/xu
基名：basename
目录名：dirname
</code></pre><p><strong>cd命令</strong></p>
<pre><code>用于切换目录

1.命令格式
 cd &lt;路径&gt;
2.命令功能
 使用绝对或相对路径切换目录
3.命令参数
cd 
  切换至当前用户主目录
cd ..
  切换至父目录
cd ~
  切换到当前登录用户的家目录
cd ~用户名
  切换到指定用户家目录
cd -  
  切换回上次的目录，原理：由变量$OLDPWD控制
  可以手动更改变量 $OLDPWD=/路径名
</code></pre><p><strong>ls命令</strong></p>
<pre><code>ls命令是linux下最常用的命令。ls命令就是list的缩写，ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。 
通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多!

1.命令格式
ls [选项][参数]
2.命令功能
列出名表目录中所有的子目录和文件
3.命令参数
-d，
列出目录本身，而不是其内容
-a，
列出所有文件以及文件夹（包括隐藏）
-l
使用长列表格式
-A，
不列出&apos;.&apos;(表当前目录)和&apos;..&apos;（表当前目录的父目录）
-u，--time=atime, --time=access,--time= use
与-l配合使用，显示访问时间
-c，--time=ctime, --time=status
与-l配合使用，显示权限修改时间
-1 
显示另一列文件
-S 
按文件从大到小排序
-r，
排序时的逆序
-Sr 
反转，按文件小到大排序
-R，
以递归方式列出子目录
-X 
按后缀排序  
-U
不排序;按目录顺序列出条目
-p，
追加/指标到目录
-n， -num-uid-gid
像-l，但列出数字用户和组ID
-o
像-l，但不列出组信息
（还有一些不懂怎么用，没列出来）
</code></pre><p><strong>touch命令</strong></p>
<pre><code>linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。

1.命令格式
touch [选项]..文件名..
2.命令功能
创建一个不存在的文件。
touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。
3.命令参数
-r &lt;指定文档&gt; &lt;参考文档&gt;
将文件时间与指定参考文件时间对齐。
-c &lt;文件名&gt;
若文件名不存在，则不创建。
-t[[CC]YY]MMDDhhmm[.SS] &lt;文件名&gt; 
设定文件的时间戳
[[CC]YY]MMDDhhmm[.SS]
eg：2018年07月24日14点20分00秒;对应格式：201807241420.00 
-m 配合-t使用，修改Modify time 修改时间
-a 配合-t使用，修改Acess time 访问时间
</code></pre><p><strong>cp命令</strong></p>
<pre><code>cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。
一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。
这说明命令行和shell脚本的执行方式有些不同。 

1.命令格式
cp[选项].. 源 目的
2.命令功能
将源文件复制至目标文件，或将多个源文件复制至目标目录。
3.命令参数
-a,-archive
与-dR --preserve = all相同
--attributes-only
不要复制文件数据，只复制属性 
-i 
覆盖前询问
-n
不覆盖已存在的文件
--backup[=CONTROL]
备份每个现有目标文件,接受参数
-b像--backup但不接受参数
--copy-contents
递归时复制特殊文件的内容
-d与--no-dereference --preserve=links
相同
-f,--force
如果无法打开现有目标文件，请将其删除并尝试
再次（当使用-n选项时忽略此选项）
-H
遵循SOURCE中的命令行符号链接
-l,--link
硬链接文件而不是复制
-L,--dereference
始终遵循SOURCE中的符号链接
-P,--no-dereference
永远不要在SOURCE中关注符号链接
-p与--preserve = mode，ownership，timestamps
相同
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/25/第二周-关于文件系统，以及history、cd、ls、touch、cp命令/" data-id="cjkgkimqg00011oisnwwvdyuq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-个人blog搭建（纯属笔记，不做任何解释）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/22/个人blog搭建（纯属笔记，不做任何解释）/" class="article-date">
  <time datetime="2018-07-22T04:35:00.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/个人blog搭建（纯属笔记，不做任何解释）/">个人blog搭建（纯属笔记，不做任何解释）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>==<strong>windows下搭建hexo</strong>==</p>
<p>大致浏览即可，细节操作在下面的总结那<br>一.环境准备</p>
<p>1.安装node.js(npm也在安装包中)（默认安装即可，一路Next。。）<br>    安装包：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<pre><code>为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的
</code></pre><p>   检查安装是否成功,出现版本号则说明 Node.js 环境配置成功<br>    node -v、npm -v</p>
<p>2.安装git（默认安装即可，也是一路Next。。）<br>    安装包：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p>
<pre><code>为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上
</code></pre><p>   检查安装是否成功,出现版本号则说明 git 环境配置成功<br>    git -v<br>3.安装控制台Cmder（默认安装即可）<br>    安装包：<a href="http://cmder.net/" target="_blank" rel="noopener">http://cmder.net/</a></p>
<p>#个人使用爱好，可不装，用Windows自带cmd即可</p>
<p>4.安装Sublime Text 3（默认安装即可）<br>    安装包：<a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">https://www.sublimetext.com/3</a></p>
<p>#只要是支持.md的文本工具即可</p>
<p>二.GitHub的注册和配置<br>    官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
<p>1.拥有一个GitHub账号，没有的话去官网注册一下，很简单就不多说了<br>    官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>2.在GitHub创建一个仓库</p>
<h1 id="yourname-必须是你的用户名。"><a href="#yourname-必须是你的用户名。" class="headerlink" title="yourname 必须是你的用户名。"></a>yourname 必须是你的用户名。</h1><pre><code>图片1（待上传）
图片2（待上传）
 .
 .
 .
</code></pre><p>3.配置SSH密钥</p>
<p>   1）在桌面空白处鼠标右键打开Git bash here,键入命令（$ 无需键入..）<br>    $ ssh-keygen -t rsa -C “your’s emaill address”<br>   引号内填入你注册时所用的邮箱，回车<br>   显示你ssh密钥生成后保存的目录，直接回车确认（记住目录名，后面要找它拿东西的）<br>   会提示你设置密码（需要输入两次，密码看不见的）设置完密码之后<br>   会生成两个文件&lt;id_rsa&gt;、&lt;id_rsa.pub&gt;<br>   前往目录寻找文件&lt;id_rsa.pub&gt;，使用sublime text3 打开，并复制所有内容<br>   2）将SSH密钥存入GitHub</p>
<h1 id="ssh-T-git-github-com-选择性设置，用于设置自动填入密码"><a href="#ssh-T-git-github-com-选择性设置，用于设置自动填入密码" class="headerlink" title="$ ssh -T git@github.com(选择性设置，用于设置自动填入密码)"></a>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>(选择性设置，用于设置自动填入密码)</h1><pre><code>图片1（待上传）
图片2（待上传）
 .
 .
</code></pre><p>三.环境配置完成，开始安装Hexo，以及利用hexo建立本地网站</p>
<p>1.win+r 打开Cmder控制台，键入命令</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><p>  会报错，正常现象<br>    npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\chokidar\node_modules\fsevents):<br>    npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href="mailto:fsevents@1.0.17" target="_blank" rel="noopener">fsevents@1.0.17</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”win32”,”arch”:”x64”})<br>关于这个两个报错：fsevent是mac osx系统的，你是在win或者Linux下使用了 所以会有警告，忽略即可</p>
<p>   安装需要点时间，请耐心等待，安装成功后会有提示<br>    $ hexo -v<br>   检查安装是否成功,出现版本号则说明 hexo 安装成功</p>
<p>2.在任意一个分区创建任意一个文件夹，并该目录建立网站</p>
<p>#路径中不要有中文<br>    eg:创建test文件夹，路径为F:\test<br>git<br>    hexo init f:\test         创建一个网站，可能需要等待一小会，耐心等待<br>  成功提示：INFO  Start blogging with Hexo!</p>
<p>3.配置test目录下的_config.yml，生成静态文件<br>    配置_config.yml，用sublime text3 打开编辑并保存<br>  直接到文本尾部</p>
<pre><code># Deployment
   deploy:
     type: git
     repository: https://github.com/xucanbin/xucanbin.github.io.git
     branch: master

$ npm install hexo-deployer-git --save         安装一个插件
</code></pre><p>  在test目录中，鼠标右键打开git bash  </p>
<pre><code>$ ls            检查下目录下是不是出现多个文件，都是用于搭建网站的，这就是hexo的强大之处了
$ hexo g        生成静态文件。
$ hexo s        启动服务器。默认情况下，访问网址为： http://localhost:4000/
</code></pre><p>   尝试能否访问<a href="http://localhost:4000/，当然这只是本地的网页，没什么用。" target="_blank" rel="noopener">http://localhost:4000/，当然这只是本地的网页，没什么用。</a><br>   成功则如图<br>   由于source目录下自带一篇hello world文章，所以你网页上自动生成了。</p>
<p>四.配置test目录下的_config.yml</p>
<p>五.将hexo建立网站的目录（亦可称为本地仓库）与github同步</p>
<p> 在test目录下，新建一个README.md，并鼠标右键打开git bash<br> 并新建一个README.md ，用sublime text 3 打开编辑随意写点东西，后面会用到</p>
<p>将当前目录转变成一个 Git 仓库</p>
<pre><code>$ git init 
</code></pre><p>配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息</p>
<pre><code>$ git config --global user.name &quot;Your&apos;s name&quot;           引号中填自己的GitHub账号
$ git config --global user.email &quot;Your&apos;s email address&quot; 引号中填注册GitHub的邮箱
$ git add README.md       将README.md添加到索引

$ git commit -m &quot;first commit&quot;
添加远程仓库
$ git remote add origin git@github.com:yourname/yourname.github.io.git
$ ssh -T git@github.com
$ git push -u origin master

$ hexo g
$ hexo d
</code></pre><p>二次总结</p>
<p>关于搭建个人博客的事情我自己总结了几点</p>
<p>hexo 是帮你搭建了一个本地网站</p>
<p>git 是用于配置giuhub上的仓库以及ssh密钥</p>
<p>node.js的话，主要是其环境下的npm，依赖npm去安装hexo </p>
<p>我们创建自己的博客网站 其实就是把hexo创建的本地网站 所生成的静态页面部署到GitHub上<br>请准备好<git>好&lt;node.js&gt;环境，才能开始下列操作<br>实现部署的前提，拥有一个github账号以及在github上创建一个库命名格式为&lt;账号名.github.io.git&gt;</git></p>
<p>#命名格式必须遵守，不然无法成功（目前我是找不到其他方法啦）<br>1.安装并使用hexo,生成本地网站之后，配置本地网站中的_config.yml</p>
<pre><code>$ npm install -g hexo-cli   (还未分清楚用cmd还是git-bash安装，待测试)
$ hexo --version    
</code></pre><p>2.使用hexo建立本地网站</p>
<pre><code>$ hexo init &lt;目录名&gt;         亦可进入目录下打开git-bash键入
</code></pre><p>3.生成静态页面，也就是你未来的blog网站，</p>
<pre><code>$ hexo g
</code></pre><p>##｛以下操作可跳过<br>       $ hexo s       启动服务器，尝试进入本地网站，正常的话可以访问：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> </p>
<p>##以上操作可跳过｝</p>
<p>4.配置本地网站中的_config.yml</p>
<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><pre><code>deploy:
  type: git
  repository: https://github.com/xucanbin/xucanbin.github.io.git
  branch: master
</code></pre><p>5.安装hexo的deployer插件（必须装的插件）</p>
<pre><code>$ npm install hexo-deployer-git --save  (成功提示待测试)
</code></pre><p>6.本地git仓库（这是把本地网站目录转换为git仓库的操作，我记得会有有一个.git）</p>
<pre><code>$ git init &lt; 目录名&gt;    亦可进入目录下打开git bash 直接键入
</code></pre><p>7.ssh密钥   (使用git-bash)</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;your&apos;s emaill address&quot; 
</code></pre><p>   引号内填入你注册时所用的邮箱，回车<br>   显示你ssh密钥生成后保存的目录，直接回车确认（记住目录名，后面要找它拿东西的）<br>   会提示你设置密码（需要输入两次，密码看不见的）设置完密码之后<br>   会生成两个文件&lt;id_rsa&gt;、&lt;id_rsa.pub&gt;<br>   前往目录寻找文件&lt;id_rsa.pub&gt;，使用sublime text3 打开，并复制所有内容<br>   将SSH密钥存入GitHub，附图片</p>
<p>##（待上传）##<br>8.配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息<br>      （在仓库目录下打开git-bash） </p>
<pre><code>$ git config --global user.name &quot;Your&apos;s name&quot;           引号中填自己的GitHub账号
$ git config --global user.email &quot;Your&apos;s email address&quot; 引号中填注册GitHub的邮箱
$ git add README.md               将README.md添加到索引
$ git commit -m &quot;first commit&quot;    记录对存储库的更改,使用给定的&quot;&quot;first commit&quot;&quot;作为提交消息
</code></pre><p>9.添加git远程仓库（在仓库目录下打开git-bash）<br>  添加远程仓库</p>
<pre><code>$ git remote add origin git@github.com:xucanbin/xucanbin.github.io.git
</code></pre><p>10.推送到远程仓库（将 master 分支推送到 origin 服务器）（在仓库目录下打开git-bash）</p>
<pre><code>$ git push origin master
</code></pre><p>11.基于被配置完后的_config.yml,再次生成静态网页（在仓库目录下打开git-bash）</p>
<pre><code>$hexo g
</code></pre><p>12.将第二次生成的静态网页部署到git的远程仓库中（在仓库目录下打开git-bash）</p>
<pre><code>$hexo d        后续弹出一个窗口 输入git用户名以及密码
</code></pre><p>基础搭建完成<br>test目录下 f:\test\source_post\<br>上传文章的方法</p>
<p>以后写的博客直接放在里面，格式要求 后缀的.md<br>git-bash下</p>
<pre><code>$ hexo g
$ hexo d
$ git push origin master
</code></pre><p>最后，打开自己的博客就能看到文章所在。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/22/个人blog搭建（纯属笔记，不做任何解释）/" data-id="cjkgkimqh00021oiskh764fnp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-第一周-计算机基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/第一周-计算机基础知识/" class="article-date">
  <time datetime="2018-07-21T07:45:00.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/21/第一周-计算机基础知识/">计算机基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>==<strong>DAY 1</strong>==</p>
<h2 id="认识计算机"><a href="#认识计算机" class="headerlink" title="认识计算机"></a>认识计算机</h2><p><strong>世界上第一台计算机</strong></p>
<pre><code>计算机：一种能接受和存储信息，对海量数据进行自动、高速地处理，并输出结果的现代化智能设备。
</code></pre><p><strong>冯·诺依曼体系结构</strong>：1946年数学家冯·诺依曼提出计算机有5个组成部分：运算器、控制器、存储器（主存储器、辅助存储器）、输入设备、输出设备。</p>
<pre><code>1946年，世界上第一台计算机在美国滨州大学诞生。占地170平方米，重达30吨。
</code></pre><p>计算机发展历史：</p>
<pre><code>第一代（电子管时代）：1946-1957  
第二代（晶体管时代）：1958-1964
第三代（集成电路时代）：1965-1970
第四代（大规模集成电路时代）：1971以后```
</code></pre><p><strong>计算机系统</strong></p>
<p>1.硬件系统</p>
<pre><code>主机
     中央处理器CPU
          运算器ALU
          控制器CU
     内部存储器
          rom
          ram（断电丢失数据）
 外部设备
     外部存储器：硬盘、U盘
     输入设备：鼠标、键盘
     输出设备：显示屏、打印机、音频
</code></pre><p>2.软件系统</p>
<pre><code>系统软件：
     操作系统：win7、linux、mac
     程序语言处理系统
     数据库服务系统
     服务程序：检查、诊断、调试程序
应用软件：
     通用应用软件--如QQ、office办公
     专用应用软件--用户程序
</code></pre><p><strong>服务器种类</strong></p>
<pre><code> 塔式服务器tower

机架式服务器rack

规格：宽度为19英寸，高度以U为单位，如42U（约2米高）。
       1U=44.45毫米=1.75英寸。
配件：
     KVM（Keyboard Video Mouse）
     PDU (Power Distribution Unit)

刀片式服务器blade
</code></pre><p><strong>存储网络：</strong></p>
<pre><code>DAS---直接连接存储(direct attached storage)与主机紧密相连
     优点：
         管理成本低，实施简单。
     缺点：
         存储共享受到限制。
         不利于CPU的指令周期优化，增加系统负担。

NAS---网络连接存储(network attached storage)基于文件协议（NFS、SMB/CIFS）,实现文件共享，适用于局域网或较小的网络
     优点：
         集中管理数据，从而释放带宽，提高性能。
         可提供跨平台文件共享功能。
     缺点：
         可靠性差。    
SAN---存储区域网络(storage area networks)基于SCSI、IP、ATM等多种高级协议，实现存储共享
     优点：
         服务器跟储存装置两者各司其职，
         高效能、高稳定度的存储环境。
     缺点：
         实施复杂，管理成本高。
</code></pre><p><strong>操作系统</strong><br>(Operating System)：</p>
<pre><code>OS功能：
     硬件驱动、进程管理、内存管理、网络管理、安全管理、文件管理。


OS分类：
     服务器OS:REHL,CentOS,window server,AIX
     桌面OS:WIN7,WIN10,MAC0S,Fedora
     移动设备OS:Android,IOS,YunOS
</code></pre><p><strong>开发接口</strong></p>
<p>ABI接口 （应用接口）</p>
<pre><code>OS与应用程序的底层接口,允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行
如.apk无法在win7上运行
如.exe无法在Android上运行
</code></pre><p>API接口 （开发接口）</p>
<pre><code>库调用源代码和库之间的接口，实现库调用，因此同样的源代码可以在支持这个API的任何系统中编译
</code></pre><p>POSIX:Portable Operating System Interface</p>
<pre><code>IEEE（国际组织）在操作系统上定义的一系列API标准
</code></pre><p><strong>==练习==：</strong></p>
<pre><code>1.显示当前时间，格式：2016-06-18 10：20：30 
2.显示前天是星期几
3.设置当前时间为2019-08-07 06：05：10
</code></pre><p>1.答：</p>
<pre><code>$ date %F&apos; &apos;%T
</code></pre><p>2.答：</p>
<pre><code>$ date -d “2 days ago” +%A
</code></pre><p>3.答：</p>
<pre><code>$ date 080706052019.10
</code></pre><p>==<strong>DAY 2</strong>==</p>
<p>用户和内核空间</p>
<p>用户空间 user space</p>
<pre><code>用户空间必须通过系统接口（system call），才能向内核发出指令。
</code></pre><p>内核空间 kerneL space</p>
<pre><code>内核空间可以执行任意命令，调用系统的一切资源。
</code></pre><p>用户与内核的联系</p>
<pre><code>用户的程序无法直接访问硬件，只能通过操作系统间接访问硬件。

两个空间相对独立，防止损害硬件，但用户能通过操作系统间接访问硬件。
</code></pre><p>原理：</p>
<pre><code>上下文切换，会带来额外的资源损耗，减少上下文切换的次数，可以降低资源损耗。

相当于用户空间与内核空间的来回切换。

user space
     user land application
     #library#函数库,API接口
     ↓↓↓
     ↓↓↓（invoke）
     ↓↓↓
kernel space
     #system call#系统调用接口
     kernel
     device driver
     ↓↓↓
hardware
</code></pre><p>查看库调用</p>
<pre><code>$ ldd /bin/command
$ ldd /bin/command
</code></pre><p>跟踪底层系统调用</p>
<pre><code>$ strace command 
</code></pre><p>跟踪底层库调用</p>
<pre><code>$ ltrace command 
</code></pre><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>低级语言</p>
<pre><code> 机器语言：0、1
汇编语言:和机器语言一一对应(学汇编，不会编)
</code></pre><p>中级语言:系统级应用、驱动程序</p>
<pre><code>C语言
</code></pre><p>高级语言：应用级程序开发</p>
<pre><code>Java、Python、Go、PHP、Objective-C、C#
</code></pre><p>查看16进制的2进制代码</p>
<pre><code>$ hexdump -c  /bin/ls 
</code></pre><p>兼容分时系统工作原理</p>
<pre><code>原理：时间片
 1s对于计算机来讲，相当的漫长
 eg：1s分为100个时间片，每个时间片10ms
任务绑定cpu：task cpu
（主要是利用cpu中的三级缓存&quot;cache，L1,L2,L3&quot;，提高任务处理效率)
</code></pre><p><strong>Linux起源</strong></p>
<pre><code>1991年的10月5日，完全免费的内核kernel诞生了
</code></pre><p>兼容分时系统：Multics（多路信息计算系统）</p>
<pre><code>1964年发起了开发计划，于1969年失败，贝尔实验室退出计划。而后，ken thompson 为了打游戏，写了一个系统UNICS.（unix雏形）
1969 ，雏形初现unics，基于B语言开发   
1973，正式命名unix，基于C语言开发
1977，BSD,伯克利大学流派开始开发
1979，贝尔实验室流派，system V架构，因版权问题，不对学生提供源码，开始收费
1984，minix操作系统，由Andrew S.Tanenbaum开发
</code></pre><p>GUN（GNU is Not Unix）</p>
<pre><code>1984，由Richard Stallman发起并创建
目的是为了所有软件开源、自由
</code></pre><p>GPL(GUN General Public License)</p>
<pre><code>允许用户任意复制、传递、修改及再发布
</code></pre><p>LGPL(Lesser General Public License)</p>
<pre><code>LGPL相对GPL较为宽松，允许不公开所有源码
</code></pre><p>查看bash遵守GPL协议</p>
<pre><code>$ rpm -qi bash 
</code></pre><p>完整的类UNIX操作系统</p>
<pre><code>Linux内核+GNU工具
</code></pre><p>linux三大主流</p>
<pre><code>Debian
 --Ubantu
RedHat
 --CentOS
Slackware
  --S.U.S.E
</code></pre><p><strong>查看内核版本</strong></p>
<pre><code>$ uname -r 
</code></pre><p><strong>版本号解读</strong></p>
<pre><code>3.10.0-862.el7.x86_64

 内核版本号 &apos;3.10.0&apos;
 编译次数 &apos;862&apos;  次
 厂商版本 &apos;el&apos; 商业Lunix
 版本号 &apos;7&apos; centos7
  &apos;x86-64&apos;  64位
</code></pre><p><strong>登录前界面的配置文件</strong></p>
<pre><code>$ cat /etc/issue
</code></pre><p><strong>哈希值校验</strong>（安装系统后检查系统的完整性）</p>
<pre><code>$ sha1sum /dev/sr0   
</code></pre><p><strong>虚拟机软件:模拟硬件环境</strong></p>
<pre><code>vmware
</code></pre><p><strong>windows下CMD命令行转换分区格式，数据不丢失（单向的FAT格式转NTFS ）</strong></p>
<pre><code>$ conver H:/fs:ntfs
</code></pre><p><strong>Linux 准备</strong></p>
<pre><code>/dev/sda==硬盘
/home/xu==c:\user
/etc==注册表
/usr==C:\Windows and C:\program files
/boot 启动 
mount point 挂载点
</code></pre><p><strong>引导分区格式 MBR &amp; GPT</strong></p>
<p>MBR（主分区与扩展分区合起来不超过4个）</p>
<pre><code>MBR（主分区与扩展分区合起来不超过4个）
主分区：
     一个硬盘最多4个，主分区最小单位，只有一个活动的主分区。
扩展分区：
     一个硬盘最多只有一个扩展分区。但不可存储，需再次划分为更小的分区才能存储数据，即逻辑分区。
逻辑驱动器：
     由扩展分区二次划分。
</code></pre><p>GPT（待补充）</p>
<p><strong>linux中分区格式</strong></p>
<pre><code>主分区编号：/dev/sda1~4 
扩展分区编号：：/dev/sda5，6...
</code></pre><p><strong>centos分区大小</strong> （建议）</p>
<pre><code>/boot 1g   系统挂载点
/     50g   根目录
/data 20g   做实验用的目录
swap  2g    虚拟内存，大小一般为内存的1.5倍或者2倍
</code></pre><p><strong>更改主机名</strong></p>
<pre><code>centos6
$ nano /etc/sysconfig/network
centos7
$ nano /etc/hostname
</code></pre><p>引导程序：</p>
<pre><code>$ grub
</code></pre><p>查看内存：  </p>
<pre><code>$ free
$ cat /proc/meminfo
</code></pre><p>查看内存使用：</p>
<pre><code>$ free -h
</code></pre><p><strong>用户id号：</strong></p>
<pre><code>id为0，则为管理员，与root名字无关
</code></pre><p>uid</p>
<pre><code>超级用户root   uid：0
普通用户       uid：500+或者1000+
</code></pre><p>查看uid</p>
<pre><code>$ id -u  
 centos6 id 普通用户从500开始计算。。501
 centos7 id 普通用户从1000开始计算。。1001
</code></pre><p><strong>终端：</strong></p>
<p>物理终端</p>
<pre><code>/dev/tty* 
</code></pre><p>虚拟终端</p>
<pre><code>/dev/pts*
</code></pre><p>查看当前终端：</p>
<pre><code>$ tty
$ whoami
$ who am i
</code></pre><p>查看所有在线终端：</p>
<pre><code>$ who
</code></pre><p>切换终端：</p>
<pre><code>$ chvt &lt;终端号&gt;
$ ctrl+F1~F6
</code></pre><p>关机命令：</p>
<pre><code>$ halt；
$ poweroff；
$ shutdown -r now
</code></pre><p>设置登录前界面显示</p>
<pre><code>$ nano /etc/issue
 \d 天数 
 \l 显示当前登录终端号
 \n 显示主机名字
 \t 显示当前时间
 \r 显示内核版本
 \s 显示系统版本
</code></pre><p><strong>==练习==：</strong></p>
<pre><code>1.在本机字符终端登录时，除显示原有信息外，再显示当前登录终端号，主机名和当前时间
2.今天18：30自动关机，并提示用户
</code></pre><p>1.答：  </p>
<pre><code>$ nano /etc/issue 在文件中加入以下代码

 You are login on \l
 The hostname is \n
 It&apos;s \t now!
</code></pre><p>2.答：</p>
<pre><code>$ shutdown 18：30 “you were be shutdown”
</code></pre><p>==<strong>DAY</strong> 3==</p>
<p>多数企业基于安全问题，防止被针对版本漏洞而受到攻击，有关版本号的信息会进行自主修改。</p>
<p>许多公司在生产中所用系统版本相对滞后，以求稳定。</p>
<p>linux的系统相关配置皆放在文本文件中。</p>
<p><strong>查看centos版本</strong></p>
<p>centos6</p>
<pre><code>$ lsb_release -a （此程序centos7默认没有安装）
</code></pre><p>centos7</p>
<pre><code>$ cat /etc/centos-release
</code></pre><h6 id="字符界面下的编辑文本工具"><a href="#字符界面下的编辑文本工具" class="headerlink" title="字符界面下的编辑文本工具"></a>字符界面下的编辑文本工具</h6><pre><code>$ nano &lt;目录&gt;
</code></pre><p>指定用户开机自动登录</p>
<pre><code>   编辑配置文件
$ nano /etc/gdm/custom.conf  

 在字符 [daemon]下加入两行代码
 [daemon]
 AutomaticLoginEnable=true
 AutomaticLogin=&lt;user&gt;
</code></pre><p>查看cpu详细信息</p>
<pre><code>$ lscpu
    Flags:所带有的关键特性，eg：mmx，针对视频加速处理的一个特性
</code></pre><p>查看块设备</p>
<pre><code>$ lsblk
</code></pre><p>查看网卡</p>
<pre><code>$ dmesg
</code></pre><h3 id="交互式口"><a href="#交互式口" class="headerlink" title="交互式口"></a>交互式口</h3><p><strong>操作linux需要交互式接口</strong></p>
<p>图形化用户接口GUI(Graphic User Interface)</p>
<pre><code>GNOME(C,GTK)
KDE(C++,QT)
XFCE(轻量级桌面)
应用于：X protocol, window manager, desktop
三者之间的区别：底层库不同
</code></pre><p>命令行接口CLI （效率高）</p>
<pre><code>shell程序：

sh(bourn史蒂夫·伯恩)
csh
tcsh
ksh(korn)
bash (bournagain shell)GPL
zsh

shell也被称为命令解释器。
shell也属于开发语言，是一种简化、功能较弱的高级语言。
</code></pre><h6 id="除了以上常提到的shell，还有一种shell较为特殊的shell-：nologin"><a href="#除了以上常提到的shell，还有一种shell较为特殊的shell-：nologin" class="headerlink" title="除了以上常提到的shell，还有一种shell较为特殊的shell ：nologin"></a>除了以上常提到的shell，还有一种shell较为特殊的shell ：nologin</h6><h6 id="用于底层系统服务，而非用户使用。"><a href="#用于底层系统服务，而非用户使用。" class="headerlink" title="用于底层系统服务，而非用户使用。"></a>用于底层系统服务，而非用户使用。</h6><p>查看当前所用shell</p>
<pre><code>$ echo $SHELL
</code></pre><p>查看系统含有的所有shell</p>
<pre><code>$ cat /bin/shells
</code></pre><p><strong>PS1变量 （用于命令行提示符）</strong></p>
<p>临时更改命令行提示符颜色</p>
<pre><code>$ PS1=&quot;\[\e[1;40;31m\][\u@\h \W]$\[\e[0m\]&quot;
</code></pre><h6 id="1代表高亮-31-37代表字体颜色-40代表背景色"><a href="#1代表高亮-31-37代表字体颜色-40代表背景色" class="headerlink" title="1代表高亮,31~37代表字体颜色,40代表背景色"></a>1代表高亮,31~37代表字体颜色,40代表背景色</h6><p>永久更改命令提示符行颜色</p>
<pre><code>1.在/etc/profile.d/目录下
2.创建&lt;任意名&gt;.sh
3.将PS1=&quot;\[\e[1;40;31m\][\u@\h\W]$\[\e[0m\]&quot; 复制进去，保存
4.source 文件，或者重启即可
</code></pre><p><strong>PATH变量（用于存放外部命令的所有路径点）</strong></p>
<pre><code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
</code></pre><p><strong>帮助命令</strong></p>
<pre><code>$ help command
help中带*的表示被禁用
</code></pre><h6 id="（）16进制中，0a换行符号，0d回车"><a href="#（）16进制中，0a换行符号，0d回车" class="headerlink" title="（）16进制中，0a换行符号，0d回车"></a>（）16进制中，0a换行符号，0d回车</h6><h3 id="三大类命令"><a href="#三大类命令" class="headerlink" title="三大类命令"></a>三大类命令</h3><p><strong>内部命令</strong></p>
<p>集成于当前系统所使用shell中的一些命令</p>
<p>查看所有内部命令</p>
<pre><code>$ enable
</code></pre><p>禁用内部命令</p>
<pre><code>$ enable -n command
</code></pre><p>启用内部命令</p>
<pre><code>$ enable command
</code></pre><p>查看被禁用命令 </p>
<pre><code>$ enable -n
</code></pre><p>查看可用命令</p>
<pre><code>$ enable -p
</code></pre><p><strong>外部命令</strong></p>
<p>外部命令是在磁盘中独立的文件，使用的时候需要到磁盘中读取。</p>
<p>外部命令执行一次会产生缓存，有个命令叫hash，会从$PATH这个变量中定义的路径去搜索外部命令，从而执行该命令。</p>
<p>原理：</p>
<pre><code>外部命令一旦执行过后，命令所在路径会被hash缓存到内存中，下次再执行命令的时候就不必再到路径中去搜索，直接从hash中的路径读取，不用再到各个路径中去搜索，从而提升速度。
</code></pre><p>关于hash的使用：</p>
<pre><code>$ hash                显示 hash 缓存 
$ hash – l            显示 hash 缓存，可作为输入使用 
$ hash – p path name  将命令全路径 path 起 别名为 name 
$ hash – t name       打印缓存中 name 的路径 
$ hash – d name       清除 name 缓存 
$ hash – r            清除缓存
</code></pre><p><strong>别名命令</strong> <strong>alias</strong></p>
<p>外部命令与内部命令都可以被写为别名。</p>
<p>要想别名重启后不丢失永久生效，需将命令写当前用户目录下的.bashrc中</p>
<pre><code>$ nano /home/name/.bashrc      (普通用户,name换成你的用户名)
$ nano /root/.bashrc           (超级用户)
$ nano /etc/.bashrc            (所有用户）
</code></pre><p>查看所有别名</p>
<pre><code>$ alias
</code></pre><p>创建别名命令</p>
<pre><code>eg：
  $ ailas copy=&apos;cp&apos; | &quot;cp&quot;  （&apos;&apos;跟&quot;&quot;都能学习）
  $ alias -p copy=&apos;cp&apos;  （创建别名并打印出所有别名，仅支持&apos;&apos;）
</code></pre><p>取消别名</p>
<pre><code>$ unalias 
</code></pre><p>取消所有别名</p>
<pre><code>$ unalias -r
</code></pre><p>忽视别名的存在，强制执行原始命令</p>
<pre><code>$ \command
$ `command`
</code></pre><p><strong>判断命令的类别</strong> （tpye）</p>
<p>外部命令显示（路径）：</p>
<pre><code>eg：$ type echo
    $ echo is /usr/bin/echo
</code></pre><p>内部命令显示：</p>
<pre><code>eg：$ type type
    $ type is a shell builtin
</code></pre><p>别名命令则显示：（假设存在别名 alias copy=’cp’）</p>
<pre><code>eg：$ type copy
    $ copy is aliased to `cp&apos;  
</code></pre><p>显示命令的所有路径（或者类别）：</p>
<pre><code>$ type -a 
</code></pre><h6 id="优先级：别名命令-gt-内部命令-gt-外部命令"><a href="#优先级：别名命令-gt-内部命令-gt-外部命令" class="headerlink" title="优先级：别名命令&gt;内部命令&gt;外部命令"></a>优先级：别名命令&gt;内部命令&gt;外部命令</h6><p>在linux中，内存，属于易失性，要想配置永久生效，就要写到文件中。</p>
<p><strong>command</strong><br>组成部分</p>
<pre><code>[短选项]:-（可多个选项合并使用）
eg:
    $ ls -a -l
    $ ls -la 
    $ ls -al  等同
[长选项]:--
eg：
    $ ls --all
    $ ls --help
[参数]
    可以是文件，也可以是路径等等。
</code></pre><p><strong>快捷键</strong>（待补充）</p>
<p>快速退出终端</p>
<pre><code>ctrl+d 
</code></pre><p>强制结束</p>
<pre><code>ctrl+c 
</code></pre><p><strong>日期和时间</strong></p>
<p>硬件时间</p>
<pre><code>$ clock = $ hwclock 
$ clock   显示硬件时间
$ clock -s，--systohc修正系统时间，以硬件时间为准
$ clock -w，--hctosys修正硬件时间，以系统时间为准
</code></pre><p>系统时间</p>
<pre><code>$ date     显示系统时间
$ date +%s 计算从1970.1.1至今一共多少秒
$ date -s  根据描述设置时间
$ date -d  根据描述显示时间
$ date -d  @&lt;秒&gt; +&quot;%F %T&quot;
$ date -d &quot;2018-08-08 20:00:00&quot;+%s
</code></pre><p>时区路径 /etc/localtime</p>
<p>更改时区</p>
<p>centos6.x</p>
<pre><code>$ tzselect
</code></pre><p>centos7.x</p>
<pre><code>$ timedatectl set-timezone &lt;时区路径&gt;
</code></pre><p>日历</p>
<pre><code>$ cal 显示当月日历
$ cal -y 显示当年日历
$ cal &lt;年份&gt; 显示该年份日历
</code></pre><h6 id="与远程服务器同步时间"><a href="#与远程服务器同步时间" class="headerlink" title="与远程服务器同步时间"></a>与远程服务器同步时间</h6><pre><code>$ ntpdate &lt;ip&gt;      （ip较为特殊，需配置过的ip地址才能同步）
</code></pre><h6 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h6><p>发送消息给所有在线主机，多用于提示</p>
<pre><code>$ wall “system will shutdown at 19：00 ”
</code></pre><h4 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h4><p>获取帮助的能力决定了技术的能力</p>
<p>了解外部命令的基本功能</p>
<pre><code>$ whatis
</code></pre><p>系统使用一定时间后，会生成生成数据库或者手动创建数据库</p>
<pre><code>$ whatis command数据库
</code></pre><p><strong>手动创建whatis数据库</strong></p>
<p>centos 6.x</p>
<pre><code>$ makewhatis
</code></pre><p>centos 7.x</p>
<pre><code>$ mandb
</code></pre><p>了解命令的基本功能</p>
<pre><code>内部命令：
$ help command
外部命令：
$ command --help
</code></pre><p>寻找命令所在路径</p>
<pre><code>$ whereis
</code></pre><h6 id="man-and-info（有待详细说明）"><a href="#man-and-info（有待详细说明）" class="headerlink" title="man and info（有待详细说明）"></a>man and info（有待详细说明）</h6><p>man帮助（manual用户手册）</p>
<p>man章节分类</p>
<pre><code>1.用户命令
2.系统调用
3.C库调用
4.设备文件及特殊文件
5.配置文件格式
6.游戏
7.杂项
8.管理类命令
9.Linux内核API
</code></pre><p>使用命令获取章节号</p>
<pre><code>$ whatis command
</code></pre><p>指定man章节号寻找帮助</p>
<pre><code>$ man &lt;章节号&gt; command
</code></pre><p>在man中搜索关键词</p>
<pre><code>/ &lt;关键词&gt;  or ?&lt;关键词&gt;
</code></pre><p>man的配置文件目录</p>
<p>centos6</p>
<pre><code>man.conf(作用待了解)
</code></pre><p>centos7</p>
<pre><code>man_db.conf(作用待了解)
</code></pre><p>待续….</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/21/第一周-计算机基础知识/" data-id="cjkgkimqr00041ois6lov3iy7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/05/第三周-shell脚本编程基础知识/">shell脚本编程基础知识</a>
          </li>
        
          <li>
            <a href="/2018/08/01/第三周-文本处理工具和正则表达式/">文本处理工具和正则表达式</a>
          </li>
        
          <li>
            <a href="/2018/07/29/第二周-用户和组的管理以及权限管理/">用户和组的管理以及权限管理</a>
          </li>
        
          <li>
            <a href="/2018/07/26/第二周-命令、索引节点、标准IO和管道/">命令、索引节点、标准I/O和管道</a>
          </li>
        
          <li>
            <a href="/2018/07/25/第二周-关于文件系统，以及history、cd、ls、touch、cp命令/">关于文件系统，以及history、cd、ls、touch、cp命令以及通配符</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 ACan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>