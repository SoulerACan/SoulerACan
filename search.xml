<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>inode编号，是每个文件的唯一性，以及重定向的知识</title>
      <link href="/2018/07/26/DAY%204/"/>
      <url>/2018/07/26/DAY%204/</url>
      <content type="html"><![CDATA[<p>#DAY 4  </p><p><strong>mv命令</strong><br>mv &lt;选项&gt; &lt;文件名&gt; &lt;文件名&gt;<br>用于移动覆盖文件或者给文件改名 （仅能单个改名）<br>常用选项：<br>    -i 覆盖前询问<br>    -f 强制覆盖</p><p>eg：改名<br>[root@Souler6 app]# ls<br>dir1  f1  f2  f3  f4<br>[root@Souler6 app]# mv f2 f5   #将f2改名为f5<br>[root@Souler6 app]# ls<br>dir1  f1  f3  f4  f5<br>eg：移动且改名<br>[root@Souler6 app]# ll<br>total 4<br>-rw-r–r–. 2 root root 0 Jul 26 09:35 f5  #注意创建时间<br>[root@Souler6 app]# ll dir1/<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f4<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f5<br>[root@Souler6 app]# mv f5 dir1/f6   #移动并改名<br>[root@Souler6 app]# ll dir1/<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f4<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f5<br>-rw-r–r–. 2 root root 0 Jul 26 09:35 f6  #f5移动且改名的文件f6，创建时间与f5相同<br>eg：移动改名且覆盖<br>[root@Souler6 app]# touch f5<br>[root@Souler6 app]# ll<br>total 4<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 f5 #注意创建时间<br>[root@Souler6 app]# ll dir1/<br>total 0<br>-rw-r–r–. 2 root root 0 Jul 26 09:35 f6 #注意创建时间<br>[root@Souler6 app]# mv f5 dir1/f6<br>mv: overwrite `dir1/f6’? y  ##文件已存在询问是否覆盖，加-f 可以强制覆盖<br>[root@Souler6 app]# ll dir1/<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 f6  #改名且覆盖后，时间也变了</p><p><strong>rename命令</strong></p><p>批量改名字<br>eg：<br>[root@Souler6 dir1]# ll<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f1<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f2<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f3<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f4<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 f5<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 f6<br>[root@Souler6 dir1]# rename ‘f’ ‘xcb’ f*<br>[root@Souler6 dir1]# ll<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb1<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb2<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb3<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</p><p><strong>rm命令  可还原的删除</strong><br>rm &lt;选项&gt;&lt;文件名&gt;..<br>常用选项：<br>-i 交互式，删除前询问<br>-f 强制性，不询问</p><p>eg：交互式删除<br>[root@Souler6 dir1]# ll<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb1<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb2<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb3<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6<br>[root@Souler6 dir1]# rm xcb1 xcb2 xcb3<br>rm: remove regular empty file <code>xcb1&#39;? yrm: remove regular empty file</code>xcb2’? y<br>rm: remove regular empty file `xcb3’? y<br>[root@Souler6 dir1]# ll<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</p><p>eg：强制删除<br>[root@Souler6 dir1]# ll<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb4<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6<br>[root@Souler6 dir1]# rm -f xcb4<br>[root@Souler6 dir1]# ll<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6</p><p>eg：删除目录 需要-r递归删除<br>[root@Souler6 app]# ll<br>total 4<br>drwxr-xr-x. 2 root root 4096 Jul 26 11:15 dir1<br>-rw-r–r–. 1 root root    0 Jul 26 09:35 f1<br>lrwxrwxrwx. 1 root root    7 Jul 26 09:37 f3 -&gt; /app/f1<br>lrwxrwxrwx. 1 root root    9 Jul 26 09:39 f4 -&gt; ../app/f1<br>-rw-r–r–. 1 root root    0 Jul 26 11:01 f6<br>[root@Souler6 app]# ll dir1/<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 10:54 xcb5<br>-rw-r–r–. 1 root root 0 Jul 26 11:03 xcb6<br>[root@Souler6 app]# rm -rf dir1/<br>[root@Souler6 app]# ll<br>total 0<br>-rw-r–r–. 1 root root 0 Jul 26 09:35 f1<br>lrwxrwxrwx. 1 root root 7 Jul 26 09:37 f3 -&gt; /app/f1<br>lrwxrwxrwx. 1 root root 9 Jul 26 09:39 f4 -&gt; ../app/f1<br>-rw-r–r–. 1 root root 0 Jul 26 11:01 ll f6</p><p>号外：利用alias命令与mv，创建一个垃圾箱trash<br>alias rm=”mv -t /trash”（利用-t选项 调换前后顺序）<br>删除大文件，急速为系统腾出空间，使用重定向原理&gt;</p><pre><code>$ dd if=/dev/zero of=bigfile bs=1M count=100 &gt; bigfile</code></pre><p>创建一个名为bigfile，大小为100M的文件。<br>再rm -rf 文件名</p><p>lsof |grep deleted</p><p>提问：删除文件的底层原理</p><p><strong>删除shred命令  相对比较安全的删除</strong></p><p>shred -zv -n5 &lt;文件名&gt;<br> n5表覆盖5次</p><p><strong>tree</strong><br>tree &lt;选项&gt;&lt;目录名&gt;<br>查看目录的树<br>tree -d 只看目录树<br>tree -L n 查看层数，n为层数<br>tree -P 配合通配符使用*</p><p><strong>dd命令</strong><br>dd if=/dev/zero of=bigfile bs=1M count=100<br>创建一个名为bigfile，大小为100M的文件。</p><p><strong>mkdir</strong><br>mkdir -p 自动创建不存在的子目录<br>创建空目录<br>eg：<br>[root@Souler6 ~]# mkdir  /app/dir1/{x/{a,b},y/{c,d}}<br>mkdir: cannot create directory <code>/app/dir1/x/a&#39;: No such file or directorymkdir: cannot create directory</code>/app/dir1/x/b’: No such file or directory<br>mkdir: cannot create directory <code>/app/dir1/y/c&#39;: No such file or directorymkdir: cannot create directory</code>/app/dir1/y/d’: No such file or directory<br>报错原因，因为没加-p选项，不会自动创建不存在的子目录，我们可以尝试加参数后在运行</p><p>[root@Souler6 ~]# mkdir -pv /app/dir1/{x/{a,b},y/{c,d}}<br>mkdir: created directory <code>/app/dir1&#39;mkdir: created directory</code>/app/dir1/x’<br>mkdir: created directory <code>/app/dir1/x/a&#39;mkdir: created directory</code>/app/dir1/x/b’<br>mkdir: created directory <code>/app/dir1/y&#39;mkdir: created directory</code>/app/dir1/y/c’<br>mkdir: created directory `/app/dir1/y/d’<br>加了-p选项就创建成功了，-v是显示创建过程</p><p>[root@Souler6 ~]# tree /app/dir1/<br>/app/dir1/<br>├── x<br>│   ├── a<br>│   └── b<br>└── y<br>    ├── c<br>    └── d</p><p>6 directories, 0 files<br>用目录树显示，想使用tree需自己安装。。<br><strong>rmdir</strong><br>rmdir -p  自动删除上一级空目录<br>只能删空目录<br>eg：<br>[root@Souler6 app]# mkdir -pv /app/dir1/dir2/{/dir3,/dir4/dir5/dir6}<br>mkdir: created directory <code>/app/dir1&#39;mkdir: created directory</code>/app/dir1/dir2’<br>mkdir: created directory <code>/app/dir1/dir2//dir3&#39;  mkdir: created directory</code>/app/dir1/dir2//dir4’<br>mkdir: created directory <code>/app/dir1/dir2//dir4/dir5&#39;mkdir: created directory</code>/app/dir1/dir2//dir4/dir5/dir6’<br>[root@Souler6 app]# tree /app/<br>/app/<br>└── dir1<br>    └── dir2<br>        ├── dir3<br>        └── dir4         有树目录可看出，dir2非空目录<br>            └── dir5<br>                └── dir6<br>6 directories, 0 files<br>[root@Souler6 app]# rmdir -pv /app/dir1/dir2/dir4/dir5/dir6/<br>rmdir: removing directory, <code>/app/dir1/dir2/dir4/dir5/dir6/&#39;rmdir: removing directory,</code>/app/dir1/dir2/dir4/dir5’<br>rmdir: removing directory, <code>/app/dir1/dir2/dir4&#39;rmdir: removing directory,</code>/app/dir1/dir2’<br>rmdir: failed to remove directory `/app/dir1/dir2’: Directory not empty  #删到过程能够看到报错了，由于目录dir2非空目录，停止删除<br>[root@Souler6 app]# tree /app/<br>/app/<br>└── dir1<br>    └── dir2<br>        └── dir3    对比上面的树目录中可以看到dir2目录下空的子目录已被清理<br>3 directories, 0 files<br>故，可印证rmdir只能删空目录，-p是将父目录为空的目录删除，逆向递归删除</p><p><strong>索引节点</strong><br>linux底层工作原理</p><p>inode（index node）<br>节点编号<br>inode number ,inode编号，是每个文件的唯一性，</p><p>   inode table 节点表 属于元数据<br>    节点编号，链接数（matadata）<br>   date block 数据块 属于数据<br>    1M、1G (data)<br>即时节点编号也有可能出现出现节点编号相同的情况</p><p>例如：分区所在挂载的目录节点编号相同</p><p>例如：在同一个分区中，节点编号相同即为同一个文件（涉及硬链接）</p><p>在不同分区中，即时节点编号相同也不是同一文件，每个分区中的节点编号不互通（分区挂载点除外）</p><p>节点编号是有限的，可回收利用<br>eg: f1的节点编号为52，删除f1后又创建f2的节点编号为52<br>   原因：由于f1被删除后，节点编号52空缺，之后会被分配给新创建的文件f2使用</p><p>  查看节点编号<br>    $ls -l -i</p><p>  查看节点编号的使用情况<br>    $ df -i </p><p><strong>硬链接</strong><br>独立，只能在同一个分区，不能跨设备，不能跨分区，局限性。<br>且多个硬链接文件所占的空间=单个源文件。可以理解为每一个硬链接都是给文件起了个新名字，所占用的资源不增加不减少。<br>文件夹不支持创建硬链接，节点编号不增长。</p><p>eg：<br>[root@Souler6 ~]# touch /app/f1<br>[root@Souler6 ~]# ll -i /app/<br>total 0<br>11 -rw-r–r–. 1 root root 0 Jul 26 09:35 f1  ##11是节点编号，2是硬链接<br>[root@Souler6 ~]# ln /app/f1 /app/f2<br>[root@Souler6 ~]# ll -i /app/<br>total 0<br>11 -rw-r–r–. 2 root root 145 Jul 26 09:35 f1<br>11 -rw-r–r–. 2 root root 145 Jul 26 09:35 f2<br>从上面的信息可以获取到 f1与f2是硬链接的关系，其节点编号相同，都为11，这两个文件是等同的，且所占空间为145个字节，而不是290个字节。<br>将f1删除，f2可以运行，不受影响。<br>将f2删除，f1可以运行，不受影响。<br>可以理解为，删除硬链接仅仅是将文件多个名字中去掉一个名字<br>但若是将f1，f2同时删除，此文件将不存在，且节点编号空缺出来，等待分配给新的文件</p><p>  创建硬链接<br>    $ ln f1 f2</p><p><strong>软链接</strong><br>仅仅只是一个快捷方式，每个软链接会占用一个节点编号，每个快捷方式所占空间与路径有关<br>可跨分区，依赖性：假如源文件被删除，则软链接失效。</p><p>同分区使用<br>[root@Souler6 ~]# ln -s /app/f1 /app/f3  （使用绝对路径）<br>[root@Souler6 ~]# ln -s ../app/f1 /app/f4  （使用相对路径）<br>[root@Souler6 ~]# ll -i /app/<br>total 0<br>11 -rw-r–r–. 2 root root 145 Jul 26 09:35 f1<br>11 -rw-r–r–. 2 root root 145 Jul 26 09:35 f2<br>12 lrwxrwxrwx. 1 root root 7 Jul 26 09:37 f3 -&gt; /app/f1<br>13 lrwxrwxrwx. 1 root root 9 Jul 26 09:39 f4 -&gt; ../app/f1</p><p>f3与f4都是f1的软链接，相当于f1的快捷方式，即时这样也不是同一个文件，可以看到f3与f4的节点编号不同，各自占用一个独立的节点编号。<br>以及可以看到f3指向的路径有7个字符占用7个字节，f4指向的路径有9个字符占用了9个字节，因此可以得出每个快捷方式所占空间与源文件无关，而是与路径的字符长度有关。</p><p>跨分区使用<br>[root@Souler6 ~]# ln -s ../app/f1 f4<br>[root@Souler6 ~]# ll -i /root/<br>total 104<br>134418 -rw——-. 1 root root  1456 Jul 17 11:08 anaconda-ks.cfg<br>153481 drwxr-xr-x. 2 root root  4096 Jul 26 08:57 Desktop<br>153485 drwxr-xr-x. 2 root root  4096 Jul 17 11:18 Documents<br>153482 drwxr-xr-x. 2 root root  4096 Jul 17 11:18 Downloads<br>153603 -rw-r–r–. 1 root root     0 Jul 26 09:34 f1<br>153615 lrwxrwxrwx. 1 root root     9 Jul 26 09:38 f4 -&gt; ../app/f1</p><p>可以看到快捷方式f4使用的节点编号，跟上面的f4是不一样的，差别很大<br>跨区创建所生成的软链接会按当前分区剩余的节点编号去分配节点。<br>可以看到/分区下 快捷方式f4的节点编号为153615<br>而分区/app下，快捷方式f4的节点编号为13。</p><p>多用相对路径<br>/dev/cdrom-&gt; sr0  光盘的快捷方式<br>创建软链接<br>ln -s f1 f2，<br>每个软链接独自分配一个不同的节点编号<br>多用相对路径</p><p>（<strong>分析 mv f1 f2  与 ln -s f1 f2 的底层原理</strong>）</p><p> mv f1 f2<br> 同分区中，改名，或者移动，并不会改变节点编号<br>[root@Souler6 mv]# ll -i<br>total 0<br>131074 -rw-r–r–. 1 root root 0 Jul 26 12:25 f1  #改名前<br>[root@Souler6 mv]# mv f1 ../f2    #移动f1并改名为f2<br>[root@Souler6 mv]# ll -i<br>total 0<br>[root@Souler6 mv]# ll -i ../<br>total 8<br>131074 -rw-r–r–. 1 root root    0 Jul 26 12:25 f2  #改名后，文件数据没任何变化<br>524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln<br>131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:29 mv<br>同分区中，改名且覆盖<br>[root@Souler6 mv]# touch f22  #创建一个新的文件f22<br>[root@Souler6 mv]# ll -i<br>total 0<br>131075 -rw-r–r–. 1 root root 0 Jul 26 12:31 f22  #f22节点编号131075<br>[root@Souler6 mv]# ll -i ../<br>total 8<br>131074 -rw-r–r–. 1 root root    0 Jul 26 12:25 f2  #f2节点编号为131074<br>524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln<br>131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:31 mv<br>[root@Souler6 mv]# mv f22 ../f2<br>mv: overwrite `../f2’? y         #因已存在f2文件，故改名后覆盖<br>[root@Souler6 mv]# ll -i ../<br>total 8<br>131075 -rw-r–r–. 1 root root    0 Jul 26 12:31 f2  #f2节点编号为131075，变了<br>524289 drwxr-xr-x. 2 root root 4096 Jul 26 12:27 ln<br>131073 drwxr-xr-x. 2 root root 4096 Jul 26 12:31 mv<br>跨分区移动<br>[root@Souler6 ~]# ll -i f1<br>153603 -rw-r–r–. 1 root root 0 Jul 26 09:34 f1<br>[root@Souler6 ~]# mv f1 /boot<br>[root@Souler6 ~]# ll -i /boot/f1<br>38 -rw-r–r–. 1 root root 0 Jul 26 09:34 /boot/f1 #注意，节点编号改变了</p><p>根据以上分析可以得出<br>同分区中<br>mv改名后，文件数据没任何变化<br>mv移动文件时，节点编号不会发生改变<br>mv覆盖文件时，会把节点编号一起覆盖掉<br>跨分区的移动<br>mv移动后，节点编号会发生改变</p><p>ln -s f1 f2<br>[root@Souler6 mv]# ll -i ../ln/<br>total 0<br>524290 -rw-r–r–. 1 root root 0 Jul 26 12:45 f1 #源文件的节点编号为524290<br>[root@Souler6 mv]# ln -s ../../app/ln/f1 /app/mv/f3 #可以理解成将相对路径下f1文件的快捷方式发送到绝对路径并起名为f3<br>[root@Souler6 mv]# ll -i ../mv/<br>total 0<br>131076 lrwxrwxrwx. 1 root root 10 Jul 26 13:01 f3 -&gt; ../../app/ln/f1#快捷方式的节点为131076<br>[root@Souler6 mv]# tree /app/<br>/app/<br>├── f2<br>├── ln<br>│   └── f1<br>└── mv<br>    └── f3 -&gt; /app/ln/f1<br>2 directories, 3 files<br>根据以上分析可以得出，<br>创建快捷方式需指定相对路径，再指定存放的绝对路径<br>快捷方式也会被单独分配一个节点，且所占大小与路径字符有关<br>创建同分区中和跨分区的软链接<br>ln -s 软链接都会被分配一个新的节点编号<br>（待分析）</p><p><strong>xargs touch  突破创建文件个数的限制</strong>（待补充）</p><p><strong>关于磁盘存储内部工作原理</strong><br>inode 表结构的直接指针与间接指针<br>直接指针<br>12共有个直接指针，每个指针指向一个大小为4k的数据块，最多存储48k，但存储的数据超过48k则需要用到间接指针来存储更大的数据<br>间接指针<br>一个间接指针占4个字节byte<br>一个数据块占4k，4k=4<em>1024byte<br>所以1个数据块中有1024个间接指针<br>一级间接指针 4MB<br>间接指针指向下一个文件块的指针，文件块的大小为4k，每个指针占4个byte，故可以理解为该文件块下有1024个指针，1024个指针分别指向1024个4k的数据块，故可存放文件的大小为1024</em>4k=4MB<br>二级间接指针 4GB<br>间接指针指向下一个文件块的指针，文件块的大小为4k，每个指针占4个byte，故可以理解为该文件块下有1024个指针，1024个指针分别指向1024个文件块，这种又衍生除了1024<em>1024个指针，这1024</em>1024个指针再次指向数据块，每个数据块大小为4k，故可存放的文件大小为1024<em>1024</em>4k=4GB<br>三级间接指针 4TB<br>与二级指针同理，故可存放的文件大小为1024<em>1024</em>1024*4k=4TB</p><p><strong>文件内容file</strong><br>在linux中，不注重后缀，一般情况下更改后缀不影响程序的运行<br>file [选项] &lt;文件名&gt;</p><p>也可以通过hexdump查看开头作出判断<br>hexdump -C -n 100  &lt;文件名&gt;</p><p><strong>标准I/O和管道</strong></p><p> input：输入数据   ouput：输出数据<br>文件描述符<br>    打开的文件都有一个fd：file descriptor(文件描述符)<br>进程运行会产生文件描述符<br>    自动生成的文件描述符存储在/proc/PID/fd中，PID是一个数字（进程编号）<br>    查看进程<br>       $ ps|aux<br>linux中给程序提供的三种I/O设备<br>    标准输入 STDIN    0 默认位置：键盘<br>    标准输出 STDOUT   1 默认位置：当前终端窗口<br>    标准错误 STDERR   2 默认位置：当前终端窗口<br>I/O重定向：改变默认位置</p><p><strong>把输出和错误重定向到文件</strong></p><p>大致讲一下标准输入、标准输出、标准错误的概念<br>[root@Souler6 app]# ll /app/ /error/  # 一般我们在键盘中敲入命令，这就是标准输入STDIN（0）<br>ls: cannot access /error/: No such file or directory # 执行命令后由于/error文件不存在，故，报错，这种就是标准错误STDERR（2）标准错误会默认打印在当前终端窗口<br>/app/:       #/app存在，故，这是一个标准输出STDOUT（1）标准输出会默认打印在当前终端窗口<br>total 12<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:12 d1<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:12 d2</p><p>下面举例子详细说明：  ‘&gt;’可以用于重定向, ‘&gt;&gt;’ 用于重定向的追加  </p><p>[root@Souler6 app]# ls<br>d1  d2<br>[root@Souler6 app]# ll /app/ /error/ &gt; 1.txt #标准输入，但是’&gt;’已经将标准输出进行了重定向，故屏幕不打印标准输出，只打印了标准错误<br>ls: cannot access /error/: No such file or directory<br>[root@Souler6 app]# cat 1.txt  # 查看1.txt中是不是真的打印了标准输出<br>/app/:      #这是本来应该被打印在屏幕上的标准输出，但’&gt;’对其进行了重定向<br>total 8<br>-rw-r–r–. 1 root root    0 Jul 26 10:33 1.txt  #这是创建用于存放标准输出的文件，因为ll在打印前就对1.txt进行了列出命令，初始大小为0，实际上它的大小已经不是0了，我们可以理解为是 ‘ll命令的速度’比‘重定向打印的速度快’。<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2<br>[root@Souler6 app]# ll     #查看1.txt的大小<br>total 12<br>-rw-r–r–. 1 root root  153 Jul 26 10:33 1.txt  #可以看到占用了153个字节<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2<br>[root@Souler6 app]# ll /app/ /error/ &gt;&gt; 1.txt  #使用’&gt;&gt;’表示追加打印，不加则会覆盖<br>ls: cannot access /error/: No such file or directory<br>[root@Souler6 app]# cat 1.txt  # 可以看到标准输出追加到了原有内容的下边<br>/app/:<br>total 8<br>-rw-r–r–. 1 root root    0 Jul 26 10:33 1.txt<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2<br>/app/:<br>total 12<br>-rw-r–r–. 1 root root  153 Jul 26 10:33 1.txt<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2<br>[root@Souler6 app]# ll<br>total 12<br>-rw-r–r–. 1 root root  307 Jul 26 10:48 1.txt  #由于内容追加，文件大小从153字节增长到了307字节<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2</p><p>从上文可以看到三种I/O他们都带着一个数字<br>STDIN（0）,STDOUT（1）,STDERR2（2）<br>那这些数字是代表什么呢<br>实际上 ‘&gt;’是’1&gt;’ 我们可以这样理解 1&gt;重定向标准输出（数字具体表现在这）<br>有’1&gt;’当然还有’2&gt;’ 我们可以这样理解 2&gt;重定向标准错误（数字具体表现在这）<br>通过上面的例子<br>eg:我们直接尝试把标准错误追加到1.txt （也可以）<br>[root@Souler6 app]# ll /app/ /error/ 2&gt; 1.txt  #把标准错误重定向至1.txt中打印<br>/app/:      #没有重定向标准输出，故默认在屏幕中打印<br>total 12<br>-rw-r–r–. 1 root root   53 Jul 26 11:07 1.txt<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d1<br>drwxr-xr-x. 2 root root 4096 Jul 26 10:32 d2<br>[root@Souler6 app]# cat 1.txt # 查看1.txt是否打印了标准错误<br>ls: cannot access /error/: No such file or directory #可以看到打印了标准错误，文件中内容不再有之前的标准输出，可以说明由于不是重定向追加，所以直接覆盖了原文件1.txt</p><p>关于重定向的语法…</p><p> eg：&gt; 重定向标准输出<br> eg：&gt;&gt; 重定向标准输出追加<br> eg：2&gt;重定向标准错误<br> eg：2&gt;&gt;重定向标准错误追加<br> eg：set -C 重定向不覆盖<br> eg：set +C 重定向覆盖<br> eg：&gt;|重定向强行覆盖 （用于忽略set -C）<br> eg：2&gt;&amp;1 将2（标准错误）重定向到1（标准输出）<br> eg：1&gt;&amp;2 将1（标准输出）重定向到2（标准错误）<br> eg：’&amp;&gt;’等同于’2&gt;&amp;1’把标准错误重定向为标准输出,<br>   (‘&amp;&gt;’兼容性不如’2&gt;&amp;1’,二者重定向意思等同)</p><p><strong>面试题:以下哪个与众不同</strong></p><p>A app.sh &gt; f1.log 2&gt;&amp;1<br>B app.sh 2&gt;&amp;1 &gt; f1.log<br>C app.sh 2&gt;f1.log 1&gt;&amp;2<br>D app.sh &amp;&gt;f1.log</p><p>答案：B. </p><p><strong>标准输入tr</strong><br>tr命令<br>既有标准输入，也有标准输出<br>tr可以使用’&lt;’重定向输入，’&gt;’重定向输入<br>举个简单例子：将1.txt内容中的小写字母转换为大写字母<br>[root@Souler6 app]# cat 1.txt<br>ls: cannot access /error/: No such file or directory<br>ls: cannot access /error/: No such file or directory<br>[root@Souler6 app]# tr ‘a-z’ ‘A-Z’ &lt; 1.txt  #将1.txt的内容重定向为标准输入<br>LS: CANNOT ACCESS /ERROR/: NO SUCH FILE OR DIRECTORY<br>LS: CANNOT ACCESS /ERROR/: NO SUCH FILE OR DIRECTORY</p><p>把多行发送给STDIN<br>使用“&lt;&lt;终止词”命令从键盘把多行重导向给STDIN直到终止词位置<br>cat &gt; file &lt;&lt; EOF<br>举个简单的例子<br>[root@Souler6 app]# cat &gt; 1.txt &lt;&lt;EOF</p><blockquote><p>123<br>456<br>789<br>EOF<br>[root@Souler6 app]# cat 1.txt<br>123<br>456<br>789 </p></blockquote><p>（EOF可以是任意字符）</p><p><strong>管道</strong></p><p>用符号’|’表示<br>cmd1|cmd2|cmd3|…<br>多个命令的链接，最后的命令会基于上一命令的基础，对内容进行再处理进行输出<br>举个简单例子：</p><p>[root@Souler6 app]# ll 1.txt   #未加管道<br>-rw-r–r–. 1 root root 106 Jul 26 11:15 1.txt<br>[root@Souler6 app]# ll 1.txt | tr ‘a-z’ ‘A-Z’ #加管道进行大小写字母转换，并输出<br>-RW-R–R–. 1 ROOT ROOT 106 JUL 26 11:15 1.TXT</p><p><strong>tee</strong><br>用于管道中打印子shell的标准输出</p><h1 id="（待补充）"><a href="#（待补充）" class="headerlink" title="（待补充）"></a>（待补充）</h1><p>未完待续…</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>关于文件系统，以及history、cd、ls、touch、cp命令以及通配符</title>
      <link href="/2018/07/25/%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BB%A5%E5%8F%8Ahistory%E3%80%81cd%E3%80%81ls%E3%80%81touch%E3%80%81cp%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/07/25/%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%BB%A5%E5%8F%8Ahistory%E3%80%81cd%E3%80%81ls%E3%80%81touch%E3%80%81cp%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p><strong>==DAY 3==</strong></p><p><strong>命令行扩展、被括起来的集合</strong></p><pre><code>``  $()  把一个命令的输出打印给另一个命令的参数&quot;&quot;弱引用 ，&apos;&apos;强引用{} 打印重复字符串的简化形式</code></pre><p><strong>文件通配符</strong></p><pre><code>*        --&gt; 匹配任意个字符？       --&gt; 匹配单个字符~        --&gt; 当前用户家目录~mage    --&gt; 用户mage家目录~+       --&gt; 当前工作目录~-       --&gt; 前一个工作目录[0-9]:   --&gt; 匹配数字范围[a-z]:   --&gt; 小写字母[A-Z]:   --&gt; 大写字母[qwer]   --&gt; 匹配列表中的任何的一个字符[^qwer]  --&gt; 匹配列表中的所有字符以外的字符预定义支付类： man 7 glob[:digit:]：任意数字，相当于0-9[:lower:]：任意小写字母[:upper:]: 任意大写字母[:alpha:]: 任意大小写字母[:alnum:]：任意数字或字母[:blank:]：水平空白字符[:space:]：水平或垂直空白字符[:punct:]：标点符号[:print:]：可打印字符[:cntrl:]：控制（非打印）字符[:graph:]：图形字符[:xdigit:]：十六进制字符</code></pre><p><strong>TAB键补全命令</strong></p><pre><code>前提是安装了程序 bash-completion查看该安装包版本 $rpm -qa bash-completion&lt;&gt;.noarch centos 6支持命令、目录的补全；不支持补全命令选项参数centos 7支持命令、目录的补全；支持补全命令选项参数</code></pre><p><strong>history命令</strong></p><pre><code>history命令用于显示指定数目的指令命令，读取历史命令文件中的目录到历史缓存区和将历史命令缓存区中的目录写入命令文件。该命令单独使用时，仅显示历史命令，在命令行中，可以使用符号!执行指定序号的历史命令。例如，要执行第2个历史命令，则输入!2。历史命令是被保存在内存中的，当退出或者登录Shell时，会自动保存或读取。在内存中，历史命令仅能够存储1000条历史命令，该数量是由环境变量HISTSIZE进行控制。  每个用户的家目录下有个 .bash_history的文件，是专门存放用户所输入的命令历史。.bash_history（并非即时记录，用户登出才会将history追加入文件，不正常关机则无法写入文件）1.命令格式history [选项][参数]2.命令功能可单独用于查看历史命令，也可配合参数调用或删除历史命令。3.命令参数-c  (常用)清除内存中的历史列表-d &lt;n&gt; 清除第n条命令&lt;n&gt;（常用）显示最近n条历史记录-a将当前的历史记录行追加到历史记录文件-r 读取未读取的历史-w &lt;文件名&gt; 将当前历史写到指定文件中-p  执行且不留历史记录-s  伪造历史记录，但不执行</code></pre><p><strong>关于history调用</strong></p><pre><code>调用历史命令，n是命历史命令编号!n 执行上一条命令!!      执行前一条命令，去除参数!:0     补全上一个命令Esc，.     补全上一个命令按住alt+. </code></pre><p><strong>关于命令历史相关变量</strong></p><pre><code>HISTSIZE  历史记录条数HISTFILE  存储历史文件HISTFILESIZE  命令历史文件记录历史条数HISTTIMEFORMAT= &quot;%F %T&quot; 显示时间HISTIGNORE=&quot;str1:str2* &quot; 忽略str1命令，str2开头的历史</code></pre><p><strong>控制历史命令记录的方式</strong></p><pre><code>环境变量：HISTCONTROLignoredups: 忽略重复的命令；连续且相同方为”重复“ignorespace: 忽略所有空白开头的命令ignoreboth: ignoredups,ignorespaceerasedups: 删除重复命令Export 变量名=&quot;值存放在 /etc/profile或 ~/.bash_profile</code></pre><p><strong>bash快捷键</strong></p><pre><code>Ctrl + l清屏，相当于clear命令 Ctrl + o执行当前命令，并重新显示本命令 Ctrl + s阻止屏幕输出，锁定 Ctrl + q 允许屏幕输出 Ctrl + c终止命令Ctrl + z挂起命令bash的快捷键Ctrl + a光标移到命令行首，相当于HomeCtrl + e光标移到命令行尾，相当于EndCtrl + f光标向右移动一个字符Ctrl + b光标向左移动一个字符Alt + f光标向右移动一个单词尾Alt + b光标向左移动一个单词首Ctrl + xx光标在命令行首和光标之间移动Ctrl + u从光标处删除至命令行首Ctrl + k从光标处删除至命令行尾Alt + r    删除当前整行bash的快捷键Ctrl + w从光标处向左删除至单词首Alt + d从光标处向右删除至单词尾Ctrl + d删除光标处的一个字符Ctrl + h删除光标前的一个字符Ctrl + y将删除的字符粘贴至光标后Alt + c从光标处开始向右更改为首字母大写的单词Alt + u从光标处开始，将右边一个单词更改为大写Alt + l从光标处开始，将右边一个单词更改为小写Ctrl + t交换光标处和之前的字符位置Alt + t交换光标处和之前的单词位置Alt + N提示输入指定字符后，重复显示该字符N次注意：Alt组合快捷键经常和其它软件冲突</code></pre><p><strong>实验：录屏</strong>（多用于动态演示）</p><pre><code> 创建一个录屏命令 （用于复现）复现$ script -t 2&gt; time.log -a cmd.session$ .....$ .....$ ..... 退出录屏$exit 复现录像$ scriptptreplay time.log cmd.session</code></pre><p><strong>文件系统分层结构  LSB</strong></p><pre><code>/bin -&gt;/usr/bin 存放供用户使用的二进制程序/boot 引导程序文件，例如：kernel/dev  存放设备文件   brw------- b打头  块设备，随机访问   crw------- c打头  字符设备，线性访问/etc  存放系统范围内的配置文件，，可编辑的文本配置  /etc/opt  opt的配置文件  /etc/X11  X Windows系统的配置文件  /etc/sgml SGML的配置文件  /etc/xml  XML的配置文件/usr   用户存储只读用户数据的第二层次，包含绝大多数的（多）用户工具和应用程序/home  普通用户的家目录，保存用户个人的配置文件，一般为单独的分区/lib   /bin/和/sbin/中二进制文件必要的库文件/sbin  给管理员使用的二进制程序/media 可移除媒体的挂载点，图形界面下，自动充当光盘挂载点，代替/run/media/misc  命令行界面,普通用户手动挂载（进入该文件夹/misc/cd，则自动挂载光盘，不进入则不挂在）     $ systemctl start autofs     $ systemctl enable autofs       查看块设备      $ df/mnt   临时挂载的文件系统，超级用户手动挂载 $ mount /dev/sr0 /mnt/opt   可选应用软件包/proc  虚拟文件系统，，将内核与进程状态归档为文本文件，存放于内存，磁盘中所占空间为0，修改文件立即生效，但断电后数据丢失，数据修改不保存。/sys  虚拟文件系统，存放于内存，映射硬件信息      当识别不出块设备，扫描所有磁盘      $ echo &apos;- - -&apos; &gt; /sys/class/scsi_host/host2/scan/root  超级用户的家目录/sbin  必要的系统二进制文件/srv   站点的具体数据，由系统提供/data/run  不属于linux标准目录，代替/var/run/var  动态文件————在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。有时是一个单独的分区，亦可称为变量文件/tmp  临时文件，在系统重启时目录中文件不会被保留标准可参考 FHS国际规范 </code></pre><p><strong>文件系统</strong></p><pre><code>rootfs： root filesystem文件名大小写区分看文件系统：eg：  文件系统 xfs 严格区分大小写  文件系统 vfat 不区分大小写 文件有两类数据： 数据：data   存放数据的内容 元数据：metadata 存放数据的属性     </code></pre><p><strong>文件特性</strong></p><pre><code>查看文件类型的颜色规则$ cat /etc/DIR_COLOR   蓝色--&gt;目录绿色--&gt;可执行文件红色--&gt;压缩文件浅蓝色--&gt;链接文件灰色--&gt;其他文件亮黄色--&gt;设备文件查看文件类型drwxr-xr-x.  5 root root      231 Jul 18 14:49 vmware-toolseg： 文件类型由字符串drwxr-xr-x的第一位来表示，当前字符串第一位为d，由此我们可以得出该文件类型是目录文件-：普通文件d：目录文件b：块设备c：字符设备l：符号链接文件p：管道文件pises：套接字文件socker</code></pre><p><strong>显示当前工作目录</strong></p><pre><code>pwd命令$ pwd 显示连接路径$ pwd -P  显示真实物理路径  路径分为两种：相对路径，绝对路径  相对路径（方便文件转移后的运行）    不以正斜杠开始    指定相对于当前工作目录或某目录的位置    eg：      $ cd home/xu     在每个目录下都有&apos;.&apos;和&apos;..&apos; ，相对路径中经常会使用到     &apos;.&apos;表当前目录，&apos;..&apos;表父目录  绝对路径    以正斜杠开始    完整的路径位置    eg:      $cd /home/xu基名：basename目录名：dirname</code></pre><p><strong>cd命令</strong></p><pre><code>用于切换目录1.命令格式 cd &lt;路径&gt;2.命令功能 使用绝对或相对路径切换目录3.命令参数cd   切换至当前用户主目录cd ..  切换至父目录cd ~  切换到当前登录用户的家目录cd ~用户名  切换到指定用户家目录cd -    切换回上次的目录，原理：由变量$OLDPWD控制  可以手动更改变量 $OLDPWD=/路径名</code></pre><p><strong>ls命令</strong></p><pre><code>ls命令是linux下最常用的命令。ls命令就是list的缩写，ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多!1.命令格式ls [选项][参数]2.命令功能列出名表目录中所有的子目录和文件3.命令参数-d，列出目录本身，而不是其内容-a，列出所有文件以及文件夹（包括隐藏）-l使用长列表格式-A，不列出&apos;.&apos;(表当前目录)和&apos;..&apos;（表当前目录的父目录）-u，--time=atime, --time=access,--time= use与-l配合使用，显示访问时间-c，--time=ctime, --time=status与-l配合使用，显示权限修改时间-1 显示另一列文件-S 按文件从大到小排序-r，排序时的逆序-Sr 反转，按文件小到大排序-R，以递归方式列出子目录-X 按后缀排序  -U不排序;按目录顺序列出条目-p，追加/指标到目录-n， -num-uid-gid像-l，但列出数字用户和组ID-o像-l，但不列出组信息（还有一些不懂怎么用，没列出来）</code></pre><p><strong>touch命令</strong></p><pre><code>linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。1.命令格式touch [选项]..文件名..2.命令功能创建一个不存在的文件。touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。3.命令参数-r &lt;指定文档&gt; &lt;参考文档&gt;将文件时间与指定参考文件时间对齐。-c &lt;文件名&gt;若文件名不存在，则不创建。-t[[CC]YY]MMDDhhmm[.SS] &lt;文件名&gt; 设定文件的时间戳[[CC]YY]MMDDhhmm[.SS]eg：2018年07月24日14点20分00秒;对应格式：201807241420.00 -m 配合-t使用，修改Modify time 修改时间-a 配合-t使用，修改Acess time 访问时间</code></pre><p><strong>cp命令</strong></p><pre><code>cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 1.命令格式cp[选项].. 源 目的2.命令功能将源文件复制至目标文件，或将多个源文件复制至目标目录。3.命令参数-a,-archive与-dR --preserve = all相同--attributes-only不要复制文件数据，只复制属性 -i 覆盖前询问-n不覆盖已存在的文件--backup[=CONTROL]备份每个现有目标文件,接受参数-b像--backup但不接受参数--copy-contents递归时复制特殊文件的内容-d与--no-dereference --preserve=links相同-f,--force如果无法打开现有目标文件，请将其删除并尝试再次（当使用-n选项时忽略此选项）-H遵循SOURCE中的命令行符号链接-l,--link硬链接文件而不是复制-L,--dereference始终遵循SOURCE中的符号链接-P,--no-dereference永远不要在SOURCE中关注符号链接-p与--preserve = mode，ownership，timestamps相同</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>个人blog搭建（纯属笔记，不做任何解释）</title>
      <link href="/2018/07/22/%E4%B8%AA%E4%BA%BAblog%E6%90%AD%E5%BB%BA%EF%BC%88%E7%BA%AF%E5%B1%9E%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%B8%8D%E5%81%9A%E4%BB%BB%E4%BD%95%E8%A7%A3%E9%87%8A%EF%BC%89/"/>
      <url>/2018/07/22/%E4%B8%AA%E4%BA%BAblog%E6%90%AD%E5%BB%BA%EF%BC%88%E7%BA%AF%E5%B1%9E%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%B8%8D%E5%81%9A%E4%BB%BB%E4%BD%95%E8%A7%A3%E9%87%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>==<strong>windows下搭建hexo</strong>==</p><p>大致浏览即可，细节操作在下面的总结那<br>一.环境准备</p><p>1.安装node.js(npm也在安装包中)（默认安装即可，一路Next。。）<br>    安装包：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><pre><code>为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的</code></pre><p>   检查安装是否成功,出现版本号则说明 Node.js 环境配置成功<br>    node -v、npm -v</p><p>2.安装git（默认安装即可，也是一路Next。。）<br>    安装包：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a></p><pre><code>为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上</code></pre><p>   检查安装是否成功,出现版本号则说明 git 环境配置成功<br>    git -v<br>3.安装控制台Cmder（默认安装即可）<br>    安装包：<a href="http://cmder.net/" target="_blank" rel="noopener">http://cmder.net/</a></p><p>#个人使用爱好，可不装，用Windows自带cmd即可</p><p>4.安装Sublime Text 3（默认安装即可）<br>    安装包：<a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">https://www.sublimetext.com/3</a></p><p>#只要是支持.md的文本工具即可</p><p>二.GitHub的注册和配置<br>    官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p><p>1.拥有一个GitHub账号，没有的话去官网注册一下，很简单就不多说了<br>    官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a><br>2.在GitHub创建一个仓库</p><h1 id="yourname-必须是你的用户名。"><a href="#yourname-必须是你的用户名。" class="headerlink" title="yourname 必须是你的用户名。"></a>yourname 必须是你的用户名。</h1><pre><code>图片1（待上传）图片2（待上传） . . .</code></pre><p>3.配置SSH密钥</p><p>   1）在桌面空白处鼠标右键打开Git bash here,键入命令（$ 无需键入..）<br>    $ ssh-keygen -t rsa -C “your’s emaill address”<br>   引号内填入你注册时所用的邮箱，回车<br>   显示你ssh密钥生成后保存的目录，直接回车确认（记住目录名，后面要找它拿东西的）<br>   会提示你设置密码（需要输入两次，密码看不见的）设置完密码之后<br>   会生成两个文件&lt;id_rsa&gt;、&lt;id_rsa.pub&gt;<br>   前往目录寻找文件&lt;id_rsa.pub&gt;，使用sublime text3 打开，并复制所有内容<br>   2）将SSH密钥存入GitHub</p><h1 id="ssh-T-git-github-com-选择性设置，用于设置自动填入密码"><a href="#ssh-T-git-github-com-选择性设置，用于设置自动填入密码" class="headerlink" title="$ ssh -T git@github.com(选择性设置，用于设置自动填入密码)"></a>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>(选择性设置，用于设置自动填入密码)</h1><pre><code>图片1（待上传）图片2（待上传） . .</code></pre><p>三.环境配置完成，开始安装Hexo，以及利用hexo建立本地网站</p><p>1.win+r 打开Cmder控制台，键入命令</p><pre><code>$ npm install -g hexo-cli</code></pre><p>  会报错，正常现象<br>    npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\chokidar\node_modules\fsevents):<br>    npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for <a href="mailto:fsevents@1.0.17" target="_blank" rel="noopener">fsevents@1.0.17</a>: wanted {“os”:”darwin”,”arch”:”any”} (current: {“os”:”win32”,”arch”:”x64”})<br>关于这个两个报错：fsevent是mac osx系统的，你是在win或者Linux下使用了 所以会有警告，忽略即可</p><p>   安装需要点时间，请耐心等待，安装成功后会有提示<br>    $ hexo -v<br>   检查安装是否成功,出现版本号则说明 hexo 安装成功</p><p>2.在任意一个分区创建任意一个文件夹，并该目录建立网站</p><p>#路径中不要有中文<br>    eg:创建test文件夹，路径为F:\test<br>git<br>    hexo init f:\test         创建一个网站，可能需要等待一小会，耐心等待<br>  成功提示：INFO  Start blogging with Hexo!</p><p>3.配置test目录下的_config.yml，生成静态文件<br>    配置_config.yml，用sublime text3 打开编辑并保存<br>  直接到文本尾部</p><pre><code># Deployment   deploy:     type: git     repository: https://github.com/xucanbin/xucanbin.github.io.git     branch: master$ npm install hexo-deployer-git --save         安装一个插件</code></pre><p>  在test目录中，鼠标右键打开git bash  </p><pre><code>$ ls            检查下目录下是不是出现多个文件，都是用于搭建网站的，这就是hexo的强大之处了$ hexo g        生成静态文件。$ hexo s        启动服务器。默认情况下，访问网址为： http://localhost:4000/</code></pre><p>   尝试能否访问<a href="http://localhost:4000/，当然这只是本地的网页，没什么用。" target="_blank" rel="noopener">http://localhost:4000/，当然这只是本地的网页，没什么用。</a><br>   成功则如图<br>   由于source目录下自带一篇hello world文章，所以你网页上自动生成了。</p><p>四.配置test目录下的_config.yml</p><p>五.将hexo建立网站的目录（亦可称为本地仓库）与github同步</p><p> 在test目录下，新建一个README.md，并鼠标右键打开git bash<br> 并新建一个README.md ，用sublime text 3 打开编辑随意写点东西，后面会用到</p><p>将当前目录转变成一个 Git 仓库</p><pre><code>$ git init </code></pre><p>配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息</p><pre><code>$ git config --global user.name &quot;Your&apos;s name&quot;           引号中填自己的GitHub账号$ git config --global user.email &quot;Your&apos;s email address&quot; 引号中填注册GitHub的邮箱$ git add README.md       将README.md添加到索引$ git commit -m &quot;first commit&quot;添加远程仓库$ git remote add origin git@github.com:yourname/yourname.github.io.git$ ssh -T git@github.com$ git push -u origin master$ hexo g$ hexo d</code></pre><p>二次总结</p><p>关于搭建个人博客的事情我自己总结了几点</p><p>hexo 是帮你搭建了一个本地网站</p><p>git 是用于配置giuhub上的仓库以及ssh密钥</p><p>node.js的话，主要是其环境下的npm，依赖npm去安装hexo </p><p>我们创建自己的博客网站 其实就是把hexo创建的本地网站 所生成的静态页面部署到GitHub上<br>请准备好<git>好&lt;node.js&gt;环境，才能开始下列操作<br>实现部署的前提，拥有一个github账号以及在github上创建一个库命名格式为&lt;账号名.github.io.git&gt;</git></p><p>#命名格式必须遵守，不然无法成功（目前我是找不到其他方法啦）<br>1.安装并使用hexo,生成本地网站之后，配置本地网站中的_config.yml</p><pre><code>$ npm install -g hexo-cli   (还未分清楚用cmd还是git-bash安装，待测试)$ hexo --version    </code></pre><p>2.使用hexo建立本地网站</p><pre><code>$ hexo init &lt;目录名&gt;         亦可进入目录下打开git-bash键入</code></pre><p>3.生成静态页面，也就是你未来的blog网站，</p><pre><code>$ hexo g</code></pre><p>##｛以下操作可跳过<br>       $ hexo s       启动服务器，尝试进入本地网站，正常的话可以访问：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> </p><p>##以上操作可跳过｝</p><p>4.配置本地网站中的_config.yml</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><pre><code>deploy:  type: git  repository: https://github.com/xucanbin/xucanbin.github.io.git  branch: master</code></pre><p>5.安装hexo的deployer插件（必须装的插件）</p><pre><code>$ npm install hexo-deployer-git --save  (成功提示待测试)</code></pre><p>6.本地git仓库（这是把本地网站目录转换为git仓库的操作，我记得会有有一个.git）</p><pre><code>$ git init &lt; 目录名&gt;    亦可进入目录下打开git bash 直接键入</code></pre><p>7.ssh密钥   (使用git-bash)</p><pre><code>$ ssh-keygen -t rsa -C &quot;your&apos;s emaill address&quot; </code></pre><p>   引号内填入你注册时所用的邮箱，回车<br>   显示你ssh密钥生成后保存的目录，直接回车确认（记住目录名，后面要找它拿东西的）<br>   会提示你设置密码（需要输入两次，密码看不见的）设置完密码之后<br>   会生成两个文件&lt;id_rsa&gt;、&lt;id_rsa.pub&gt;<br>   前往目录寻找文件&lt;id_rsa.pub&gt;，使用sublime text3 打开，并复制所有内容<br>   将SSH密钥存入GitHub，附图片</p><p>##（待上传）##<br>8.配置你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息<br>      （在仓库目录下打开git-bash） </p><pre><code>$ git config --global user.name &quot;Your&apos;s name&quot;           引号中填自己的GitHub账号$ git config --global user.email &quot;Your&apos;s email address&quot; 引号中填注册GitHub的邮箱$ git add README.md               将README.md添加到索引$ git commit -m &quot;first commit&quot;    记录对存储库的更改,使用给定的&quot;&quot;first commit&quot;&quot;作为提交消息</code></pre><p>9.添加git远程仓库（在仓库目录下打开git-bash）<br>  添加远程仓库</p><pre><code>$ git remote add origin git@github.com:xucanbin/xucanbin.github.io.git</code></pre><p>10.推送到远程仓库（将 master 分支推送到 origin 服务器）（在仓库目录下打开git-bash）</p><pre><code>$ git push origin master</code></pre><p>11.基于被配置完后的_config.yml,再次生成静态网页（在仓库目录下打开git-bash）</p><pre><code>$hexo g</code></pre><p>12.将第二次生成的静态网页部署到git的远程仓库中（在仓库目录下打开git-bash）</p><pre><code>$hexo d        后续弹出一个窗口 输入git用户名以及密码</code></pre><p>基础搭建完成<br>test目录下 f:\test\source_post\<br>上传文章的方法</p><p>以后写的博客直接放在里面，格式要求 后缀的.md<br>git-bash下</p><pre><code>$ hexo g$ hexo d$ git push origin master</code></pre><p>最后，打开自己的博客就能看到文章所在。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>linux基础知识</title>
      <link href="/2018/07/21/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/07/21/linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<p>==<strong>DAY 1</strong>==</p><h2 id="认识计算机"><a href="#认识计算机" class="headerlink" title="认识计算机"></a>认识计算机</h2><p><strong>世界上第一台计算机</strong></p><pre><code>计算机：一种能接受和存储信息，对海量数据进行自动、高速地处理，并输出结果的现代化智能设备。</code></pre><p><strong>冯·诺依曼体系结构</strong>：1946年数学家冯·诺依曼提出计算机有5个组成部分：运算器、控制器、存储器（主存储器、辅助存储器）、输入设备、输出设备。</p><pre><code>1946年，世界上第一台计算机在美国滨州大学诞生。占地170平方米，重达30吨。</code></pre><p>计算机发展历史：</p><pre><code>第一代（电子管时代）：1946-1957  第二代（晶体管时代）：1958-1964第三代（集成电路时代）：1965-1970第四代（大规模集成电路时代）：1971以后```</code></pre><p><strong>计算机系统</strong></p><p>1.硬件系统</p><pre><code>主机     中央处理器CPU          运算器ALU          控制器CU     内部存储器          rom          ram（断电丢失数据） 外部设备     外部存储器：硬盘、U盘     输入设备：鼠标、键盘     输出设备：显示屏、打印机、音频</code></pre><p>2.软件系统</p><pre><code>系统软件：     操作系统：win7、linux、mac     程序语言处理系统     数据库服务系统     服务程序：检查、诊断、调试程序应用软件：     通用应用软件--如QQ、office办公     专用应用软件--用户程序</code></pre><p><strong>服务器种类</strong></p><pre><code> 塔式服务器tower机架式服务器rack规格：宽度为19英寸，高度以U为单位，如42U（约2米高）。       1U=44.45毫米=1.75英寸。配件：     KVM（Keyboard Video Mouse）     PDU (Power Distribution Unit)刀片式服务器blade</code></pre><p><strong>存储网络：</strong></p><pre><code>DAS---直接连接存储(direct attached storage)与主机紧密相连     优点：         管理成本低，实施简单。     缺点：         存储共享受到限制。         不利于CPU的指令周期优化，增加系统负担。NAS---网络连接存储(network attached storage)基于文件协议（NFS、SMB/CIFS）,实现文件共享，适用于局域网或较小的网络     优点：         集中管理数据，从而释放带宽，提高性能。         可提供跨平台文件共享功能。     缺点：         可靠性差。    SAN---存储区域网络(storage area networks)基于SCSI、IP、ATM等多种高级协议，实现存储共享     优点：         服务器跟储存装置两者各司其职，         高效能、高稳定度的存储环境。     缺点：         实施复杂，管理成本高。</code></pre><p><strong>操作系统</strong><br>(Operating System)：</p><pre><code>OS功能：     硬件驱动、进程管理、内存管理、网络管理、安全管理、文件管理。OS分类：     服务器OS:REHL,CentOS,window server,AIX     桌面OS:WIN7,WIN10,MAC0S,Fedora     移动设备OS:Android,IOS,YunOS</code></pre><p><strong>开发接口</strong></p><p>ABI接口 （应用接口）</p><pre><code>OS与应用程序的底层接口,允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行如.apk无法在win7上运行如.exe无法在Android上运行</code></pre><p>API接口 （开发接口）</p><pre><code>库调用源代码和库之间的接口，实现库调用，因此同样的源代码可以在支持这个API的任何系统中编译</code></pre><p>POSIX:Portable Operating System Interface</p><pre><code>IEEE（国际组织）在操作系统上定义的一系列API标准</code></pre><p><strong>==练习==：</strong></p><pre><code>1.显示当前时间，格式：2016-06-18 10：20：30 2.显示前天是星期几3.设置当前时间为2019-08-07 06：05：10</code></pre><p>1.答：</p><pre><code>$ date %F&apos; &apos;%T</code></pre><p>2.答：</p><pre><code>$ date -d “2 days ago” +%A</code></pre><p>3.答：</p><pre><code>$ date 080706052019.10</code></pre><p>==<strong>DAY 2</strong>==</p><p>用户和内核空间</p><p>用户空间 user space</p><pre><code>用户空间必须通过系统接口（system call），才能向内核发出指令。</code></pre><p>内核空间 kerneL space</p><pre><code>内核空间可以执行任意命令，调用系统的一切资源。</code></pre><p>用户与内核的联系</p><pre><code>用户的程序无法直接访问硬件，只能通过操作系统间接访问硬件。两个空间相对独立，防止损害硬件，但用户能通过操作系统间接访问硬件。</code></pre><p>原理：</p><pre><code>上下文切换，会带来额外的资源损耗，减少上下文切换的次数，可以降低资源损耗。相当于用户空间与内核空间的来回切换。user space     user land application     #library#函数库,API接口     ↓↓↓     ↓↓↓（invoke）     ↓↓↓kernel space     #system call#系统调用接口     kernel     device driver     ↓↓↓hardware</code></pre><p>查看库调用</p><pre><code>$ ldd /bin/command$ ldd /bin/command</code></pre><p>跟踪底层系统调用</p><pre><code>$ strace command </code></pre><p>跟踪底层库调用</p><pre><code>$ ltrace command </code></pre><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>低级语言</p><pre><code> 机器语言：0、1汇编语言:和机器语言一一对应(学汇编，不会编)</code></pre><p>中级语言:系统级应用、驱动程序</p><pre><code>C语言</code></pre><p>高级语言：应用级程序开发</p><pre><code>Java、Python、Go、PHP、Objective-C、C#</code></pre><p>查看16进制的2进制代码</p><pre><code>$ hexdump -c  /bin/ls </code></pre><p>兼容分时系统工作原理</p><pre><code>原理：时间片 1s对于计算机来讲，相当的漫长 eg：1s分为100个时间片，每个时间片10ms任务绑定cpu：task cpu（主要是利用cpu中的三级缓存&quot;cache，L1,L2,L3&quot;，提高任务处理效率)</code></pre><p><strong>Linux起源</strong></p><pre><code>1991年的10月5日，完全免费的内核kernel诞生了</code></pre><p>兼容分时系统：Multics（多路信息计算系统）</p><pre><code>1964年发起了开发计划，于1969年失败，贝尔实验室退出计划。而后，ken thompson 为了打游戏，写了一个系统UNICS.（unix雏形）1969 ，雏形初现unics，基于B语言开发   1973，正式命名unix，基于C语言开发1977，BSD,伯克利大学流派开始开发1979，贝尔实验室流派，system V架构，因版权问题，不对学生提供源码，开始收费1984，minix操作系统，由Andrew S.Tanenbaum开发</code></pre><p>GUN（GNU is Not Unix）</p><pre><code>1984，由Richard Stallman发起并创建目的是为了所有软件开源、自由</code></pre><p>GPL(GUN General Public License)</p><pre><code>允许用户任意复制、传递、修改及再发布</code></pre><p>LGPL(Lesser General Public License)</p><pre><code>LGPL相对GPL较为宽松，允许不公开所有源码</code></pre><p>查看bash遵守GPL协议</p><pre><code>$ rpm -qi bash </code></pre><p>完整的类UNIX操作系统</p><pre><code>Linux内核+GNU工具</code></pre><p>linux三大主流</p><pre><code>Debian --UbantuRedHat --CentOSSlackware  --S.U.S.E</code></pre><p><strong>查看内核版本</strong></p><pre><code>$ uname -r </code></pre><p><strong>版本号解读</strong></p><pre><code>3.10.0-862.el7.x86_64 内核版本号 &apos;3.10.0&apos; 编译次数 &apos;862&apos;  次 厂商版本 &apos;el&apos; 商业Lunix 版本号 &apos;7&apos; centos7  &apos;x86-64&apos;  64位</code></pre><p><strong>登录前界面的配置文件</strong></p><pre><code>$ cat /etc/issue</code></pre><p><strong>哈希值校验</strong>（安装系统后检查系统的完整性）</p><pre><code>$ sha1sum /dev/sr0   </code></pre><p><strong>虚拟机软件:模拟硬件环境</strong></p><pre><code>vmware</code></pre><p><strong>windows下CMD命令行转换分区格式，数据不丢失（单向的FAT格式转NTFS ）</strong></p><pre><code>$ conver H:/fs:ntfs</code></pre><p><strong>Linux 准备</strong></p><pre><code>/dev/sda==硬盘/home/xu==c:\user/etc==注册表/usr==C:\Windows and C:\program files/boot 启动 mount point 挂载点</code></pre><p><strong>引导分区格式 MBR &amp; GPT</strong></p><p>MBR（主分区与扩展分区合起来不超过4个）</p><pre><code>MBR（主分区与扩展分区合起来不超过4个）主分区：     一个硬盘最多4个，主分区最小单位，只有一个活动的主分区。扩展分区：     一个硬盘最多只有一个扩展分区。但不可存储，需再次划分为更小的分区才能存储数据，即逻辑分区。逻辑驱动器：     由扩展分区二次划分。</code></pre><p>GPT（待补充）</p><p><strong>linux中分区格式</strong></p><pre><code>主分区编号：/dev/sda1~4 扩展分区编号：：/dev/sda5，6...</code></pre><p><strong>centos分区大小</strong> （建议）</p><pre><code>/boot 1g   系统挂载点/     50g   根目录/data 20g   做实验用的目录swap  2g    虚拟内存，大小一般为内存的1.5倍或者2倍</code></pre><p><strong>更改主机名</strong></p><pre><code>centos6$ nano /etc/sysconfig/networkcentos7$ nano /etc/hostname</code></pre><p>引导程序：</p><pre><code>$ grub</code></pre><p>查看内存：  </p><pre><code>$ free$ cat /proc/meminfo</code></pre><p>查看内存使用：</p><pre><code>$ free -h</code></pre><p><strong>用户id号：</strong></p><pre><code>id为0，则为管理员，与root名字无关</code></pre><p>uid</p><pre><code>超级用户root   uid：0普通用户       uid：500+或者1000+</code></pre><p>查看uid</p><pre><code>$ id -u   centos6 id 普通用户从500开始计算。。501 centos7 id 普通用户从1000开始计算。。1001</code></pre><p><strong>终端：</strong></p><p>物理终端</p><pre><code>/dev/tty* </code></pre><p>虚拟终端</p><pre><code>/dev/pts*</code></pre><p>查看当前终端：</p><pre><code>$ tty$ whoami$ who am i</code></pre><p>查看所有在线终端：</p><pre><code>$ who</code></pre><p>切换终端：</p><pre><code>$ chvt &lt;终端号&gt;$ ctrl+F1~F6</code></pre><p>关机命令：</p><pre><code>$ halt；$ poweroff；$ shutdown -r now</code></pre><p>设置登录前界面显示</p><pre><code>$ nano /etc/issue \d 天数  \l 显示当前登录终端号 \n 显示主机名字 \t 显示当前时间 \r 显示内核版本 \s 显示系统版本</code></pre><p><strong>==练习==：</strong></p><pre><code>1.在本机字符终端登录时，除显示原有信息外，再显示当前登录终端号，主机名和当前时间2.今天18：30自动关机，并提示用户</code></pre><p>1.答：  </p><pre><code>$ nano /etc/issue 在文件中加入以下代码 You are login on \l The hostname is \n It&apos;s \t now!</code></pre><p>2.答：</p><pre><code>$ shutdown 18：30 “you were be shutdown”</code></pre><p>==<strong>DAY</strong> 3==</p><p>多数企业基于安全问题，防止被针对版本漏洞而受到攻击，有关版本号的信息会进行自主修改。</p><p>许多公司在生产中所用系统版本相对滞后，以求稳定。</p><p>linux的系统相关配置皆放在文本文件中。</p><p><strong>查看centos版本</strong></p><p>centos6</p><pre><code>$ lsb_release -a （此程序centos7默认没有安装）</code></pre><p>centos7</p><pre><code>$ cat /etc/centos-release</code></pre><h6 id="字符界面下的编辑文本工具"><a href="#字符界面下的编辑文本工具" class="headerlink" title="字符界面下的编辑文本工具"></a>字符界面下的编辑文本工具</h6><pre><code>$ nano &lt;目录&gt;</code></pre><p>指定用户开机自动登录</p><pre><code>   编辑配置文件$ nano /etc/gdm/custom.conf   在字符 [daemon]下加入两行代码 [daemon] AutomaticLoginEnable=true AutomaticLogin=&lt;user&gt;</code></pre><p>查看cpu详细信息</p><pre><code>$ lscpu    Flags:所带有的关键特性，eg：mmx，针对视频加速处理的一个特性</code></pre><p>查看块设备</p><pre><code>$ lsblk</code></pre><p>查看网卡</p><pre><code>$ dmesg</code></pre><h3 id="交互式口"><a href="#交互式口" class="headerlink" title="交互式口"></a>交互式口</h3><p><strong>操作linux需要交互式接口</strong></p><p>图形化用户接口GUI(Graphic User Interface)</p><pre><code>GNOME(C,GTK)KDE(C++,QT)XFCE(轻量级桌面)应用于：X protocol, window manager, desktop三者之间的区别：底层库不同</code></pre><p>命令行接口CLI （效率高）</p><pre><code>shell程序：sh(bourn史蒂夫·伯恩)cshtcshksh(korn)bash (bournagain shell)GPLzshshell也被称为命令解释器。shell也属于开发语言，是一种简化、功能较弱的高级语言。</code></pre><h6 id="除了以上常提到的shell，还有一种shell较为特殊的shell-：nologin"><a href="#除了以上常提到的shell，还有一种shell较为特殊的shell-：nologin" class="headerlink" title="除了以上常提到的shell，还有一种shell较为特殊的shell ：nologin"></a>除了以上常提到的shell，还有一种shell较为特殊的shell ：nologin</h6><h6 id="用于底层系统服务，而非用户使用。"><a href="#用于底层系统服务，而非用户使用。" class="headerlink" title="用于底层系统服务，而非用户使用。"></a>用于底层系统服务，而非用户使用。</h6><p>查看当前所用shell</p><pre><code>$ echo $SHELL</code></pre><p>查看系统含有的所有shell</p><pre><code>$ cat /bin/shells</code></pre><p><strong>PS1变量 （用于命令行提示符）</strong></p><p>临时更改命令行提示符颜色</p><pre><code>$ PS1=&quot;\[\e[1;40;31m\][\u@\h \W]$\[\e[0m\]&quot;</code></pre><h6 id="1代表高亮-31-37代表字体颜色-40代表背景色"><a href="#1代表高亮-31-37代表字体颜色-40代表背景色" class="headerlink" title="1代表高亮,31~37代表字体颜色,40代表背景色"></a>1代表高亮,31~37代表字体颜色,40代表背景色</h6><p>永久更改命令提示符行颜色</p><pre><code>1.在/etc/profile.d/目录下2.创建&lt;任意名&gt;.sh3.将PS1=&quot;\[\e[1;40;31m\][\u@\h\W]$\[\e[0m\]&quot; 复制进去，保存4.source 文件，或者重启即可</code></pre><p><strong>PATH变量（用于存放外部命令的所有路径点）</strong></p><pre><code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin</code></pre><p><strong>帮助命令</strong></p><pre><code>$ help commandhelp中带*的表示被禁用</code></pre><h6 id="（）16进制中，0a换行符号，0d回车"><a href="#（）16进制中，0a换行符号，0d回车" class="headerlink" title="（）16进制中，0a换行符号，0d回车"></a>（）16进制中，0a换行符号，0d回车</h6><h3 id="三大类命令"><a href="#三大类命令" class="headerlink" title="三大类命令"></a>三大类命令</h3><p><strong>内部命令</strong></p><p>集成于当前系统所使用shell中的一些命令</p><p>查看所有内部命令</p><pre><code>$ enable</code></pre><p>禁用内部命令</p><pre><code>$ enable -n command</code></pre><p>启用内部命令</p><pre><code>$ enable command</code></pre><p>查看被禁用命令 </p><pre><code>$ enable -n</code></pre><p>查看可用命令</p><pre><code>$ enable -p</code></pre><p><strong>外部命令</strong></p><p>外部命令是在磁盘中独立的文件，使用的时候需要到磁盘中读取。</p><p>外部命令执行一次会产生缓存，有个命令叫hash，会从$PATH这个变量中定义的路径去搜索外部命令，从而执行该命令。</p><p>原理：</p><pre><code>外部命令一旦执行过后，命令所在路径会被hash缓存到内存中，下次再执行命令的时候就不必再到路径中去搜索，直接从hash中的路径读取，不用再到各个路径中去搜索，从而提升速度。</code></pre><p>关于hash的使用：</p><pre><code>$ hash                显示 hash 缓存 $ hash – l            显示 hash 缓存，可作为输入使用 $ hash – p path name  将命令全路径 path 起 别名为 name $ hash – t name       打印缓存中 name 的路径 $ hash – d name       清除 name 缓存 $ hash – r            清除缓存</code></pre><p><strong>别名命令</strong> <strong>alias</strong></p><p>外部命令与内部命令都可以被写为别名。</p><p>要想别名重启后不丢失永久生效，需将命令写当前用户目录下的.bashrc中</p><pre><code>$ nano /home/name/.bashrc      (普通用户,name换成你的用户名)$ nano /root/.bashrc           (超级用户)$ nano /etc/.bashrc            (所有用户）</code></pre><p>查看所有别名</p><pre><code>$ alias</code></pre><p>创建别名命令</p><pre><code>eg：  $ ailas copy=&apos;cp&apos; | &quot;cp&quot;  （&apos;&apos;跟&quot;&quot;都能学习）  $ alias -p copy=&apos;cp&apos;  （创建别名并打印出所有别名，仅支持&apos;&apos;）</code></pre><p>取消别名</p><pre><code>$ unalias </code></pre><p>取消所有别名</p><pre><code>$ unalias -r</code></pre><p>忽视别名的存在，强制执行原始命令</p><pre><code>$ \command$ `command`</code></pre><p><strong>判断命令的类别</strong> （tpye）</p><p>外部命令显示（路径）：</p><pre><code>eg：$ type echo    $ echo is /usr/bin/echo</code></pre><p>内部命令显示：</p><pre><code>eg：$ type type    $ type is a shell builtin</code></pre><p>别名命令则显示：（假设存在别名 alias copy=’cp’）</p><pre><code>eg：$ type copy    $ copy is aliased to `cp&apos;  </code></pre><p>显示命令的所有路径（或者类别）：</p><pre><code>$ type -a </code></pre><h6 id="优先级：别名命令-gt-内部命令-gt-外部命令"><a href="#优先级：别名命令-gt-内部命令-gt-外部命令" class="headerlink" title="优先级：别名命令&gt;内部命令&gt;外部命令"></a>优先级：别名命令&gt;内部命令&gt;外部命令</h6><p>在linux中，内存，属于易失性，要想配置永久生效，就要写到文件中。</p><p><strong>command</strong><br>组成部分</p><pre><code>[短选项]:-（可多个选项合并使用）eg:    $ ls -a -l    $ ls -la     $ ls -al  等同[长选项]:--eg：    $ ls --all    $ ls --help[参数]    可以是文件，也可以是路径等等。</code></pre><p><strong>快捷键</strong>（待补充）</p><p>快速退出终端</p><pre><code>ctrl+d </code></pre><p>强制结束</p><pre><code>ctrl+c </code></pre><p><strong>日期和时间</strong></p><p>硬件时间</p><pre><code>$ clock = $ hwclock $ clock   显示硬件时间$ clock -s，--systohc修正系统时间，以硬件时间为准$ clock -w，--hctosys修正硬件时间，以系统时间为准</code></pre><p>系统时间</p><pre><code>$ date     显示系统时间$ date +%s 计算从1970.1.1至今一共多少秒$ date -s  根据描述设置时间$ date -d  根据描述显示时间$ date -d  @&lt;秒&gt; +&quot;%F %T&quot;$ date -d &quot;2018-08-08 20:00:00&quot;+%s</code></pre><p>时区路径 /etc/localtime</p><p>更改时区</p><p>centos6.x</p><pre><code>$ tzselect</code></pre><p>centos7.x</p><pre><code>$ timedatectl set-timezone &lt;时区路径&gt;</code></pre><p>日历</p><pre><code>$ cal 显示当月日历$ cal -y 显示当年日历$ cal &lt;年份&gt; 显示该年份日历</code></pre><h6 id="与远程服务器同步时间"><a href="#与远程服务器同步时间" class="headerlink" title="与远程服务器同步时间"></a>与远程服务器同步时间</h6><pre><code>$ ntpdate &lt;ip&gt;      （ip较为特殊，需配置过的ip地址才能同步）</code></pre><h6 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h6><p>发送消息给所有在线主机，多用于提示</p><pre><code>$ wall “system will shutdown at 19：00 ”</code></pre><h4 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h4><p>获取帮助的能力决定了技术的能力</p><p>了解外部命令的基本功能</p><pre><code>$ whatis</code></pre><p>系统使用一定时间后，会生成生成数据库或者手动创建数据库</p><pre><code>$ whatis command数据库</code></pre><p><strong>手动创建whatis数据库</strong></p><p>centos 6.x</p><pre><code>$ makewhatis</code></pre><p>centos 7.x</p><pre><code>$ mandb</code></pre><p>了解命令的基本功能</p><pre><code>内部命令：$ help command外部命令：$ command --help</code></pre><p>寻找命令所在路径</p><pre><code>$ whereis</code></pre><h6 id="man-and-info（有待详细说明）"><a href="#man-and-info（有待详细说明）" class="headerlink" title="man and info（有待详细说明）"></a>man and info（有待详细说明）</h6><p>man帮助（manual用户手册）</p><p>man章节分类</p><pre><code>1.用户命令2.系统调用3.C库调用4.设备文件及特殊文件5.配置文件格式6.游戏7.杂项8.管理类命令9.Linux内核API</code></pre><p>使用命令获取章节号</p><pre><code>$ whatis command</code></pre><p>指定man章节号寻找帮助</p><pre><code>$ man &lt;章节号&gt; command</code></pre><p>在man中搜索关键词</p><pre><code>/ &lt;关键词&gt;  or ?&lt;关键词&gt;</code></pre><p>man的配置文件目录</p><p>centos6</p><pre><code>man.conf(作用待了解)</code></pre><p>centos7</p><pre><code>man_db.conf(作用待了解)</code></pre><p>待续….</p>]]></content>
      
      
    </entry>
    
  
  
</search>
